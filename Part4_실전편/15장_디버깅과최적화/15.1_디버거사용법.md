# 15.1 디버거 사용법

## 개념 정리

### 디버거(Debugger)란?

디버거는 **프로그램의 실행을 제어하고 내부 상태를 관찰**할 수 있는 개발 도구입니다. 프로그램에서 발생하는 버그를 체계적으로 찾고 분석하는 과정을 지원합니다.

#### 디버거의 핵심 개념

1. **실행 제어 (Execution Control)**
   - 프로그램의 실행을 일시 정지, 재개, 단계별 실행
   - 특정 지점에서 실행을 멈추는 중단점(Breakpoint) 설정

2. **상태 관찰 (State Inspection)**
   - 변수의 값, 메모리 내용, 레지스터 상태 확인
   - 함수 호출 스택 추적

3. **코드 추적 (Code Tracing)**
   - 프로그램의 실행 경로 추적
   - 함수 호출 순서와 매개변수 확인

### 디버깅의 기본 원리

#### 1. 심볼 정보 (Symbol Information)
```bash
# 디버그 정보 포함하여 컴파일
gcc -g -O0 -o program program.c
```

- **-g**: 디버그 심볼 정보 포함
- **-O0**: 최적화 비활성화 (디버깅 용이성)
- 심볼 정보가 있어야 변수명, 함수명, 줄 번호 등을 확인 가능

#### 2. 중단점 (Breakpoint)
- **기능**: 특정 위치에서 프로그램 실행 일시 정지
- **종류**:
  - **함수 중단점**: 함수 시작점에서 정지
  - **라인 중단점**: 특정 소스 라인에서 정지
  - **조건부 중단점**: 특정 조건 만족 시에만 정지
  - **데이터 중단점**: 메모리 값 변경 시 정지

#### 3. 단계별 실행 (Step Execution)
- **Step Into**: 함수 호출 시 함수 내부로 진입
- **Step Over**: 함수 호출을 하나의 단계로 취급
- **Step Out**: 현재 함수에서 빠져나올 때까지 실행

### 주요 디버거 소개

#### 1. GDB (GNU Debugger)

**특징**:
- Linux/Unix 환경의 표준 디버거
- 명령줄 기반 인터페이스
- 강력한 기능과 높은 확장성

**주요 기능**:
```bash
# 기본 실행 제어
(gdb) run [arguments]           # 프로그램 실행
(gdb) continue                  # 실행 계속
(gdb) quit                      # 디버거 종료

# 중단점 관리
(gdb) break main                # main 함수에 중단점
(gdb) break file.c:25          # 특정 파일의 25번 라인
(gdb) break func if x > 10     # 조건부 중단점
(gdb) info breakpoints         # 중단점 목록
(gdb) delete 1                 # 1번 중단점 삭제

# 단계별 실행
(gdb) step                     # 한 줄 실행 (함수 내부 진입)
(gdb) next                     # 한 줄 실행 (함수 건너뜀)
(gdb) finish                   # 현재 함수 끝까지 실행

# 변수 및 메모리 확인
(gdb) print variable_name      # 변수 값 출력
(gdb) info locals             # 지역변수 목록
(gdb) info args               # 함수 매개변수
(gdb) backtrace               # 스택 추적
(gdb) x/10i $pc               # 현재 위치 명령어들
```

#### 2. Visual Studio Debugger

**특징**:
- Windows 환경의 통합 개발 환경
- GUI 기반의 직관적 인터페이스
- 시각적 디버깅 도구 제공

**주요 기능**:
- **Watch Window**: 변수 값 실시간 모니터링
- **Call Stack**: 함수 호출 스택 시각화
- **Memory Window**: 메모리 내용 16진수로 표시
- **Immediate Window**: 실행 중 표현식 평가

#### 3. LLDB

**특징**:
- LLVM 프로젝트의 디버거
- macOS Xcode의 기본 디버거
- 모던한 아키텍처와 API

**주요 특징**:
- Python 스크립팅 지원
- 표현식 평가 엔진
- 크로스 플랫폼 지원

### 디버깅 전략과 방법론

#### 1. 체계적 디버깅 프로세스

```
1. 문제 재현 (Reproduce)
   ↓
2. 최소 테스트 케이스 생성 (Minimize)
   ↓
3. 가설 수립 (Hypothesize)
   ↓
4. 디버거로 검증 (Verify)
   ↓
5. 수정 및 테스트 (Fix & Test)
```

#### 2. 효과적인 중단점 설정

**전략적 중단점 위치**:
- **함수 시작점**: 매개변수 값 확인
- **루프 시작/끝**: 반복 상태 확인
- **조건문**: 분기 조건 확인
- **메모리 할당/해제**: 메모리 관련 문제 추적

**조건부 중단점 활용**:
```bash
# 특정 반복에서만 중단
(gdb) break loop_function if i == 100

# 포인터가 NULL일 때 중단
(gdb) break function if ptr == 0

# 특정 값 범위에서 중단
(gdb) break calculate if result < 0 || result > 1000
```

#### 3. 변수 관찰 기법

**변수 자동 출력**:
```bash
# 매 단계마다 변수 값 자동 출력
(gdb) display variable_name
(gdb) display *pointer_name
(gdb) display array[0]@10      # 배열 원소 10개
```

**복잡한 데이터 구조 탐색**:
```bash
# 구조체 멤버 접근
(gdb) print student.name
(gdb) print student->score

# 연결 리스트 순회
(gdb) print *head
(gdb) print *head->next
(gdb) print *head->next->next
```

### 메모리 디버깅

#### 1. 메모리 내용 확인

```bash
# 메모리 내용 다양한 형식으로 출력
(gdb) x/10x address        # 16진수로 10워드
(gdb) x/20c string_ptr     # 문자로 20바이트
(gdb) x/5i function_ptr    # 명령어로 5개
(gdb) x/10d array_ptr      # 10진수로 10개
```

#### 2. 메모리 감시 (Watchpoint)

```bash
# 메모리 위치 변경 감시
(gdb) watch *pointer       # 쓰기 감시
(gdb) rwatch *pointer      # 읽기 감시
(gdb) awatch *pointer      # 읽기/쓰기 모두 감시
```

#### 3. 메모리 누수 디버깅

**Valgrind와 연동**:
```bash
# Valgrind로 메모리 문제 검출
valgrind --tool=memcheck --leak-check=full ./program

# GDB에서 Valgrind 결과 분석
gdb ./program
(gdb) run < input_file
```

### 고급 디버깅 기법

#### 1. 코어 덤프 분석

```bash
# 코어 덤프 활성화
ulimit -c unlimited

# 코어 덤프 파일로 디버깅
gdb ./program core

# 크래시 시점 상태 분석
(gdb) backtrace
(gdb) info registers
(gdb) x/20i $pc
```

#### 2. 원격 디버깅

```bash
# 원격 디버깅 서버 시작
gdbserver :1234 ./program

# 원격 연결
gdb ./program
(gdb) target remote hostname:1234
```

#### 3. 스크립트를 통한 자동화

**GDB 스크립트 예제**:
```bash
# debug_script.gdb
set pagination off
break main
run
set $i = 0
while $i < 10
    print array[$i]
    set $i = $i + 1
end
continue
```

### 디버깅 모범 사례

#### 1. 코드 준비사항

**디버그 친화적 코딩**:
```c
// 명확한 변수명 사용
int student_count = 0;  // 좋음
int n = 0;             // 나쁨

// 의미 있는 함수 분리
void process_student_grades() {
    validate_input();
    calculate_average();
    update_records();
}

// 어서션 활용
#include <assert.h>
assert(pointer != NULL);
assert(array_size > 0);
```

#### 2. 로그와 디버거 조합

**디버그 로그 활용**:
```c
#ifdef DEBUG
    #define DBG_PRINT(fmt, ...) \
        printf("[%s:%d] " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#else
    #define DBG_PRINT(fmt, ...)
#endif

// 사용 예
DBG_PRINT("Processing item %d, value = %f", i, value);
```

#### 3. 단위 테스트와 디버깅

**테스트 기반 디버깅**:
```c
// 최소 재현 테스트
void test_minimal_case() {
    int result = problematic_function(simple_input);
    assert(result == expected_value);
}

// 경계 조건 테스트
void test_edge_cases() {
    test_with_null_input();
    test_with_empty_array();
    test_with_maximum_size();
}
```

### 디버깅 도구 확장

#### 1. IDE 통합 디버거

**Visual Studio Code + GDB**:
- `launch.json` 설정으로 디버깅 환경 구성
- 중단점 시각화 및 변수 감시
- 터미널 통합 디버깅

**CLion 디버거**:
- 지능형 중단점 설정
- 메모리 뷰 및 평가 창
- CMake 프로젝트 통합

#### 2. 정적 분석 도구와 연동

**Clang Static Analyzer**:
```bash
# 정적 분석 수행
clang --analyze source.c

# 결과를 바탕으로 디버깅 포인트 설정
```

**Cppcheck**:
```bash
# 코드 품질 검사
cppcheck --enable=all source.c

# 발견된 문제점을 디버거로 추적
```

### 성능 디버깅

#### 1. 프로파일링과 디버깅

**gprof 사용**:
```bash
# 프로파일링 정보 포함 컴파일
gcc -pg -g -o program program.c

# 실행 및 프로파일 생성
./program
gprof program gmon.out > profile.txt

# 병목 지점을 디버거로 분석
gdb ./program
(gdb) break slow_function
```

#### 2. 실시간 성능 모니터링

**perf와 GDB 연동**:
```bash
# 성능 이벤트 모니터링
perf record ./program
perf report

# 핫스팟을 GDB로 분석
```

이러한 디버거 사용법을 체계적으로 학습하고 활용하면, C 프로그램의 복잡한 버그도 효율적으로 찾아내고 해결할 수 있습니다.