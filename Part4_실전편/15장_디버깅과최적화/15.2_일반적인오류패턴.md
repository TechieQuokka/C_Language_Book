# 15.2 일반적인 오류 패턴

## 개념 정리

### 오류의 분류와 특성

C언어 프로그래밍에서 발생하는 오류는 **발생 시점**과 **원인**에 따라 체계적으로 분류할 수 있습니다. 각 오류 유형을 이해하면 효과적인 디버깅 전략을 수립할 수 있습니다.

#### 1. 시점별 오류 분류

**컴파일 타임 오류 (Compile-time Errors)**
- **발생 시점**: 소스 코드를 기계어로 변환하는 단계
- **특징**: 프로그램 실행 전에 발견됨
- **장점**: 비교적 발견과 수정이 쉬움

**링크 타임 오류 (Link-time Errors)**
- **발생 시점**: 여러 오브젝트 파일을 하나의 실행 파일로 결합하는 단계
- **특징**: 컴파일은 성공하지만 링킹에서 실패
- **주요 원인**: 함수나 변수의 정의 누락, 라이브러리 부재

**런타임 오류 (Runtime Errors)**
- **발생 시점**: 프로그램 실행 중
- **특징**: 예측하기 어렵고 디버깅이 복잡
- **위험성**: 시스템 크래시나 보안 취약점으로 이어질 수 있음

#### 2. 원인별 오류 분류

**구문 오류 (Syntax Errors)**
- 언어 문법 규칙 위반
- 컴파일러가 즉시 발견

**의미 오류 (Semantic Errors)**
- 문법적으로는 올바르지만 의도와 다른 동작
- 논리적 결함으로 인한 잘못된 결과

**런타임 오류 (Runtime Errors)**
- 실행 중 발생하는 예외적 상황
- 메모리 접근 위반, 0으로 나누기 등

### 주요 오류 패턴 분석

#### 1. 포인터 관련 오류

포인터는 C언어의 강력한 기능이지만 **가장 많은 오류의 원인**이기도 합니다.

**1-1. NULL 포인터 역참조 (Null Pointer Dereference)**

**개념**:
- NULL로 설정된 포인터를 통해 메모리에 접근하려는 시도
- 대부분의 시스템에서 세그멘테이션 폴트 발생

**발생 패턴**:
```c
// 패턴 1: 초기화하지 않은 포인터
int* ptr;  // 쓰레기 값
*ptr = 10; // 위험!

// 패턴 2: 명시적 NULL 할당 후 사용
int* ptr = NULL;
*ptr = 10; // 세그멘테이션 폴트

// 패턴 3: 함수 반환값 확인 누락
char* str = malloc(100);
strcpy(str, "Hello"); // malloc 실패 시 NULL 역참조
```

**예방 방법**:
```c
// 방어적 프로그래밍
int* ptr = malloc(sizeof(int));
if (ptr != NULL) {
    *ptr = 10;
    // 사용
    free(ptr);
    ptr = NULL; // 댕글링 포인터 방지
}
```

**1-2. 댕글링 포인터 (Dangling Pointer)**

**개념**:
- 해제된 메모리를 가리키는 포인터
- 메모리가 재할당되면 예상치 못한 값이 나타남

**발생 패턴**:
```c
// 패턴 1: 해제 후 사용
int* ptr = malloc(sizeof(int));
*ptr = 42;
free(ptr);
printf("%d", *ptr); // 정의되지 않은 동작

// 패턴 2: 스택 변수 주소 반환
int* get_address() {
    int local = 10;
    return &local; // 함수 종료 시 지역변수 소멸
}

// 패턴 3: 배열 경계 벗어난 포인터
int arr[5];
int* ptr = &arr[5]; // 배열 끝을 넘어선 주소
*ptr = 100; // 정의되지 않은 동작
```

**1-3. 이중 해제 (Double Free)**

**개념**:
- 같은 메모리 블록을 두 번 이상 해제
- 힙 손상이나 프로그램 종료 야기

**발생 패턴**:
```c
// 패턴 1: 직접적인 이중 해제
int* ptr = malloc(sizeof(int));
free(ptr);
free(ptr); // 이중 해제

// 패턴 2: 포인터 별칭으로 인한 이중 해제
int* ptr1 = malloc(sizeof(int));
int* ptr2 = ptr1;
free(ptr1);
free(ptr2); // 같은 메모리 이중 해제
```

#### 2. 배열 관련 오류

**2-1. 버퍼 오버플로우 (Buffer Overflow)**

**개념**:
- 배열의 경계를 넘어서는 메모리 접근
- 보안 취약점의 주요 원인

**발생 메커니즘**:
```
배열 메모리 레이아웃:
[배열 데이터][기타 변수들][함수 반환 주소][...]
      ↑            ↑            ↑
   정상 영역    오버플로우 영역   공격 대상
```

**발생 패턴**:
```c
// 패턴 1: 배열 인덱스 오류
int arr[10];
arr[10] = 5; // 인덱스 10은 존재하지 않음

// 패턴 2: 문자열 경계 초과
char buffer[10];
strcpy(buffer, "This is too long"); // 버퍼 크기 초과

// 패턴 3: 루프 조건 오류
for (int i = 0; i <= 10; i++) { // <= 대신 <
    arr[i] = i;
}
```

**2-2. 버퍼 언더플로우 (Buffer Underflow)**

**개념**:
- 배열의 시작점보다 앞쪽 메모리에 접근
- 음수 인덱스 사용 시 발생

**발생 패턴**:
```c
int arr[10];
int index = -1;
arr[index] = 5; // 배열 앞쪽 메모리 접근
```

#### 3. 메모리 관리 오류

**3-1. 메모리 누수 (Memory Leak)**

**개념**:
- 할당된 메모리를 해제하지 않아 사용 가능한 메모리가 감소
- 장기 실행 프로그램에서 심각한 문제

**누수 패턴**:
```c
// 패턴 1: 단순 해제 누락
void function() {
    char* buffer = malloc(1000);
    // 작업 수행
    // free(buffer); // 누락!
    return;
}

// 패턴 2: 조건부 누수
void conditional_function(int condition) {
    char* buffer = malloc(1000);
    if (condition) {
        free(buffer);
        return; // 정상 해제
    }
    // condition이 false일 때 누수
    return;
}

// 패턴 3: 재할당 시 누수
char* ptr = malloc(100);
ptr = malloc(200); // 이전 메모리 블록 누수
```

**3-2. 초기화되지 않은 메모리 사용**

**개념**:
- `malloc`으로 할당한 메모리는 초기화되지 않음
- 예측할 수 없는 쓰레기 값 포함

**문제 상황**:
```c
// 초기화되지 않은 값 사용
int* arr = malloc(10 * sizeof(int));
int sum = 0;
for (int i = 0; i < 10; i++) {
    sum += arr[i]; // 쓰레기 값들의 합
}

// 해결방법
int* arr = calloc(10, sizeof(int)); // 0으로 초기화
// 또는
int* arr = malloc(10 * sizeof(int));
memset(arr, 0, 10 * sizeof(int));
```

#### 4. 문자열 처리 오류

**4-1. 널 종료자 누락**

**개념**:
- C 문자열은 반드시 '\0'으로 끝나야 함
- 널 종료자가 없으면 문자열 함수들이 오동작

**발생 패턴**:
```c
// 패턴 1: 배열 크기 부족
char str[5] = {'H', 'e', 'l', 'l', 'o'}; // '\0' 공간 없음
printf("%s", str); // 버퍼 오버런

// 패턴 2: strncpy 사용 시 주의사항
char dest[10];
strncpy(dest, "Hello World", 10); // '\0' 보장 안됨
dest[9] = '\0'; // 수동으로 추가 필요

// 패턴 3: 메모리 복사 실수
char src[] = "Hello";
char* dest = malloc(5); // '\0' 공간 부족
memcpy(dest, src, 5); // 널 종료자 누락
```

**4-2. 문자열 리터럴 수정 시도**

**개념**:
- 문자열 리터럴은 읽기 전용 메모리에 저장
- 수정 시도 시 세그멘테이션 폴트

**문제 코드**:
```c
char* str = "Hello"; // 읽기 전용 영역
str[0] = 'h'; // 세그멘테이션 폴트

// 해결방법
char str[] = "Hello"; // 스택에 복사본 생성
str[0] = 'h'; // 수정 가능
```

#### 5. 타입 관련 오류

**5-1. 정수 오버플로우 (Integer Overflow)**

**개념**:
- 변수가 표현할 수 있는 범위를 초과
- 예상치 못한 값으로 변환

**발생 예시**:
```c
// signed 오버플로우
int max_int = INT_MAX; // 2147483647
int overflow = max_int + 1; // -2147483648 (언더플로우)

// unsigned 오버플로우
unsigned int max_uint = UINT_MAX; // 4294967295
unsigned int overflow = max_uint + 1; // 0

// 곱셈 오버플로우
int large = 100000;
int result = large * large; // 오버플로우 발생
```

**5-2. 부호 있는/없는 타입 혼용**

**개념**:
- signed와 unsigned 타입 간 변환 시 예상치 못한 결과
- 비교 연산에서 특히 문제

**문제 상황**:
```c
int signed_val = -1;
unsigned int unsigned_val = 1;

if (signed_val < unsigned_val) {
    // 실행되지 않음! -1이 큰 양수로 변환됨
    printf("This won't print\n");
}

// 배열 인덱스에서의 문제
int arr[10];
int index = -1;
if (index < sizeof(arr)/sizeof(arr[0])) { // false!
    arr[index] = 5; // 버퍼 언더플로우
}
```

#### 6. 동시성 관련 오류

**6-1. 경쟁 조건 (Race Condition)**

**개념**:
- 여러 스레드가 공유 자원에 동시 접근
- 실행 순서에 따라 결과가 달라짐

**발생 패턴**:
```c
// 전역 변수 동시 수정
int global_counter = 0;

void* thread_function(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        global_counter++; // 원자적이지 않음
    }
    return NULL;
}

// 예상: 2000000, 실제: 예측 불가능한 값
```

**6-2. 데드락 (Deadlock)**

**개념**:
- 두 개 이상의 스레드가 서로의 자원을 기다리며 무한 대기
- 프로그램 완전 정지

**발생 패턴**:
```c
pthread_mutex_t mutex1, mutex2;

// 스레드 1
pthread_mutex_lock(&mutex1);
pthread_mutex_lock(&mutex2); // 스레드 2가 소유 중
// ...

// 스레드 2
pthread_mutex_lock(&mutex2);
pthread_mutex_lock(&mutex1); // 스레드 1이 소유 중
// 데드락 발생
```

### 오류 탐지 및 예방 방법

#### 1. 정적 분석 도구 활용

**컴파일러 경고 최대화**:
```bash
gcc -Wall -Wextra -Werror -pedantic source.c
```

**주요 경고 옵션**:
- `-Wall`: 기본적인 경고들
- `-Wextra`: 추가 경고들
- `-Werror`: 경고를 오류로 취급
- `-Wshadow`: 변수 가리기 경고
- `-Wformat=2`: 포맷 문자열 검사

**정적 분석기**:
```bash
# Clang Static Analyzer
clang --analyze source.c

# Cppcheck
cppcheck --enable=all source.c

# PC-lint (상용)
pc-lint source.c
```

#### 2. 동적 분석 도구 활용

**AddressSanitizer (ASan)**:
```bash
gcc -fsanitize=address -g -o program source.c
./program # 메모리 오류 자동 검출
```

**Valgrind**:
```bash
valgrind --tool=memcheck --leak-check=full ./program
```

**Thread Sanitizer**:
```bash
gcc -fsanitize=thread -g -o program source.c
./program # 경쟁 조건 검출
```

#### 3. 방어적 프로그래밍 기법

**입력 검증**:
```c
int safe_divide(int a, int b) {
    if (b == 0) {
        fprintf(stderr, "Division by zero error\n");
        return 0; // 또는 오류 코드 반환
    }
    return a / b;
}
```

**범위 검사**:
```c
void safe_array_access(int* arr, int size, int index, int value) {
    if (arr == NULL) {
        fprintf(stderr, "Array is NULL\n");
        return;
    }
    if (index < 0 || index >= size) {
        fprintf(stderr, "Index out of bounds: %d\n", index);
        return;
    }
    arr[index] = value;
}
```

**메모리 관리 래퍼**:
```c
void* safe_malloc(size_t size) {
    void* ptr = malloc(size);
    if (ptr == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    return ptr;
}

void safe_free(void** ptr) {
    if (ptr && *ptr) {
        free(*ptr);
        *ptr = NULL;
    }
}
```

#### 4. 코딩 표준 및 관례

**변수 초기화 원칙**:
```c
// 항상 초기화
int count = 0;
char* buffer = NULL;
FILE* file = NULL;

// 구조체 초기화
struct Point p = {0, 0};
// 또는
struct Point p;
memset(&p, 0, sizeof(p));
```

**함수 반환값 검사**:
```c
FILE* file = fopen("data.txt", "r");
if (file == NULL) {
    perror("Failed to open file");
    exit(EXIT_FAILURE);
}

int* ptr = malloc(sizeof(int));
if (ptr == NULL) {
    fprintf(stderr, "Memory allocation failed\n");
    exit(EXIT_FAILURE);
}
```

**어서션 활용**:
```c
#include <assert.h>

void process_array(int* arr, int size) {
    assert(arr != NULL);
    assert(size > 0);

    for (int i = 0; i < size; i++) {
        assert(i >= 0 && i < size);
        arr[i] = i * 2;
    }
}
```

### 오류 패턴별 디버깅 전략

#### 1. 메모리 관련 오류 디버깅

**단계별 접근**:
1. **AddressSanitizer로 1차 검사**
2. **Valgrind로 상세 분석**
3. **GDB로 정확한 위치 파악**
4. **코드 리뷰로 패턴 분석**

#### 2. 논리 오류 디버깅

**체계적 접근**:
1. **최소 재현 케이스 작성**
2. **입력과 출력 추적**
3. **중간 계산 값 검증**
4. **알고리즘 정확성 재검토**

#### 3. 성능 관련 문제

**프로파일링 기반 접근**:
1. **gprof로 함수별 시간 측정**
2. **병목 지점 식별**
3. **알고리즘 복잡도 분석**
4. **캐시 효율성 검토**

이러한 체계적인 오류 패턴 이해와 예방 기법을 통해 안정적이고 신뢰할 수 있는 C 프로그램을 개발할 수 있습니다.