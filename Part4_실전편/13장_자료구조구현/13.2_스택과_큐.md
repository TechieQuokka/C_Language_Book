# 13.2 스택과 큐 (Stack and Queue)

## 핵심 개념: 제약된 접근의 철학

스택과 큐는 **"제약된 접근"**이라는 철학을 구현한 추상 데이터 타입입니다. 이들은 **"제약이 자유를 준다"**는 역설적 진리를 보여줍니다. 접근을 제한함으로써 더 명확한 의미와 효율적인 연산을 제공합니다.

### 추상 데이터 타입 (ADT)의 본질

**ADT**는 **"무엇을 할 수 있는가"**에 집중하고 **"어떻게 구현되는가"**는 숨깁니다. 스택과 큐는 이러한 추상화의 완벽한 예시입니다:

- **인터페이스**: 허용되는 연산들의 명세
- **구현**: 내부 데이터 구조와 알고리즘
- **불변조건**: 항상 유지되어야 하는 속성들

## 스택 (Stack): LIFO의 수학적 본질

### 스택의 수학적 정의

스택을 수학적으로 정의하면:
- **집합 S**: 스택에 저장된 원소들
- **순서 관계**: 시간적 순서 (temporal ordering)
- **접근 제약**: 가장 최근에 삽입된 원소만 접근 가능

**LIFO 원리**: Last In, First Out
이는 수학의 **역함수(Inverse Function)** 개념과 유사합니다.

### 스택의 기하학적 해석

스택을 기하학적으로 해석하면:
- **수직적 구조**: 아래에서 위로 쌓는 구조
- **중력의 은유**: 가장 위의 원소만 제거 가능
- **단조성**: 삽입과 삭제 지점이 동일

**철학적 의미**: 스택은 **"자연스러운 쌓기"**의 디지털 구현입니다.

### 스택의 기본 연산과 복잡도

#### 필수 연산들
- **push(item)**: 원소 삽입 - O(1)
- **pop()**: 최상단 원소 제거 및 반환 - O(1)
- **top()/peek()**: 최상단 원소 조회 (제거하지 않음) - O(1)
- **isEmpty()**: 스택이 비어있는지 확인 - O(1)

#### 부가 연산들
- **size()**: 스택의 크기 - O(1) 또는 O(n)
- **clear()**: 모든 원소 제거 - O(n)

**수학적 특성**: 모든 기본 연산이 **상수 시간**에 수행됩니다.

### 함수 호출과 스택의 관계

#### 콜 스택 (Call Stack)의 수학적 모델

**콜 스택**은 재귀 함수의 수학적 모델입니다:
- **함수 호출**: f(x) → 스택에 푸시
- **함수 반환**: 스택에서 팝
- **재귀 깊이**: 스택의 높이와 정비례

**수학적 의미**: 재귀는 **"자기 참조적 정의"**이며, 스택은 이를 **"선형 구조로 전개"**합니다.

#### 스택 프레임의 구조
각 스택 프레임에는:
- **매개변수**: 함수에 전달된 인자들
- **지역 변수**: 함수 내부에서 선언된 변수들
- **반환 주소**: 함수 종료 후 돌아갈 위치
- **이전 프레임 포인터**: 호출자의 프레임 위치

### 스택의 구현 방식

#### 배열 기반 구현
**장점**:
- **캐시 효율성**: 연속된 메모리 접근
- **구현 단순성**: 인덱스 기반 접근
- **메모리 오버헤드 없음**: 포인터 불필요

**단점**:
- **고정 크기**: 컴파일 타임에 크기 결정
- **오버플로우 위험**: 크기 초과 시 오류

#### 연결 리스트 기반 구현
**장점**:
- **동적 크기**: 런타임에 크기 조정
- **메모리 효율성**: 필요한 만큼만 할당

**단점**:
- **포인터 오버헤드**: 추가 메모리 필요
- **캐시 성능**: 비연속적 메모리 접근

## 큐 (Queue): FIFO의 공정성 원리

### 큐의 수학적 정의

- **집합 Q**: 큐에 저장된 원소들
- **순서 보존**: 삽입 순서와 삭제 순서 일치
- **공정성**: 먼저 온 것이 먼저 처리됨

**FIFO 원리**: First In, First Out
이는 **"공정한 대기"**의 수학적 모델입니다.

### 큐의 기하학적 해석

- **수평적 구조**: 한쪽 끝에서 삽입, 다른 쪽 끝에서 삭제
- **파이프라인**: 데이터의 일방향 흐름
- **병목 현상**: 출구의 처리 속도가 전체 성능 결정

### 큐의 기본 연산과 복잡도

#### 필수 연산들
- **enqueue(item)**: 후단에 원소 삽입 - O(1)
- **dequeue()**: 전단에서 원소 제거 및 반환 - O(1)
- **front()**: 전단 원소 조회 - O(1)
- **rear()/back()**: 후단 원소 조회 - O(1)
- **isEmpty()**: 큐가 비어있는지 확인 - O(1)

### 확률론적 관점에서의 큐

#### 큐잉 이론 (Queueing Theory)

큐잉 이론에서 큐는:
- **도착률 λ**: 단위 시간당 도착하는 요청 수
- **서비스율 μ**: 단위 시간당 처리 가능한 요청 수
- **안정성 조건**: λ < μ (도착률 < 서비스율)

**리틀의 법칙**: L = λW
- L: 평균 대기열 길이
- λ: 도착률
- W: 평균 대기시간

**수학적 의미**: 시스템의 **처리량과 지연시간** 사이의 근본적 관계

### 원형 큐 (Circular Queue)의 수학적 아름다움

#### 모듈러 산술의 적용

원형 큐에서 인덱스 계산:
- **다음 위치**: (index + 1) % size
- **이전 위치**: (index - 1 + size) % size
- **거리 계산**: (end - start + size) % size

**수학적 의미**: 선형 구조를 **원형으로 매핑**하여 공간 활용도를 높입니다.

#### 순환군의 구현

원형 큐는 수학의 **순환군(Cyclic Group)**을 구현합니다:
- **항등원**: 빈 큐 상태
- **연산**: 삽입과 삭제
- **순환성**: 인덱스의 주기적 반복

#### 가득 참과 비어있음의 구별

**문제**: (front == rear)일 때 가득 참과 비어있음을 구별하기 어려움

**해결 방법들**:
1. **카운터 사용**: 별도 변수로 원소 개수 추적
2. **한 칸 비우기**: size-1개 원소만 저장
3. **플래그 사용**: 가득 참 상태를 별도 변수로 표시

## 스택과 큐의 대칭성과 대조성

### 시간 복잡도의 동등성

두 자료구조 모두 기본 연산이 **O(1)**입니다:
- **스택**: push(), pop(), top()
- **큐**: enqueue(), dequeue(), front()

**수학적 의미**: 제약된 접근이 **효율성을 보장**합니다.

### 메모리 접근 패턴의 차이

- **스택**: 한 지점에서의 집중적 접근 (캐시 친화적)
- **큐**: 두 지점에서의 분산적 접근 (캐시 미스 가능성)

### 응용 분야의 대조

#### 스택의 응용
- **깊이 우선 탐색(DFS)**: 탐험의 백트래킹
- **구문 분석**: 괄호 매칭, 후위 표기법
- **실행 문맥 관리**: 함수 호출, 예외 처리
- **실행 취소**: Undo 기능 구현

#### 큐의 응용
- **너비 우선 탐색(BFS)**: 레벨별 탐색
- **스케줄링**: 프로세스, 작업 대기열
- **버퍼링**: 데이터 스트림 처리
- **이벤트 처리**: 이벤트 기반 시스템

## 덱(Deque): 양단 큐의 일반화

### 수학적 일반화

덱은 스택과 큐의 **상위 집합**입니다:
- **스택 ⊆ 덱**: 한쪽 끝만 사용
- **큐 ⊆ 덱**: 양쪽 끝을 다르게 사용
- **덱**: 양쪽 끝 모두 자유롭게 사용

### 대칭성의 수학적 의미

덱의 연산들은 **대칭적**입니다:
- push_front() ↔ push_back()
- pop_front() ↔ pop_back()
- front() ↔ back()

이는 **군론(Group Theory)**의 **역원(Inverse Element)** 개념과 유사합니다.

### 덱의 구현 방식

#### 동적 배열 기반
- **중앙에서 시작**: 양방향 확장 가능
- **재할당 최적화**: 기하급수적 증가
- **amortized O(1)**: 평균적으로 상수 시간

#### 블록 기반 (Block-based)
- **작은 블록들의 연결**: 메모리 지역성 개선
- **간접 참조**: 블록 테이블을 통한 접근
- **균형**: 메모리 효율성과 접근 속도

## 우선순위 큐 (Priority Queue)

### 우선순위의 수학적 모델

우선순위 큐는 **전순서 관계**를 가진 원소들의 큐입니다:
- **비교 함수**: a ≤ b (우선순위 관계)
- **추출 원칙**: 가장 높은 우선순위 원소 먼저
- **삽입 원칙**: 우선순위에 따른 위치 결정

### 힙을 이용한 구현

- **최대 힙**: 큰 값이 높은 우선순위
- **최소 힙**: 작은 값이 높은 우선순위
- **연산 복잡도**: 삽입/삭제 모두 O(log n)

## 스택과 큐의 변형과 최적화

### 최소값을 추적하는 스택

**문제**: 스택의 최소값을 O(1) 시간에 조회

**해결책**:
1. **보조 스택**: 최소값들만 저장하는 별도 스택
2. **차이값 저장**: 현재값과 최소값의 차이 저장
3. **연결 리스트**: 각 노드에 현재 최소값 저장

### 두 스택으로 큐 구현

**아이디어**: 입력 스택과 출력 스택 사용
- **enqueue**: 입력 스택에 push
- **dequeue**: 출력 스택이 비어있으면 입력 스택의 모든 원소를 출력 스택으로 이동

**분석**: amortized O(1) 시간 복잡도

### 두 큐로 스택 구현

**아이디어**: 최신 원소를 항상 한 큐의 앞쪽에 유지
- **push**: 새 원소를 빈 큐에 넣고, 다른 큐의 모든 원소를 옮김
- **pop**: 비어있지 않은 큐에서 dequeue

**분석**: push가 O(n), pop이 O(1)

## 메모리 관리와 성능 최적화

### 메모리 할당 전략

#### 정적 할당
- **고정 크기**: 컴파일 타임에 크기 결정
- **빠른 접근**: 인덱스 기반 연산
- **메모리 낭비**: 최대 크기로 할당

#### 동적 할당
- **가변 크기**: 필요에 따라 크기 조정
- **메모리 효율**: 실제 사용량만큼 할당
- **할당 비용**: 동적 할당/해제 오버헤드

### 캐시 최적화

#### 스택의 캐시 효율성
- **공간 지역성**: 연속된 메모리 접근
- **시간 지역성**: 최근 접근한 메모리 재사용
- **프리페칭**: 예측 가능한 접근 패턴

#### 큐의 캐시 고려사항
- **두 포인터**: front와 rear의 분산된 접근
- **원형 구조**: 메모리 재사용으로 지역성 개선
- **블록 기반**: 큰 블록 단위로 캐시 활용

## 동시성과 병렬 처리

### 스레드 안전성

#### 문제점
- **경쟁 조건**: 동시 접근으로 인한 데이터 손상
- **일관성**: 중간 상태에서의 관찰 문제

#### 해결 방법
- **뮤텍스**: 상호 배제를 통한 동기화
- **원자적 연산**: 하드웨어 지원 원자 연산
- **lock-free**: Compare-And-Swap 등 활용

### 무잠금 자료구조

#### 무잠금 스택
- **CAS 연산**: 원자적 비교-교환
- **ABA 문제**: 포인터 재사용으로 인한 오류
- **해결책**: 버전 카운터 또는 hazard pointer

#### 무잠금 큐
- **두 포인터 동기화**: head와 tail의 일관성
- **도움말 메커니즘**: 진행 중인 연산 완료 지원

## 마무리: 스택과 큐의 철학적 의의

스택과 큐는 **"제약의 힘"**을 보여주는 완벽한 예시입니다:

### 스택의 철학
- **깊이의 추구**: 한 방향으로 파고들기
- **역순의 아름다움**: 나중에 온 것이 먼저 나가는 우아함
- **맥락의 보존**: 실행 문맥과 호출 스택

### 큐의 철학
- **공정성의 구현**: 순서대로 처리하는 정의
- **흐름의 관리**: 데이터 스트림의 자연스러운 처리
- **대기의 질서**: 문명화된 대기 시스템

**핵심 통찰**: 제약이 있기 때문에 명확한 의미와 효율적인 구현이 가능합니다. 이는 소프트웨어 설계에서 **"제약을 통한 자유"**라는 중요한 원칙을 보여줍니다.

**철학적 결론**: 스택과 큐는 단순한 자료구조를 넘어서 **"질서 있는 시스템"**의 원형입니다. 이들을 통해 우리는 복잡한 컴퓨터 시스템에서도 **예측 가능하고 관리 가능한 질서**를 만들어낼 수 있습니다.

## 구현에 대한 개념 설명

### 1. 스택 구현 방식의 설계 철학

#### 구현 선택의 근본적 트레이드오프

스택 구현은 **"성능과 유연성"**, **"단순성과 확장성"** 사이의 근본적 선택을 요구합니다. 이는 소프트웨어 설계의 핵심 딜레마를 보여줍니다.

**철학적 통찰**: 완벽한 구현은 존재하지 않으며, 모든 설계는 **상황에 맞는 최적화**입니다.

#### 배열 기반 구현: 단순함의 힘

```c
typedef struct ArrayStack {
    int data[MAX_SIZE];  // 연속된 메모리 블록
    int top;             // 단일 포인터로 상태 관리
    int capacity;        // 불변 속성
} ArrayStack;
```

**설계 원리**:
- **연속성의 가치**: 메모리 지역성으로 캐시 효율성 극대화
- **예측 가능성**: 컴파일 타임에 모든 메모리 레이아웃 결정
- **원자적 연산**: top 인덱스 하나로 모든 상태 변화 표현

**메모리 접근 패턴의 수학적 분석**:
- **캐시 적중률**: 연속된 메모리 접근으로 95% 이상 달성 가능
- **프리페칭 효과**: CPU가 다음 접근을 예측하여 미리 로드
- **TLB 효율성**: 페이지 경계 crossing 최소화

#### 연결 리스트 기반 구현: 유연성의 추구

```c
typedef struct StackNode {
    int data;                    // 실제 데이터
    struct StackNode* next;      // 다음 노드로의 포인터
} StackNode;

typedef struct LinkedStack {
    StackNode* top;              // 최상단 노드 포인터
    int size;                    // 크기 추적 (선택적)
} LinkedStack;
```

**설계 원리**:
- **무한 확장성**: 메모리가 허용하는 한 무제한 성장
- **동적 할당**: 실제 필요량만큼만 메모리 사용
- **포인터 간접 참조**: 유연성과 복잡성의 교환

**메모리 할당 패턴의 분석**:
- **힙 단편화**: 비연속적 할당으로 인한 메모리 효율성 저하
- **캐시 미스**: 포인터 추적으로 인한 예측 불가능한 메모리 접근
- **malloc/free 오버헤드**: 시스템 호출 비용

### 2. 스택 연산의 구현 세부사항

#### Push 연산의 내부 메커니즘

**배열 기반 Push의 원자성**:
```c
void push(ArrayStack* stack, int item) {
    // 1. 경계 검사 (O(1))
    if (stack->top >= stack->capacity - 1) {
        // 오버플로우 처리
        return;
    }

    // 2. 원자적 상태 변경
    stack->data[++stack->top] = item;  // 전위 증가 + 할당
}
```

**중요한 설계 결정**:
- **전위 증가 사용**: `++stack->top`으로 인덱스 증가와 사용을 한 번에
- **경계 검사 우선**: 안전성을 위한 방어적 프로그래밍
- **예외 없는 실패**: C의 철학에 맞는 조용한 실패

**연결 리스트 Push의 포인터 조작**:
```c
void pushLinked(LinkedStack* stack, int item) {
    // 1. 새 노드 생성 (시스템 호출)
    StackNode* newNode = malloc(sizeof(StackNode));

    // 2. 포인터 연결 (원자적이지 않음)
    newNode->data = item;
    newNode->next = stack->top;  // 기존 top을 새 노드의 next로
    stack->top = newNode;        // 새 노드를 top으로
}
```

**포인터 조작의 순서**:
1. **새 노드 준비**: 데이터 설정과 링크 준비
2. **기존 체인 연결**: 새 노드의 next를 기존 top으로
3. **head 포인터 이동**: top을 새 노드로 업데이트

**순서의 중요성**: 잘못된 순서는 메모리 누수나 데이터 손실 발생

#### Pop 연산의 안전성 보장

**배열 기반 Pop의 단순성**:
```c
int pop(ArrayStack* stack) {
    if (stack->top < 0) {
        return ERROR_VALUE;  // 언더플로우 처리
    }

    return stack->data[stack->top--];  // 후위 감소로 반환 후 감소
}
```

**후위 감소의 의미**: 현재 값을 반환한 후 인덱스를 감소시켜 논리적 제거

**연결 리스트 Pop의 메모리 관리**:
```c
int popLinked(LinkedStack* stack) {
    if (stack->top == NULL) {
        return ERROR_VALUE;
    }

    StackNode* temp = stack->top;     // 제거할 노드 보관
    int data = temp->data;            // 반환할 데이터 추출
    stack->top = stack->top->next;    // head 포인터 이동
    free(temp);                       // 메모리 해제

    return data;
}
```

**메모리 해제의 중요성**: 메모리 누수 방지를 위한 필수 단계

### 3. 큐 구현의 복잡성과 해결책

#### 선형 큐의 한계와 원형 큐의 해결책

**선형 큐의 문제**:
```c
// 비효율적인 선형 큐
typedef struct LinearQueue {
    int data[MAX_SIZE];
    int front, rear;
} LinearQueue;

// rear가 끝에 도달하면 사용 불가능한 공간 발생
```

**가짜 오버플로우**: 앞쪽에 빈 공간이 있어도 rear가 끝에 도달하면 사용 불가

**원형 큐의 수학적 해결**:
```c
// 모듈러 산술을 활용한 원형 큐
void enqueue(ArrayQueue* queue, int item) {
    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->data[queue->rear] = item;
}

int dequeue(ArrayQueue* queue) {
    int item = queue->data[queue->front];
    queue->front = (queue->front + 1) % queue->capacity;
    return item;
}
```

**모듈러 산술의 의미**:
- **순환성**: `(index + 1) % size`로 배열 끝에서 처음으로 순환
- **수학적 우아함**: 유한 집합에서 무한 시퀀스 처리
- **공간 효율성**: 모든 배열 공간 100% 활용

#### 가득 참과 비어있음의 구별 문제

**문제의 본질**: `front == rear`일 때 두 상태를 구별할 수 없음

**해결책 1: 크기 카운터 사용**
```c
typedef struct ArrayQueue {
    int data[MAX_SIZE];
    int front, rear;
    int size;  // 현재 원소 개수
} ArrayQueue;

bool isEmpty(ArrayQueue* q) { return q->size == 0; }
bool isFull(ArrayQueue* q) { return q->size == q->capacity; }
```

**장점**: 명확한 상태 구별, 직관적 이해
**단점**: 추가 메모리 필요, 동기화 복잡성 증가

**해결책 2: 한 칸 비우기**
```c
bool isEmpty(ArrayQueue* q) { return q->front == q->rear; }
bool isFull(ArrayQueue* q) {
    return (q->rear + 1) % q->capacity == q->front;
}
```

**장점**: 추가 변수 불필요, 간단한 조건 검사
**단점**: 공간 효율성 98.X% (한 칸 낭비)

**해결책 3: 플래그 사용**
```c
typedef struct ArrayQueue {
    int data[MAX_SIZE];
    int front, rear;
    bool isFull;  // 가득 참 상태 플래그
} ArrayQueue;
```

**설계 철학**: 각 해결책은 **메모리, 성능, 복잡성** 간의 다른 균형점을 제시

### 4. 연결 리스트 기반 큐의 포인터 관리

#### 이중 포인터 동기화의 복잡성

**큐의 특수성**: 삽입과 삭제가 서로 다른 끝에서 발생

```c
typedef struct LinkedQueue {
    QueueNode* front;  // 삭제 지점
    QueueNode* rear;   // 삽입 지점
} LinkedQueue;
```

**Enqueue의 경계 조건 처리**:
```c
void enqueueLinked(LinkedQueue* queue, int item) {
    QueueNode* newNode = createNode(item);

    if (queue->rear == NULL) {
        // 빈 큐: front와 rear 모두 새 노드를 가리킴
        queue->front = queue->rear = newNode;
    } else {
        // 일반적인 경우: rear 뒤에 추가
        queue->rear->next = newNode;
        queue->rear = newNode;
    }
}
```

**Dequeue의 경계 조건 처리**:
```c
int dequeueLinked(LinkedQueue* queue) {
    if (queue->front == NULL) return ERROR;

    QueueNode* temp = queue->front;
    int data = temp->data;

    queue->front = queue->front->next;

    // 마지막 원소 제거 시 rear도 NULL로 설정
    if (queue->front == NULL) {
        queue->rear = NULL;
    }

    free(temp);
    return data;
}
```

**중요한 불변조건**: `front == NULL`이면 반드시 `rear == NULL`이어야 함

**포인터 동기화의 실패 시나리오**:
1. **댕글링 포인터**: rear가 해제된 노드를 가리키는 경우
2. **고아 노드**: front는 NULL인데 rear는 유효한 노드를 가리키는 경우
3. **불일치 상태**: 빈 큐인데 한 포인터만 NULL인 경우

### 5. 덱(Deque) 구현의 대칭성 설계

#### 양방향 연산의 통일성

**덱의 설계 철학**: 모든 연산이 양방향으로 대칭적으로 작동해야 함

```c
// 대칭적 연산 인터페이스
void pushFront(Deque* deque, int item);
void pushBack(Deque* deque, int item);
int popFront(Deque* deque);
int popBack(Deque* deque);
```

**원형 배열에서의 양방향 인덱싱**:
```c
// 앞쪽 삽입: 인덱스를 뒤로 이동
void pushFront(ArrayDeque* deque, int item) {
    deque->front = (deque->front - 1 + deque->capacity) % deque->capacity;
    deque->data[deque->front] = item;
}

// 뒤쪽 삽입: 인덱스를 앞으로 이동
void pushBack(ArrayDeque* deque, int item) {
    deque->rear = (deque->rear + 1) % deque->capacity;
    deque->data[deque->rear] = item;
}
```

**음수 모듈러 연산의 처리**: `(index - 1 + capacity) % capacity`로 음수 방지

#### 이중 연결 리스트 기반 덱

```c
typedef struct DequeNode {
    int data;
    struct DequeNode* prev;  // 이전 노드
    struct DequeNode* next;  // 다음 노드
} DequeNode;

typedef struct Deque {
    DequeNode* front;
    DequeNode* rear;
} Deque;
```

**양방향 포인터의 장점**:
- **O(1) 양방향 삽입/삭제**: 끝에서의 모든 연산이 상수 시간
- **대칭적 구현**: front와 rear 연산의 코드 구조 동일
- **순회 가능성**: 양방향 순회 지원

**복잡성의 대가**:
- **포인터 관리 복잡성**: 각 연산에서 4개 포인터 업데이트 필요
- **메모리 오버헤드**: 노드당 추가 포인터 8바이트 (64비트 시스템)
- **디버깅 어려움**: 포인터 망이 복잡해짐

### 6. 메모리 관리 전략과 성능 최적화

#### 메모리 풀링 기법

**문제**: 빈번한 malloc/free 호출로 인한 성능 저하

**해결책**: 미리 할당된 메모리 풀 사용
```c
typedef struct NodePool {
    StackNode nodes[POOL_SIZE];
    bool used[POOL_SIZE];
    int freeList[POOL_SIZE];
    int freeCount;
} NodePool;

StackNode* allocateNode(NodePool* pool) {
    if (pool->freeCount == 0) return NULL;

    int index = pool->freeList[--pool->freeCount];
    pool->used[index] = true;
    return &pool->nodes[index];
}
```

**장점**:
- **예측 가능한 성능**: malloc/free 호출 제거
- **메모리 지역성**: 연속된 메모리 블록 사용
- **단편화 방지**: 미리 할당된 블록 재사용

#### 캐시 친화적 설계

**캐시 라인 최적화**:
```c
// 캐시 라인 크기에 맞춘 구조체 정렬
__attribute__((aligned(64)))  // 64바이트 캐시 라인
typedef struct CacheOptimizedStack {
    int data[16];        // 64바이트에 맞춤
    int top;
    int capacity;
    char padding[44];    // 명시적 패딩
} CacheOptimizedStack;
```

**프리페칭 활용**:
```c
void prefetchNextNode(StackNode* node) {
    if (node && node->next) {
        __builtin_prefetch(node->next, 0, 1);  // 읽기용 프리페치
    }
}
```

### 7. 오류 처리와 안전성 보장

#### 방어적 프로그래밍 원칙

**입력 검증의 계층화**:
```c
int pop(ArrayStack* stack) {
    // 1차 검증: NULL 포인터
    if (stack == NULL) {
        errno = EINVAL;
        return ERROR_NULL_POINTER;
    }

    // 2차 검증: 구조체 무결성
    if (stack->top < -1 || stack->top >= stack->capacity) {
        errno = ERANGE;
        return ERROR_CORRUPTED_STATE;
    }

    // 3차 검증: 논리적 상태
    if (stack->top == -1) {
        errno = ENODATA;
        return ERROR_EMPTY_STACK;
    }

    return stack->data[stack->top--];
}
```

**오류 전파 메커니즘**:
1. **errno 설정**: POSIX 표준 오류 코드 사용
2. **명시적 반환값**: 특별한 값으로 오류 표시
3. **로깅**: 디버깅을 위한 상세 정보 기록

#### 메모리 안전성 보장

**이중 해제 방지**:
```c
void safeDestroyStack(LinkedStack** stack) {
    if (stack == NULL || *stack == NULL) return;

    while ((*stack)->top != NULL) {
        popLinked(*stack);
    }

    free(*stack);
    *stack = NULL;  // 댕글링 포인터 방지
}
```

**메모리 누수 탐지**:
```c
#ifdef DEBUG
static int allocCount = 0;

void* debugMalloc(size_t size) {
    void* ptr = malloc(size);
    if (ptr) allocCount++;
    printf("Alloc: %p (count: %d)\n", ptr, allocCount);
    return ptr;
}

void debugFree(void* ptr) {
    if (ptr) {
        allocCount--;
        printf("Free: %p (count: %d)\n", ptr, allocCount);
    }
    free(ptr);
}
#endif
```

### 8. 성능 분석과 벤치마킹

#### 시간 복잡도의 상세 분석

**Amortized Analysis의 필요성**: 동적 배열의 크기 조정 시

```c
// 동적 크기 조정이 있는 스택
void dynamicPush(DynamicStack* stack, int item) {
    if (stack->size == stack->capacity) {
        // 크기 두 배로 증가
        int newCapacity = stack->capacity * 2;
        int* newData = realloc(stack->data,
                              newCapacity * sizeof(int));
        if (newData == NULL) return;  // 메모리 부족

        stack->data = newData;
        stack->capacity = newCapacity;
    }

    stack->data[stack->size++] = item;
}
```

**분할 상환 분석**:
- **개별 연산**: O(n) (최악의 경우 - 재할당)
- **n개 연산 시퀀스**: O(n) (평균적으로)
- **상환된 비용**: O(1) per operation

**증명**: 크기 조정 비용이 기하급수적으로 분산됨

#### 공간 복잡도 최적화

**메모리 사용량 분석**:
```c
// 배열 스택: O(capacity)
size_t arrayStackMemory(ArrayStack* stack) {
    return sizeof(ArrayStack) +
           stack->capacity * sizeof(int);
}

// 연결 리스트 스택: O(size)
size_t linkedStackMemory(LinkedStack* stack) {
    return sizeof(LinkedStack) +
           stack->size * (sizeof(StackNode) + sizeof(int));
}
```

**메모리 효율성 비교**:
- **작은 스택**: 연결 리스트가 유리
- **큰 스택**: 배열이 유리 (포인터 오버헤드 없음)
- **변동성 큰 스택**: 연결 리스트가 유리

### 9. 동시성과 스레드 안전성

#### 락-프리 스택 구현

**CAS (Compare-And-Swap) 기반 구현**:
```c
typedef struct LockFreeStack {
    volatile StackNode* top;
} LockFreeStack;

void lockFreePush(LockFreeStack* stack, int item) {
    StackNode* newNode = allocateNode();
    newNode->data = item;

    StackNode* oldTop;
    do {
        oldTop = stack->top;
        newNode->next = oldTop;
    } while (!__sync_bool_compare_and_swap(&stack->top,
                                           oldTop, newNode));
}
```

**ABA 문제와 해결책**:
```c
// 태그를 포함한 포인터 사용
typedef struct TaggedPointer {
    StackNode* ptr;
    uint64_t tag;
} TaggedPointer;

typedef struct LockFreeStackWithTag {
    volatile TaggedPointer top;
} LockFreeStackWithTag;
```

#### 큐의 동시성 처리

**읽기-쓰기 분리**:
```c
// 생산자-소비자 패턴
typedef struct ConcurrentQueue {
    volatile int data[MAX_SIZE];
    volatile int head;     // 소비자만 수정
    volatile int tail;     // 생산자만 수정
    int capacity;
} ConcurrentQueue;
```

**메모리 장벽의 필요성**:
```c
void enqueueAtomic(ConcurrentQueue* queue, int item) {
    int nextTail = (queue->tail + 1) % queue->capacity;
    if (nextTail == queue->head) return;  // 가득 참

    queue->data[queue->tail] = item;
    __sync_synchronize();  // 메모리 장벽
    queue->tail = nextTail;
}
```

**핵심 통찰**: 스택과 큐의 구현은 단순한 자료구조를 넘어서 **시스템 설계의 핵심 원리**들을 담고 있습니다. 메모리 관리, 성능 최적화, 동시성 처리, 오류 안전성 등 현대 소프트웨어 개발의 모든 복잡성이 이 작은 자료구조들 안에 압축되어 있습니다.

## 스택 구현

### 구현 방식의 선택: 배열 vs 연결 리스트

스택을 구현하는 두 가지 주요 방법이 있으며, 각각 다른 철학을 반영합니다:

#### 배열 기반 구현의 특징
- **메모리 지역성**: 연속된 메모리 공간 사용으로 캐시 효율성 높음
- **고정 크기**: 컴파일 타임에 최대 크기 결정
- **간단한 인덱싱**: top 인덱스 하나로 모든 연산 처리
- **오버플로우 위험**: 크기 제한으로 인한 스택 오버플로우 가능

#### 연결 리스트 기반 구현의 특징
- **동적 크기**: 메모리가 허용하는 한 무제한 확장
- **포인터 오버헤드**: 각 노드마다 추가 포인터 메모리 필요
- **메모리 단편화**: 비연속적 메모리 할당으로 캐시 효율성 낮음
- **복잡한 메모리 관리**: 동적 할당/해제 관리 필요

### 배열 기반 스택

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_SIZE 100

typedef struct ArrayStack {
    int data[MAX_SIZE];
    int top;
    int capacity;
} ArrayStack;

// 스택 초기화
ArrayStack* createArrayStack() {
    ArrayStack* stack = (ArrayStack*)malloc(sizeof(ArrayStack));
    if (stack == NULL) {
        printf("메모리 할당 실패\n");
        return NULL;
    }
    stack->top = -1;
    stack->capacity = MAX_SIZE;
    return stack;
}

// 스택이 비어있는지 확인
bool isEmpty(ArrayStack* stack) {
    return (stack == NULL || stack->top == -1);
}

// 스택이 가득 찼는지 확인
bool isFull(ArrayStack* stack) {
    return (stack != NULL && stack->top == stack->capacity - 1);
}

// 스택에 원소 추가
void push(ArrayStack* stack, int item) {
    if (stack == NULL) {
        printf("스택이 초기화되지 않았습니다.\n");
        return;
    }

    if (isFull(stack)) {
        printf("스택 오버플로우: 스택이 가득 찼습니다.\n");
        return;
    }

    stack->data[++stack->top] = item;
    printf("푸시: %d\n", item);
}

// 스택에서 원소 제거 및 반환
int pop(ArrayStack* stack) {
    if (isEmpty(stack)) {
        printf("스택 언더플로우: 스택이 비어있습니다.\n");
        return -1;
    }

    int item = stack->data[stack->top--];
    printf("팝: %d\n", item);
    return item;
}

// 스택의 최상단 원소 조회
int peek(ArrayStack* stack) {
    if (isEmpty(stack)) {
        printf("스택이 비어있습니다.\n");
        return -1;
    }

    return stack->data[stack->top];
}

// 스택 크기 반환
int size(ArrayStack* stack) {
    return (stack == NULL) ? 0 : stack->top + 1;
}

// 스택 출력
void printStack(ArrayStack* stack) {
    if (isEmpty(stack)) {
        printf("빈 스택입니다.\n");
        return;
    }

    printf("스택 (top -> bottom): ");
    for (int i = stack->top; i >= 0; i--) {
        printf("%d ", stack->data[i]);
    }
    printf("\n");
}

// 스택 메모리 해제
void destroyArrayStack(ArrayStack* stack) {
    if (stack != NULL) {
        free(stack);
    }
}
```

### 연결 리스트 기반 스택

```c
typedef struct StackNode {
    int data;
    struct StackNode* next;
} StackNode;

typedef struct LinkedStack {
    StackNode* top;
    int size;
} LinkedStack;

// 스택 초기화
LinkedStack* createLinkedStack() {
    LinkedStack* stack = (LinkedStack*)malloc(sizeof(LinkedStack));
    if (stack == NULL) {
        printf("메모리 할당 실패\n");
        return NULL;
    }
    stack->top = NULL;
    stack->size = 0;
    return stack;
}

// 노드 생성
StackNode* createStackNode(int data) {
    StackNode* node = (StackNode*)malloc(sizeof(StackNode));
    if (node == NULL) {
        printf("메모리 할당 실패\n");
        return NULL;
    }
    node->data = data;
    node->next = NULL;
    return node;
}

// 스택에 원소 추가
void pushLinked(LinkedStack* stack, int item) {
    if (stack == NULL) return;

    StackNode* newNode = createStackNode(item);
    if (newNode == NULL) return;

    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
    printf("푸시: %d\n", item);
}

// 스택에서 원소 제거 및 반환
int popLinked(LinkedStack* stack) {
    if (stack == NULL || stack->top == NULL) {
        printf("스택이 비어있습니다.\n");
        return -1;
    }

    StackNode* temp = stack->top;
    int item = temp->data;
    stack->top = stack->top->next;
    free(temp);
    stack->size--;
    printf("팝: %d\n", item);
    return item;
}

// 스택의 최상단 원소 조회
int peekLinked(LinkedStack* stack) {
    if (stack == NULL || stack->top == NULL) {
        printf("스택이 비어있습니다.\n");
        return -1;
    }

    return stack->top->data;
}

// 스택 메모리 해제
void destroyLinkedStack(LinkedStack* stack) {
    if (stack == NULL) return;

    while (stack->top != NULL) {
        popLinked(stack);
    }
    free(stack);
}
```

## 큐 구현

### 배열 기반 큐 (원형 큐)

```c
#define QUEUE_MAX_SIZE 100

typedef struct ArrayQueue {
    int data[QUEUE_MAX_SIZE];
    int front;
    int rear;
    int size;
    int capacity;
} ArrayQueue;

// 큐 초기화
ArrayQueue* createArrayQueue() {
    ArrayQueue* queue = (ArrayQueue*)malloc(sizeof(ArrayQueue));
    if (queue == NULL) {
        printf("메모리 할당 실패\n");
        return NULL;
    }
    queue->front = 0;
    queue->rear = -1;
    queue->size = 0;
    queue->capacity = QUEUE_MAX_SIZE;
    return queue;
}

// 큐가 비어있는지 확인
bool isQueueEmpty(ArrayQueue* queue) {
    return (queue == NULL || queue->size == 0);
}

// 큐가 가득 찼는지 확인
bool isQueueFull(ArrayQueue* queue) {
    return (queue != NULL && queue->size == queue->capacity);
}

// 큐에 원소 추가 (enqueue)
void enqueue(ArrayQueue* queue, int item) {
    if (queue == NULL) {
        printf("큐가 초기화되지 않았습니다.\n");
        return;
    }

    if (isQueueFull(queue)) {
        printf("큐 오버플로우: 큐가 가득 찼습니다.\n");
        return;
    }

    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->data[queue->rear] = item;
    queue->size++;
    printf("인큐: %d\n", item);
}

// 큐에서 원소 제거 및 반환 (dequeue)
int dequeue(ArrayQueue* queue) {
    if (isQueueEmpty(queue)) {
        printf("큐 언더플로우: 큐가 비어있습니다.\n");
        return -1;
    }

    int item = queue->data[queue->front];
    queue->front = (queue->front + 1) % queue->capacity;
    queue->size--;
    printf("디큐: %d\n", item);
    return item;
}

// 큐의 첫 번째 원소 조회
int front(ArrayQueue* queue) {
    if (isQueueEmpty(queue)) {
        printf("큐가 비어있습니다.\n");
        return -1;
    }

    return queue->data[queue->front];
}

// 큐의 마지막 원소 조회
int rear(ArrayQueue* queue) {
    if (isQueueEmpty(queue)) {
        printf("큐가 비어있습니다.\n");
        return -1;
    }

    return queue->data[queue->rear];
}

// 큐 크기 반환
int queueSize(ArrayQueue* queue) {
    return (queue == NULL) ? 0 : queue->size;
}

// 큐 출력
void printQueue(ArrayQueue* queue) {
    if (isQueueEmpty(queue)) {
        printf("빈 큐입니다.\n");
        return;
    }

    printf("큐 (front -> rear): ");
    for (int i = 0; i < queue->size; i++) {
        int index = (queue->front + i) % queue->capacity;
        printf("%d ", queue->data[index]);
    }
    printf("\n");
}

// 큐 메모리 해제
void destroyArrayQueue(ArrayQueue* queue) {
    if (queue != NULL) {
        free(queue);
    }
}
```

### 연결 리스트 기반 큐

```c
typedef struct QueueNode {
    int data;
    struct QueueNode* next;
} QueueNode;

typedef struct LinkedQueue {
    QueueNode* front;
    QueueNode* rear;
    int size;
} LinkedQueue;

// 큐 초기화
LinkedQueue* createLinkedQueue() {
    LinkedQueue* queue = (LinkedQueue*)malloc(sizeof(LinkedQueue));
    if (queue == NULL) {
        printf("메모리 할당 실패\n");
        return NULL;
    }
    queue->front = NULL;
    queue->rear = NULL;
    queue->size = 0;
    return queue;
}

// 노드 생성
QueueNode* createQueueNode(int data) {
    QueueNode* node = (QueueNode*)malloc(sizeof(QueueNode));
    if (node == NULL) {
        printf("메모리 할당 실패\n");
        return NULL;
    }
    node->data = data;
    node->next = NULL;
    return node;
}

// 큐에 원소 추가 (enqueue)
void enqueueLinked(LinkedQueue* queue, int item) {
    if (queue == NULL) return;

    QueueNode* newNode = createQueueNode(item);
    if (newNode == NULL) return;

    if (queue->rear == NULL) {
        // 빈 큐인 경우
        queue->front = queue->rear = newNode;
    } else {
        queue->rear->next = newNode;
        queue->rear = newNode;
    }

    queue->size++;
    printf("인큐: %d\n", item);
}

// 큐에서 원소 제거 및 반환 (dequeue)
int dequeueLinked(LinkedQueue* queue) {
    if (queue == NULL || queue->front == NULL) {
        printf("큐가 비어있습니다.\n");
        return -1;
    }

    QueueNode* temp = queue->front;
    int item = temp->data;

    queue->front = queue->front->next;

    // 큐가 비게 되는 경우
    if (queue->front == NULL) {
        queue->rear = NULL;
    }

    free(temp);
    queue->size--;
    printf("디큐: %d\n", item);
    return item;
}

// 큐의 첫 번째 원소 조회
int frontLinked(LinkedQueue* queue) {
    if (queue == NULL || queue->front == NULL) {
        printf("큐가 비어있습니다.\n");
        return -1;
    }

    return queue->front->data;
}

// 큐 메모리 해제
void destroyLinkedQueue(LinkedQueue* queue) {
    if (queue == NULL) return;

    while (queue->front != NULL) {
        dequeueLinked(queue);
    }
    free(queue);
}
```

## 덱(Deque) 구현

```c
#define DEQUE_MAX_SIZE 100

typedef struct ArrayDeque {
    int data[DEQUE_MAX_SIZE];
    int front;
    int rear;
    int size;
    int capacity;
} ArrayDeque;

// 덱 초기화
ArrayDeque* createDeque() {
    ArrayDeque* deque = (ArrayDeque*)malloc(sizeof(ArrayDeque));
    if (deque == NULL) return NULL;

    deque->front = 0;
    deque->rear = -1;
    deque->size = 0;
    deque->capacity = DEQUE_MAX_SIZE;
    return deque;
}

// 덱이 비어있는지 확인
bool isDequeEmpty(ArrayDeque* deque) {
    return (deque == NULL || deque->size == 0);
}

// 덱이 가득 찼는지 확인
bool isDequeFull(ArrayDeque* deque) {
    return (deque != NULL && deque->size == deque->capacity);
}

// 앞쪽에 원소 추가
void pushFront(ArrayDeque* deque, int item) {
    if (isDequeFull(deque)) {
        printf("덱이 가득 찼습니다.\n");
        return;
    }

    deque->front = (deque->front - 1 + deque->capacity) % deque->capacity;
    deque->data[deque->front] = item;
    deque->size++;

    if (deque->size == 1) {
        deque->rear = deque->front;
    }
}

// 뒤쪽에 원소 추가
void pushBack(ArrayDeque* deque, int item) {
    if (isDequeFull(deque)) {
        printf("덱이 가득 찼습니다.\n");
        return;
    }

    if (deque->size == 0) {
        deque->data[deque->front] = item;
        deque->rear = deque->front;
    } else {
        deque->rear = (deque->rear + 1) % deque->capacity;
        deque->data[deque->rear] = item;
    }
    deque->size++;
}

// 앞쪽에서 원소 제거
int popFront(ArrayDeque* deque) {
    if (isDequeEmpty(deque)) {
        printf("덱이 비어있습니다.\n");
        return -1;
    }

    int item = deque->data[deque->front];
    deque->front = (deque->front + 1) % deque->capacity;
    deque->size--;
    return item;
}

// 뒤쪽에서 원소 제거
int popBack(ArrayDeque* deque) {
    if (isDequeEmpty(deque)) {
        printf("덱이 비어있습니다.\n");
        return -1;
    }

    int item = deque->data[deque->rear];
    deque->rear = (deque->rear - 1 + deque->capacity) % deque->capacity;
    deque->size--;
    return item;
}
```

## 응용 예제

### 괄호 매칭 검사

```c
bool isValidParentheses(const char* s) {
    ArrayStack* stack = createArrayStack();
    if (stack == NULL) return false;

    for (int i = 0; s[i] != '\0'; i++) {
        char ch = s[i];

        if (ch == '(' || ch == '[' || ch == '{') {
            push(stack, ch);
        } else if (ch == ')' || ch == ']' || ch == '}') {
            if (isEmpty(stack)) {
                destroyArrayStack(stack);
                return false;
            }

            char top = pop(stack);
            if ((ch == ')' && top != '(') ||
                (ch == ']' && top != '[') ||
                (ch == '}' && top != '{')) {
                destroyArrayStack(stack);
                return false;
            }
        }
    }

    bool result = isEmpty(stack);
    destroyArrayStack(stack);
    return result;
}
```

### 후위 표기법 계산

```c
int evaluatePostfix(const char* expression) {
    ArrayStack* stack = createArrayStack();
    if (stack == NULL) return 0;

    for (int i = 0; expression[i] != '\0'; i++) {
        char ch = expression[i];

        if (ch >= '0' && ch <= '9') {
            push(stack, ch - '0');
        } else if (ch == '+' || ch == '-' || ch == '*' || ch == '/') {
            if (size(stack) < 2) {
                printf("잘못된 후위 표기식입니다.\n");
                destroyArrayStack(stack);
                return 0;
            }

            int b = pop(stack);
            int a = pop(stack);
            int result;

            switch (ch) {
                case '+': result = a + b; break;
                case '-': result = a - b; break;
                case '*': result = a * b; break;
                case '/':
                    if (b == 0) {
                        printf("0으로 나눌 수 없습니다.\n");
                        destroyArrayStack(stack);
                        return 0;
                    }
                    result = a / b;
                    break;
            }
            push(stack, result);
        }
    }

    int finalResult = pop(stack);
    destroyArrayStack(stack);
    return finalResult;
}
```

### 두 스택으로 큐 구현

```c
typedef struct StackQueue {
    ArrayStack* inputStack;
    ArrayStack* outputStack;
} StackQueue;

StackQueue* createStackQueue() {
    StackQueue* sq = (StackQueue*)malloc(sizeof(StackQueue));
    if (sq == NULL) return NULL;

    sq->inputStack = createArrayStack();
    sq->outputStack = createArrayStack();

    if (sq->inputStack == NULL || sq->outputStack == NULL) {
        destroyArrayStack(sq->inputStack);
        destroyArrayStack(sq->outputStack);
        free(sq);
        return NULL;
    }

    return sq;
}

void enqueueWithStacks(StackQueue* sq, int item) {
    if (sq == NULL) return;
    push(sq->inputStack, item);
}

int dequeueWithStacks(StackQueue* sq) {
    if (sq == NULL) return -1;

    // outputStack이 비어있으면 inputStack의 모든 원소를 이동
    if (isEmpty(sq->outputStack)) {
        while (!isEmpty(sq->inputStack)) {
            int item = pop(sq->inputStack);
            push(sq->outputStack, item);
        }
    }

    return pop(sq->outputStack);
}
```

## 실제 사용 예제

```c
int main() {
    printf("=== 스택 테스트 ===\n");
    ArrayStack* stack = createArrayStack();

    push(stack, 10);
    push(stack, 20);
    push(stack, 30);
    printStack(stack);

    printf("Top: %d\n", peek(stack));
    pop(stack);
    printStack(stack);

    destroyArrayStack(stack);

    printf("\n=== 큐 테스트 ===\n");
    ArrayQueue* queue = createArrayQueue();

    enqueue(queue, 100);
    enqueue(queue, 200);
    enqueue(queue, 300);
    printQueue(queue);

    printf("Front: %d\n", front(queue));
    dequeue(queue);
    printQueue(queue);

    destroyArrayQueue(queue);

    printf("\n=== 괄호 매칭 테스트 ===\n");
    printf("\"((()))\" : %s\n", isValidParentheses("((()))") ? "유효" : "무효");
    printf("\"([{}])\" : %s\n", isValidParentheses("([{}])") ? "유효" : "무효");
    printf("\"([)]\" : %s\n", isValidParentheses("([)]") ? "유효" : "무효");

    return 0;
}
```