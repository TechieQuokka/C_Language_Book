# 13.4 해시 테이블 (Hash Table)

## 핵심 개념: 매핑의 예술과 확률의 수학

해시 테이블은 **"임의의 키를 고정된 위치로 매핑"**하는 수학적 함수의 구현체입니다. 이는 **함수론(Function Theory)**과 **확률론(Probability Theory)**의 만남이며, 동시에 **"평균적 성능"**과 **"최악 성능"** 사이의 트레이드오프를 보여주는 완벽한 예시입니다.

### 해시 함수의 수학적 본질

#### 해시 함수의 정의

**h: U → {0, 1, 2, ..., m-1}**
- **U**: 키의 전체 집합 (Universe)
- **m**: 해시 테이블의 크기
- **목표**: 키들을 **균등하게 분산**

**핵심 통찰**: 해시 함수는 **많은 키를 적은 슬롯으로 압축**하는 손실 압축 함수입니다.

#### 완벽한 해시 함수의 이상

**완벽한 해시 함수**의 조건:
1. **균등 분포**: P(h(k) = i) = 1/m (모든 i에 대해)
2. **독립성**: 서로 다른 키의 해시값이 독립적
3. **결정적**: 같은 키는 항상 같은 해시값

**수학적 현실**: 완벽한 해시 함수는 **이론적 이상**이며, 실제로는 근사해야 합니다.

### 해시 충돌: 비둘기집 원리의 불가피성

#### 비둘기집 원리 (Pigeonhole Principle)

n개의 키를 m개의 슬롯에 배치할 때 (n > m):
**적어도 하나의 슬롯에는 ⌈n/m⌉개 이상의 키가 배치됩니다.**

**철학적 의미**: 충돌은 **불가피한 현상**이며, 이를 관리하는 것이 핵심입니다.

#### 충돌 확률의 수학적 분석

**생일 문제**와 유사하게, n개의 키가 있을 때 충돌이 없을 확률:

**P(충돌 없음) = m!/(m^n × (m-n)!) ≈ e^(-n²/2m)**

**중요한 통찰**: √m개의 키만 있어도 충돌 확률이 50%를 넘습니다.

**구체적 예시**: 1000개 슬롯에서 40개 키만 있어도 충돌 확률 > 50%

## 충돌 해결 방법: 두 가지 철학적 접근

### 체이닝 (Chaining): 확장을 통한 해결

#### 체이닝의 수학적 모델

각 슬롯을 **연결 리스트의 헤드**로 모델링:
- **평균 체인 길이**: λ = n/m (load factor)
- **탐색 시간**: O(1 + λ)
- **최악 경우**: O(n) - 모든 키가 한 슬롯에 집중

#### 포아송 분포와의 관계

체인 길이는 **포아송 분포**를 근사적으로 따릅니다:
**P(X = k) = (λ^k × e^(-λ))/k!**

**수학적 의미**: 해시 테이블의 성능은 **확률적으로 예측 가능**합니다.

#### 체이닝의 장단점

**장점**:
- **구현 단순성**: 연결 리스트만 있으면 구현 가능
- **동적 크기**: 원소 수에 제한 없음
- **삭제 용이성**: 노드 제거만 하면 됨

**단점**:
- **포인터 오버헤드**: 추가 메모리 필요
- **캐시 성능**: 비연속적 메모리 접근
- **메모리 할당**: 동적 할당의 비용

### 오픈 어드레싱: 닫힌 시스템에서의 해결

#### 기본 철학
**모든 원소를 테이블 내부에 저장**: 추가 메모리 구조 없이 해결

#### 선형 탐사 (Linear Probing)

**탐사 함수**: h'(k, i) = (h(k) + i) mod m

**클러스터링 현상**: 연속된 슬롯들이 채워져 **군집**을 형성
- **1차 클러스터링**: 연속된 점유 슬롯들
- **성능 저하**: 클러스터 크기에 비례하여 탐사 시간 증가

**수학적 분석**:
- **성공 탐색 평균**: 1/2 × (1 + 1/(1-λ))
- **실패 탐색 평균**: 1/2 × (1 + 1/(1-λ)²)

#### 이차 탐사 (Quadratic Probing)

**탐사 함수**: h'(k, i) = (h(k) + c₁i + c₂i²) mod m

**수학적 장점**: 1차 클러스터링 완화
**수학적 단점**: 2차 클러스터링 발생 가능

**정리**: m이 소수이고 λ < 1/2이면 삽입이 항상 성공합니다.

#### 이중 해싱 (Double Hashing)

**탐사 함수**: h'(k, i) = (h₁(k) + i × h₂(k)) mod m

**수학적 조건**: gcd(h₂(k), m) = 1 (모든 슬롯 탐사 보장)
**성능**: **의사 랜덤** 탐사로 클러스터링 최소화

**설계 원칙**: h₂(k) = 7 - (k mod 7) (m이 소수일 때)

## 로드 팩터와 성능의 수학적 관계

### 체이닝에서의 성능

- **평균 탐색 시간**: O(1 + λ)
- **최적 로드 팩터**: λ ≈ 0.75 (경험적)
- **공간-시간 트레이드오프**: 낮은 λ = 빠른 속도, 많은 메모리

### 오픈 어드레싱에서의 성능

- **성공 탐색**: 1/2 × (1 + 1/(1-λ))
- **실패 탐색**: 1/2 × (1 + 1/(1-λ)²)
- **임계점**: λ ≈ 0.5 이후 급격한 성능 저하

**수학적 의미**: 로드 팩터가 1에 가까워질수록 성능이 **기하급수적으로 악화**됩니다.

**구체적 성능 비교**:
- λ = 0.5: 평균 탐사 횟수 1.5
- λ = 0.75: 평균 탐사 횟수 2.5
- λ = 0.9: 평균 탐사 횟수 5.5

## 동적 크기 조정: 아모타이즈드 분석

### 재해싱 (Rehashing)의 필요성

로드 팩터가 임계값을 초과하면 **테이블 크기 증배**:
1. 새로운 테이블 생성 (보통 2배 크기)
2. 모든 원소 재삽입 (해시값 재계산)
3. 기존 테이블 해제

### 아모타이즈드 복잡도 분석

**단일 재해싱 비용**: O(n)
**n번의 삽입에서 재해싱 횟수**: O(log n)
**아모타이즈드 삽입 비용**: O(n + n×log n)/n = O(log n) → **O(1)**

**수학적 기법**: **잠재 함수(Potential Function)**를 이용한 분석

#### 잠재 함수 분석

**Φ(T) = 2×size(T) - capacity(T)**
- **재해싱 전**: Φ(T) = size(T)
- **재해싱 후**: Φ(T) = 0

**아모타이즈드 비용** = **실제 비용** + **잠재 변화**

## 해시 함수 설계의 수학적 원리

### 나눗셈 방법 (Division Method)

**h(k) = k mod m**

**수학적 고려사항**:
- **m은 소수**: 분산 효과 극대화
- **2의 거듭제곱 피하기**: 하위 비트만 사용되는 문제
- **10의 거듭제곱 피하기**: 십진수 패턴 문제

**좋은 소수 예시**: 701, 1009, 1499 등

### 곱셈 방법 (Multiplication Method)

**h(k) = ⌊m × (kA mod 1)⌋**
여기서 A는 **황금비의 역수** ≈ 0.6180339887

**수학적 근거**: 황금비는 **가장 무리수적인 수**로 분산 효과가 우수합니다.

**황금비의 특성**: φ = (1 + √5)/2, φ² = φ + 1

### 범용 해싱 (Universal Hashing)

#### 수학적 정의

**해시 함수 족 H는 범용**이다 ⟺
**Pr[h(x) = h(y)] ≤ 1/m** (모든 x ≠ y에 대해, h는 H에서 균등 선택)

#### 구체적 구성

**hₐ,ᵦ(x) = ((ax + b) mod p) mod m**
여기서:
- p는 소수 (p > |U|)
- a ∈ {1, 2, ..., p-1}
- b ∈ {0, 1, ..., p-1}

**정리**: 이렇게 구성된 H는 범용 해시 함수족입니다.

### 암호학적 해시 함수

#### 보안 해시 함수의 요구사항

1. **일방향성**: h(x)에서 x 복원 불가능
2. **충돌 저항성**: 같은 해시값을 가진 서로 다른 입력 찾기 어려움
3. **눈사태 효과**: 입력의 작은 변화가 출력을 크게 변화

**철학적 차이**: 자료구조용 해시는 **속도 중심**, 암호학적 해시는 **보안 중심**

## 해시 테이블의 응용과 변형

### 블룸 필터 (Bloom Filter): 확률적 집합 표현

#### 기본 아이디어

**확률적 집합 표현**:
- **거짓 양성**: 있을 수 있음 (실제로 없는데 있다고 함)
- **거짓 음성**: 불가능 (실제로 있는데 없다고 하지 않음)
- **공간 효율성**: 원소당 몇 비트만 사용

#### 수학적 분석

k개의 해시 함수와 m비트 배열에서:
**거짓 양성 확률** ≈ (1 - e^(-kn/m))^k

**최적 해시 함수 개수**: k = (m/n) × ln(2)

#### 응용 분야

- **데이터베이스**: 디스크 접근 전 필터링
- **네트워크**: 중복 패킷 검출
- **캐시**: 캐시 미스 예측

### 일관성 해싱 (Consistent Hashing)

#### 분산 시스템에서의 문제

**전통적 해싱**: h(key) = key mod N
- **노드 추가/제거**: 대부분의 키 재배치
- **부하 불균형**: 핫스팟 발생 가능

#### 일관성 해싱의 해결책

**원형 해시 공간**에서의 키와 노드 배치:
- **노드 추가**: 영향받는 키 최소화
- **노드 제거**: 부하를 인접 노드로 분산
- **균등 분산**: 가상 노드를 통한 로드 밸런싱

**수학적 특성**:
- **단조성**: 키의 매핑이 단조적으로 변경
- **균형성**: 각 노드가 비슷한 부하
- **확산성**: 노드 변화의 영향 최소화

### 카운팅 블룸 필터

**문제**: 기본 블룸 필터는 삭제 불가능
**해결**: 비트 대신 카운터 사용

**트레이드오프**: 메모리 증가 vs 삭제 기능

### 쿠쿠 해싱 (Cuckoo Hashing)

#### 기본 아이디어

**두 개의 해시 함수**와 **두 개의 테이블** 사용:
- **삽입**: 한 위치가 비어있으면 삽입, 아니면 기존 원소를 다른 테이블로 밀어냄
- **탐색**: 두 위치만 확인하면 됨 - **O(1) 보장**

#### 수학적 분석

**성공 확률**: 로드 팩터 λ < 0.5일 때 높은 확률로 성공
**최악 시간**: O(1) 탐색, 삽입은 아모타이즈드 O(1)

## 성능 최적화와 실제 구현

### 메모리 레이아웃 최적화

#### 캐시 친화적 설계

**선형 탐사의 장점**: 연속된 메모리 접근으로 캐시 효율성
**체이닝의 개선**:
- **로컬 체이닝**: 테이블 내부에 짧은 체인 저장
- **로빈 후드 해싱**: 불공평도를 최소화하는 재배치

#### SIMD 최적화

**병렬 비교**: 여러 슬롯을 동시에 비교
**벡터화**: 해시 함수 계산의 병렬화

### 현대적 해시 테이블 설계

#### 구글의 DenseHashMap

**특징**:
- **오픈 어드레싱**: 메모리 효율성
- **이차 탐사**: 클러스터링 완화
- **삭제 마커**: 삭제된 위치 표시

#### Facebook의 F14

**특징**:
- **SIMD 활용**: 병렬 처리 최적화
- **적응적 크기 조정**: 사용 패턴에 따른 동적 조정
- **메모리 정렬**: 캐시 라인 최적화

### 언어별 구현 특성

#### C++ std::unordered_map

**구현**: 체이닝 방식 (일반적)
**특징**: 반복자 무효화 최소화

#### Java HashMap

**구현**: 체이닝 + 트리화 (JDK 8+)
**특징**: 긴 체인을 빨강-검정 트리로 변환

#### Python dict

**구현**: 오픈 어드레싱 + 조밀한 배열
**특징**: 메모리 효율성과 순서 보존

## 해시 테이블의 한계와 대안

### 근본적 한계

- **최악 성능**: O(n) 탐색 가능성
- **메모리 오버헤드**: 로드 팩터 유지를 위한 여유 공간
- **해시 함수 의존성**: 좋지 않은 해시 함수로 인한 성능 저하

### 현대적 대안들

#### B+ 트리
- **보장된 성능**: O(log n) 보장
- **순차 접근**: 정렬된 순회 가능
- **범위 쿼리**: 구간 검색 지원

#### LSM 트리
- **쓰기 최적화**: 배치 쓰기로 성능 향상
- **압축**: 백그라운드 병합으로 공간 효율성

#### 트라이 구조
- **접두사 검색**: 문자열 특화 기능
- **메모리 지역성**: 관련 키들의 근접 배치

## 마무리: 해시 테이블의 철학적 의의

해시 테이블은 **"평균적 효율성"**과 **"확률적 보장"**의 완벽한 구현체입니다:

### 해시 테이블의 수학적 아름다움

- **단순한 아이디어**: 키를 위치로 직접 변환
- **복잡한 분석**: 확률론적 성능 분석
- **실용적 효율성**: 평균적으로 상수 시간

### 해시 테이블의 철학적 의미

- **추상화의 힘**: 복잡한 키를 단순한 인덱스로 변환
- **확률적 사고**: 평균적 성능에 기반한 설계
- **트레이드오프 인식**: 공간과 시간, 평균과 최악 사이의 균형

**핵심 통찰**: 해시 테이블을 이해하는 것은 **"확률적 알고리즘"**의 힘을 이해하는 것입니다. 완벽한 보장은 포기하되, 실용적으로 충분한 성능을 얻는 지혜입니다.

**철학적 결론**: 해시 테이블은 **"실용주의의 승리"**를 보여줍니다. 이론적 완벽성보다는 실제적 효율성을 추구하며, 확률론적 분석을 통해 그 효율성을 수학적으로 증명합니다. 이는 현대 컴퓨터 과학에서 **"평균적 성능의 중요성"**과 **"확률적 방법론의 가치"**를 일깨워주는 완벽한 사례입니다.

## 구현에 대한 개념 설명

### 1. 해시 테이블 구현의 핵심 설계 철학

#### 해시 함수 설계의 수학적 기초와 실용적 고려사항

해시 테이블 구현의 첫 번째 도전은 **"좋은 해시 함수"**의 설계입니다. 이는 순수한 수학적 이론과 실제 시스템의 제약 사이에서 균형을 찾는 과정입니다.

```c
// 단순하지만 효과적인 djb2 해시 함수
unsigned int hash(const char* key) {
    unsigned int hash = 5381;           // 마법 상수 (소수)
    int c;

    while ((c = *key++)) {
        hash = ((hash << 5) + hash) + c; // hash * 33 + c
    }

    return hash;
}
```

**설계 원리의 분석**:
1. **마법 상수 5381**: 경험적으로 좋은 분산을 보이는 소수
2. **33의 곱셈**: 비트 시프트 + 덧셈으로 효율적 구현 (`hash << 5` + `hash`)
3. **문자별 누적**: 모든 문자가 최종 해시값에 영향
4. **오버플로우 활용**: unsigned integer의 자연스러운 모듈러 연산

**수학적 vs 실용적 트레이드오프**:
- **이론적 완벽성**: 범용 해싱 함수가 수학적으로 우수
- **실용적 효율성**: 단순한 함수가 더 빠르고 실제로 충분히 좋음
- **도메인 특화**: 특정 데이터 패턴에 최적화된 해시 함수의 가치

#### 해시 테이블 크기 선택의 수학적 원리

```c
#define INITIAL_SIZE 16              // 2의 거듭제곱 (빠른 모듈러 연산)
#define LOAD_FACTOR_THRESHOLD 0.75   // 성능과 공간의 균형점

// 소수 크기를 사용하는 경우
int getNextPrime(int n) {
    while (!isPrime(n)) n++;
    return n;
}

// 2의 거듭제곱을 사용하는 경우 (비트 연산 최적화)
int getHashIndex(const char* key, int capacity) {
    return hash(key) & (capacity - 1);  // % capacity와 동일하지만 더 빠름
}
```

**크기 선택의 철학적 고민**:
- **소수 크기**: 수학적으로 더 균등한 분산, 하지만 모듈러 연산 비용
- **2의 거듭제곱**: 비트 마스킹으로 빠른 인덱스 계산, 하지만 해시 품질 의존도 높음
- **로드 팩터**: 메모리 사용량과 성능 사이의 영원한 딜레마

### 2. 충돌 해결 방법의 구현 철학과 메모리 관리

#### 체이닝의 메모리 관리 전략

```c
typedef struct HashNode {
    char* key;                       // 동적 할당된 키
    int value;                       // 실제 저장할 값
    struct HashNode* next;           // 체인의 다음 노드
} HashNode;

typedef struct ChainHashTable {
    HashNode** buckets;              // 포인터 배열
    int size;                        // 현재 원소 수
    int capacity;                    // 버킷 수
    double loadFactor;               // 성능 모니터링용
} ChainHashTable;
```

**메모리 할당 패턴의 철학적 차이**:
- **개별 할당**: 각 노드를 별도로 malloc → 유연성 vs 단편화
- **블록 할당**: 여러 노드를 한 번에 할당 → 효율성 vs 복잡성
- **풀 할당**: 미리 할당된 노드 풀 사용 → 예측성 vs 메모리 낭비

#### 체이닝에서의 삽입 연산 구현 세부사항

```c
void insertChain(ChainHashTable* hashTable, const char* key, int value) {
    // 1단계: 해시값 계산과 인덱스 변환
    int index = getHashIndex(key, hashTable->capacity);

    // 2단계: 기존 키 확인 (중복 처리)
    HashNode* current = hashTable->buckets[index];
    while (current != NULL) {
        if (strcmp(current->key, key) == 0) {
            current->value = value;      // 값 업데이트
            return;
        }
        current = current->next;
    }

    // 3단계: 새 노드 생성 및 체인 앞에 삽입
    HashNode* newNode = createHashNode(key, value);
    if (newNode == NULL) return;         // 메모리 할당 실패 처리

    newNode->next = hashTable->buckets[index];
    hashTable->buckets[index] = newNode;
    hashTable->size++;

    // 4단계: 로드 팩터 관리 및 동적 크기 조정
    hashTable->loadFactor = (double)hashTable->size / hashTable->capacity;
    if (hashTable->loadFactor > LOAD_FACTOR_THRESHOLD) {
        rehashChain(hashTable);
    }
}
```

**구현 결정의 근거**:
1. **체인 앞 삽입**: O(1) 삽입, 최근 추가된 항목에 빠른 접근
2. **중복 키 처리**: 명시적 정책 (업데이트 vs 거부)
3. **메모리 실패 처리**: 현실적 시스템 제약 인정
4. **동적 크기 조정**: 성능 유지를 위한 proactive 관리

#### 오픈 어드레싱의 상태 관리 복잡성

```c
typedef struct OpenHashTable {
    char** keys;                     // 키 배열
    int* values;                     // 값 배열
    bool* occupied;                  // 점유 상태
    bool* deleted;                   // 삭제 상태 (중요!)
    int size;
    int capacity;
} OpenHashTable;
```

**삭제 마커의 필요성과 복잡성**:
```c
bool deleteOpen(OpenHashTable* hashTable, const char* key) {
    int index = linearProbe(hashTable, key, false);
    if (index != -1 && hashTable->occupied[index] &&
        !hashTable->deleted[index]) {

        // 실제 삭제하지 않고 마킹만 함
        hashTable->deleted[index] = true;
        hashTable->size--;

        // 주의: 메모리는 해제하지 않음 (탐사 체인 보호)
        return true;
    }
    return false;
}
```

**삭제 마커의 철학적 딜레마**:
- **필요성**: 탐사 체인의 연속성 보장
- **부작용**: 메모리 누수, 성능 저하, 복잡성 증가
- **해결책**: 주기적 재해싱, 압축, 또는 tombstone 회수

### 3. 재해싱(Rehashing)의 아모타이즈드 분석과 구현 전략

#### 재해싱 타이밍의 전략적 결정

```c
void rehashChain(ChainHashTable* hashTable) {
    printf("재해싱 시작: %d -> %d\n",
           hashTable->capacity, hashTable->capacity * 2);

    // 백업 및 새 테이블 준비
    HashNode** oldBuckets = hashTable->buckets;
    int oldCapacity = hashTable->capacity;

    hashTable->capacity *= 2;        // 크기 두 배 증가
    hashTable->buckets = (HashNode**)calloc(
        hashTable->capacity, sizeof(HashNode*));

    if (hashTable->buckets == NULL) {
        // 실패 시 롤백
        hashTable->buckets = oldBuckets;
        hashTable->capacity = oldCapacity;
        return;
    }

    int oldSize = hashTable->size;
    hashTable->size = 0;

    // 모든 원소 재삽입 (새로운 해시값으로)
    for (int i = 0; i < oldCapacity; i++) {
        HashNode* current = oldBuckets[i];
        while (current != NULL) {
            HashNode* next = current->next;

            // 새 위치 계산 및 체인 재구성
            int newIndex = getHashIndex(current->key, hashTable->capacity);
            current->next = hashTable->buckets[newIndex];
            hashTable->buckets[newIndex] = current;
            hashTable->size++;

            current = next;
        }
    }

    free(oldBuckets);
    hashTable->loadFactor = (double)hashTable->size / hashTable->capacity;
}
```

**재해싱의 수학적 분석**:
- **비용**: 현재 모든 원소를 재처리 → O(n)
- **빈도**: 로드 팩터가 임계값 초과 시 → O(log n) 회
- **아모타이즈드 비용**: O(n) ÷ O(n) 연산 = O(1) per operation

**구현 시 고려사항**:
1. **메모리 사용량**: 일시적으로 2배 메모리 필요
2. **원자성**: 재해싱 중 실패 시 복구 전략
3. **성능**: 재해싱 중 일시적 성능 저하
4. **동시성**: 멀티스레드 환경에서의 안전성

### 4. 고급 해시 기법의 구현 복잡성

#### 로빈 후드 해싱의 공정성 알고리즘

```c
typedef struct RobinHoodEntry {
    char* key;
    int value;
    int distance;                    // 원래 위치로부터의 거리
} RobinHoodEntry;

void insertRobinHood(RobinHoodEntry* table, int capacity,
                     const char* key, int value) {
    int index = hash(key) % capacity;
    int distance = 0;

    RobinHoodEntry newEntry = { strdup(key), value, 0 };

    while (true) {
        if (table[index].key == NULL) {
            table[index] = newEntry;
            return;
        }

        // 핵심: "부자에서 가난한 자로" 철학
        if (table[index].distance < distance) {
            // 현재 항목이 더 가까운 거리 → 교체
            RobinHoodEntry temp = table[index];
            table[index] = newEntry;
            newEntry = temp;
            distance = newEntry.distance;
        }

        index = (index + 1) % capacity;
        distance++;
        newEntry.distance = distance;
    }
}
```

**로빈 후드 해싱의 철학적 의미**:
- **공정성**: 모든 원소의 "불행"(탐사 거리)을 최소화
- **복잡성**: 단순한 선형 탐사보다 복잡한 로직
- **성능**: 평균 탐사 거리 감소, 최악 사례 개선

#### 쿠쿠 해싱의 보장된 성능

```c
typedef struct CuckooHashTable {
    char* keys1[CUCKOO_TABLE_SIZE];  // 첫 번째 테이블
    int values1[CUCKOO_TABLE_SIZE];
    char* keys2[CUCKOO_TABLE_SIZE];  // 두 번째 테이블
    int values2[CUCKOO_TABLE_SIZE];
    int size;
} CuckooHashTable;

bool insertCuckoo(CuckooHashTable* table, const char* key, int value) {
    int maxEvictions = CUCKOO_TABLE_SIZE;
    char* currentKey = strdup(key);
    int currentValue = value;
    bool useTable1 = true;

    for (int i = 0; i < maxEvictions; i++) {
        int index = useTable1 ? hash1(currentKey) : hash2(currentKey);

        if (useTable1) {
            if (table->keys1[index] == NULL) {
                table->keys1[index] = currentKey;
                table->values1[index] = currentValue;
                return true;
            }

            // "뻐꾸기" 동작: 기존 항목 축출
            char* tempKey = table->keys1[index];
            int tempValue = table->values1[index];
            table->keys1[index] = currentKey;
            table->values1[index] = currentValue;
            currentKey = tempKey;
            currentValue = tempValue;
        } else {
            // 두 번째 테이블에서 동일한 로직
            // ...
        }

        useTable1 = !useTable1;
    }

    free(currentKey);
    return false;  // 사이클 감지, 재구성 필요
}
```

**쿠쿠 해싱의 고유한 특성**:
- **보장된 O(1) 탐색**: 최대 2번의 메모리 접근
- **복잡한 삽입**: 연쇄적 축출과 사이클 처리
- **공간 오버헤드**: 두 개의 테이블 필요
- **재구성 위험**: 사이클 발생 시 전체 재구성

### 5. 메모리 최적화와 캐시 친화적 설계

#### 메모리 지역성 최적화

```c
// 캐시 라인에 맞춘 구조체 정렬
__attribute__((aligned(64)))  // 64바이트 캐시 라인
typedef struct CacheOptimizedHashTable {
    char keys[16][32];           // 짧은 키들을 연속 배치
    int values[16];
    uint8_t occupied[16];
    uint8_t deleted[16];
    char padding[32];            // 명시적 패딩
} CacheOptimizedHashTable;
```

**SIMD 최적화 고려사항**:
```c
// 벡터화된 문자열 비교 (개념적)
bool vectorCompareKeys(const char* key, CacheOptimizedHashTable* table) {
    // AVX2를 사용한 8개 키 동시 비교
    __m256i searchKey = _mm256_load_si256((__m256i*)key);

    for (int i = 0; i < 16; i += 8) {
        __m256i tableKeys = _mm256_load_si256((__m256i*)&table->keys[i]);
        __m256i cmp = _mm256_cmpeq_epi8(searchKey, tableKeys);

        int mask = _mm256_movemask_epi8(cmp);
        if (mask != 0) {
            // 일치하는 키 발견
            return true;
        }
    }

    return false;
}
```

### 6. 오류 처리와 안전성 보장

#### 방어적 프로그래밍 원칙

```c
void insertChainSafe(ChainHashTable* hashTable, const char* key, int value) {
    // 입력 검증
    if (hashTable == NULL) {
        fprintf(stderr, "Error: hashTable is NULL\n");
        return;
    }
    if (key == NULL) {
        fprintf(stderr, "Error: key is NULL\n");
        return;
    }
    if (strlen(key) == 0) {
        fprintf(stderr, "Error: empty key\n");
        return;
    }

    // 구조체 무결성 검증
    if (hashTable->buckets == NULL) {
        fprintf(stderr, "Error: corrupted hash table\n");
        return;
    }
    if (hashTable->capacity <= 0 || hashTable->size < 0) {
        fprintf(stderr, "Error: invalid table state\n");
        return;
    }

    // 정상 삽입 로직
    int index = getHashIndex(key, hashTable->capacity);
    // ...
}
```

#### 메모리 누수 방지 전략

```c
void destroyChainHashTable(ChainHashTable* hashTable) {
    if (hashTable == NULL) return;

    for (int i = 0; i < hashTable->capacity; i++) {
        HashNode* current = hashTable->buckets[i];
        while (current != NULL) {
            HashNode* next = current->next;

            // 키 메모리 해제
            if (current->key != NULL) {
                free(current->key);
                current->key = NULL;  // 더블 프리 방지
            }

            free(current);
            current = next;
        }
    }

    free(hashTable->buckets);
    hashTable->buckets = NULL;

    // 디버깅용 상태 초기화
    hashTable->size = -1;
    hashTable->capacity = -1;

    free(hashTable);
}
```

### 7. 성능 측정과 튜닝

#### 해시 함수 품질 측정

```c
typedef struct HashStatistics {
    int emptyBuckets;
    int maxChainLength;
    double averageChainLength;
    double variance;
    int collisions;
} HashStatistics;

HashStatistics analyzeHashDistribution(ChainHashTable* hashTable) {
    HashStatistics stats = {0};
    int chainLengths[hashTable->capacity];

    // 체인 길이 수집
    for (int i = 0; i < hashTable->capacity; i++) {
        int length = 0;
        HashNode* current = hashTable->buckets[i];

        if (current == NULL) {
            stats.emptyBuckets++;
        } else {
            while (current != NULL) {
                length++;
                current = current->next;
            }
            if (length > 1) stats.collisions += (length - 1);
        }

        chainLengths[i] = length;
        if (length > stats.maxChainLength) {
            stats.maxChainLength = length;
        }
    }

    // 평균과 분산 계산
    double sum = 0;
    int nonEmptyBuckets = hashTable->capacity - stats.emptyBuckets;

    for (int i = 0; i < hashTable->capacity; i++) {
        if (chainLengths[i] > 0) {
            sum += chainLengths[i];
        }
    }

    stats.averageChainLength = (nonEmptyBuckets > 0) ? sum / nonEmptyBuckets : 0;

    // 분산 계산
    double varianceSum = 0;
    for (int i = 0; i < hashTable->capacity; i++) {
        if (chainLengths[i] > 0) {
            double diff = chainLengths[i] - stats.averageChainLength;
            varianceSum += diff * diff;
        }
    }
    stats.variance = (nonEmptyBuckets > 0) ? varianceSum / nonEmptyBuckets : 0;

    return stats;
}
```

**핵심 통찰**: 해시 테이블 구현은 **"이론과 실제의 만남"**에서 나오는 모든 복잡성을 담고 있습니다. 수학적으로 완벽한 해시 함수는 현실적으로 구현할 수 없고, 이론적으로 최적인 충돌 해결 방법이 실제로는 캐시 성능 때문에 느릴 수 있습니다. 따라서 해시 테이블 구현의 진정한 예술은 **특정 사용 패턴과 시스템 제약에 맞는 적절한 균형점**을 찾는 것입니다.

**철학적 결론**: 해시 테이블 구현을 마스터하는 것은 **"완벽보다는 실용성"**, **"이론보다는 측정"**, **"일반성보다는 특화"**라는 엔지니어링의 핵심 가치를 체득하는 과정입니다. 이는 컴퓨터 과학에서 **"좋은 것이 완벽한 것의 적"**이라는 교훈을 가장 잘 보여주는 사례 중 하나입니다.

## 체이닝 방식 해시 테이블 구현

### 기본 구조 정의

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define INITIAL_SIZE 16
#define LOAD_FACTOR_THRESHOLD 0.75

// 해시 테이블 노드 (체이닝용)
typedef struct HashNode {
    char* key;
    int value;
    struct HashNode* next;
} HashNode;

// 체이닝 해시 테이블
typedef struct ChainHashTable {
    HashNode** buckets;    // 버킷 배열
    int size;              // 현재 원소 개수
    int capacity;          // 버킷 개수
    double loadFactor;     // 로드 팩터
} ChainHashTable;

// 노드 생성
HashNode* createHashNode(const char* key, int value) {
    HashNode* newNode = (HashNode*)malloc(sizeof(HashNode));
    if (newNode == NULL) {
        printf("메모리 할당 실패\n");
        return NULL;
    }

    newNode->key = (char*)malloc(strlen(key) + 1);
    if (newNode->key == NULL) {
        free(newNode);
        return NULL;
    }

    strcpy(newNode->key, key);
    newNode->value = value;
    newNode->next = NULL;
    return newNode;
}

// 해시 테이블 초기화
ChainHashTable* createChainHashTable() {
    ChainHashTable* hashTable = (ChainHashTable*)malloc(sizeof(ChainHashTable));
    if (hashTable == NULL) return NULL;

    hashTable->capacity = INITIAL_SIZE;
    hashTable->size = 0;
    hashTable->loadFactor = 0.0;

    hashTable->buckets = (HashNode**)calloc(hashTable->capacity, sizeof(HashNode*));
    if (hashTable->buckets == NULL) {
        free(hashTable);
        return NULL;
    }

    return hashTable;
}
```

### 해시 함수 구현

```c
// 간단한 해시 함수 (djb2 알고리즘)
unsigned int hash(const char* key) {
    unsigned int hash = 5381;
    int c;

    while ((c = *key++)) {
        hash = ((hash << 5) + hash) + c; // hash * 33 + c
    }

    return hash;
}

// 해시 값을 테이블 크기에 맞게 조정
int getHashIndex(const char* key, int capacity) {
    return hash(key) % capacity;
}

// 더 복잡한 해시 함수 (FNV-1a)
unsigned int hashFNV1a(const char* key) {
    const unsigned int FNV_PRIME = 16777619u;
    const unsigned int FNV_OFFSET_BASIS = 2166136261u;

    unsigned int hash = FNV_OFFSET_BASIS;
    while (*key) {
        hash ^= (unsigned char)*key++;
        hash *= FNV_PRIME;
    }
    return hash;
}

// 곱셈 방법 해시 함수
unsigned int hashMultiplication(const char* key, int capacity) {
    const double A = 0.6180339887; // 황금비의 역수
    unsigned int hashValue = hash(key);
    double temp = hashValue * A;
    temp = temp - (int)temp; // 소수 부분만 취함
    return (int)(capacity * temp);
}
```

### 체이닝 해시 테이블 연산

#### 삽입 연산

```c
void insertChain(ChainHashTable* hashTable, const char* key, int value) {
    if (hashTable == NULL || key == NULL) return;

    int index = getHashIndex(key, hashTable->capacity);
    HashNode* current = hashTable->buckets[index];

    // 기존 키가 있는지 확인 (업데이트)
    while (current != NULL) {
        if (strcmp(current->key, key) == 0) {
            current->value = value;
            return;
        }
        current = current->next;
    }

    // 새 노드 생성 및 체인 앞에 삽입
    HashNode* newNode = createHashNode(key, value);
    if (newNode == NULL) return;

    newNode->next = hashTable->buckets[index];
    hashTable->buckets[index] = newNode;
    hashTable->size++;

    // 로드 팩터 업데이트
    hashTable->loadFactor = (double)hashTable->size / hashTable->capacity;

    // 필요시 재해싱
    if (hashTable->loadFactor > LOAD_FACTOR_THRESHOLD) {
        rehashChain(hashTable);
    }
}
```

#### 탐색 연산

```c
int* searchChain(ChainHashTable* hashTable, const char* key) {
    if (hashTable == NULL || key == NULL) return NULL;

    int index = getHashIndex(key, hashTable->capacity);
    HashNode* current = hashTable->buckets[index];

    while (current != NULL) {
        if (strcmp(current->key, key) == 0) {
            return &(current->value);
        }
        current = current->next;
    }

    return NULL; // 찾지 못함
}

bool containsChain(ChainHashTable* hashTable, const char* key) {
    return searchChain(hashTable, key) != NULL;
}
```

#### 삭제 연산

```c
bool deleteChain(ChainHashTable* hashTable, const char* key) {
    if (hashTable == NULL || key == NULL) return false;

    int index = getHashIndex(key, hashTable->capacity);
    HashNode* current = hashTable->buckets[index];
    HashNode* prev = NULL;

    while (current != NULL) {
        if (strcmp(current->key, key) == 0) {
            // 첫 번째 노드인 경우
            if (prev == NULL) {
                hashTable->buckets[index] = current->next;
            } else {
                prev->next = current->next;
            }

            free(current->key);
            free(current);
            hashTable->size--;
            hashTable->loadFactor = (double)hashTable->size / hashTable->capacity;
            return true;
        }
        prev = current;
        current = current->next;
    }

    return false; // 찾지 못함
}
```

### 재해싱 구현

```c
void rehashChain(ChainHashTable* hashTable) {
    if (hashTable == NULL) return;

    printf("재해싱 시작: %d -> %d\n", hashTable->capacity, hashTable->capacity * 2);

    // 기존 버킷 백업
    HashNode** oldBuckets = hashTable->buckets;
    int oldCapacity = hashTable->capacity;

    // 새 버킷 배열 생성
    hashTable->capacity *= 2;
    hashTable->buckets = (HashNode**)calloc(hashTable->capacity, sizeof(HashNode*));
    if (hashTable->buckets == NULL) {
        printf("재해싱 실패: 메모리 할당 오류\n");
        hashTable->buckets = oldBuckets;
        hashTable->capacity = oldCapacity;
        return;
    }

    int oldSize = hashTable->size;
    hashTable->size = 0;

    // 모든 원소를 새 테이블에 재삽입
    for (int i = 0; i < oldCapacity; i++) {
        HashNode* current = oldBuckets[i];
        while (current != NULL) {
            HashNode* next = current->next;

            // 새 위치 계산
            int newIndex = getHashIndex(current->key, hashTable->capacity);

            // 새 위치에 삽입
            current->next = hashTable->buckets[newIndex];
            hashTable->buckets[newIndex] = current;
            hashTable->size++;

            current = next;
        }
    }

    // 기존 버킷 배열 해제
    free(oldBuckets);
    hashTable->loadFactor = (double)hashTable->size / hashTable->capacity;

    printf("재해싱 완료: 크기 %d, 로드팩터 %.2f\n",
           hashTable->size, hashTable->loadFactor);
}
```

## 오픈 어드레싱 해시 테이블 구현

### 기본 구조 정의

```c
#define DELETED_MARKER ((char*)0x1) // 삭제 마커

typedef struct OpenHashTable {
    char** keys;
    int* values;
    bool* occupied;
    bool* deleted;
    int size;
    int capacity;
    double loadFactor;
} OpenHashTable;

// 오픈 어드레싱 해시 테이블 초기화
OpenHashTable* createOpenHashTable() {
    OpenHashTable* hashTable = (OpenHashTable*)malloc(sizeof(OpenHashTable));
    if (hashTable == NULL) return NULL;

    hashTable->capacity = INITIAL_SIZE;
    hashTable->size = 0;
    hashTable->loadFactor = 0.0;

    hashTable->keys = (char**)calloc(hashTable->capacity, sizeof(char*));
    hashTable->values = (int*)calloc(hashTable->capacity, sizeof(int));
    hashTable->occupied = (bool*)calloc(hashTable->capacity, sizeof(bool));
    hashTable->deleted = (bool*)calloc(hashTable->capacity, sizeof(bool));

    if (!hashTable->keys || !hashTable->values ||
        !hashTable->occupied || !hashTable->deleted) {
        free(hashTable->keys);
        free(hashTable->values);
        free(hashTable->occupied);
        free(hashTable->deleted);
        free(hashTable);
        return NULL;
    }

    return hashTable;
}
```

### 선형 탐사 구현

```c
int linearProbe(OpenHashTable* hashTable, const char* key, bool forInsertion) {
    unsigned int hashValue = hash(key);
    int index = hashValue % hashTable->capacity;
    int originalIndex = index;
    int firstDeletedIndex = -1;

    do {
        if (!hashTable->occupied[index]) {
            // 빈 슬롯 발견
            if (forInsertion && firstDeletedIndex != -1) {
                return firstDeletedIndex; // 삭제된 슬롯 재사용
            }
            return index;
        }

        if (hashTable->deleted[index]) {
            // 삭제된 슬롯 발견
            if (firstDeletedIndex == -1) {
                firstDeletedIndex = index;
            }
        } else if (hashTable->keys[index] != NULL &&
                   strcmp(hashTable->keys[index], key) == 0) {
            // 키 발견
            return index;
        }

        index = (index + 1) % hashTable->capacity;
    } while (index != originalIndex);

    // 테이블이 가득 참
    return (forInsertion && firstDeletedIndex != -1) ? firstDeletedIndex : -1;
}
```

#### 이차 탐사 구현

```c
int quadraticProbe(OpenHashTable* hashTable, const char* key, bool forInsertion) {
    unsigned int hashValue = hash(key);
    int index = hashValue % hashTable->capacity;
    int i = 0;
    int firstDeletedIndex = -1;

    while (i < hashTable->capacity) {
        int probeIndex = (index + i * i) % hashTable->capacity;

        if (!hashTable->occupied[probeIndex]) {
            if (forInsertion && firstDeletedIndex != -1) {
                return firstDeletedIndex;
            }
            return probeIndex;
        }

        if (hashTable->deleted[probeIndex]) {
            if (firstDeletedIndex == -1) {
                firstDeletedIndex = probeIndex;
            }
        } else if (hashTable->keys[probeIndex] != NULL &&
                   strcmp(hashTable->keys[probeIndex], key) == 0) {
            return probeIndex;
        }

        i++;
    }

    return (forInsertion && firstDeletedIndex != -1) ? firstDeletedIndex : -1;
}
```

#### 이중 해싱 구현

```c
int secondaryHash(const char* key, int capacity) {
    // 7 - (hash % 7) 형태 (capacity가 소수인 경우)
    return 7 - (hash(key) % 7);
}

int doubleHash(OpenHashTable* hashTable, const char* key, bool forInsertion) {
    unsigned int hashValue = hash(key);
    int index = hashValue % hashTable->capacity;
    int step = secondaryHash(key, hashTable->capacity);
    int i = 0;
    int firstDeletedIndex = -1;

    while (i < hashTable->capacity) {
        int probeIndex = (index + i * step) % hashTable->capacity;

        if (!hashTable->occupied[probeIndex]) {
            if (forInsertion && firstDeletedIndex != -1) {
                return firstDeletedIndex;
            }
            return probeIndex;
        }

        if (hashTable->deleted[probeIndex]) {
            if (firstDeletedIndex == -1) {
                firstDeletedIndex = probeIndex;
            }
        } else if (hashTable->keys[probeIndex] != NULL &&
                   strcmp(hashTable->keys[probeIndex], key) == 0) {
            return probeIndex;
        }

        i++;
    }

    return (forInsertion && firstDeletedIndex != -1) ? firstDeletedIndex : -1;
}
```

### 오픈 어드레싱 연산

#### 삽입 연산

```c
void insertOpen(OpenHashTable* hashTable, const char* key, int value) {
    if (hashTable == NULL || key == NULL) return;

    // 로드 팩터 확인
    if (hashTable->loadFactor >= 0.5) {
        rehashOpen(hashTable);
    }

    int index = linearProbe(hashTable, key, true);
    if (index == -1) {
        printf("해시 테이블이 가득 찼습니다.\n");
        return;
    }

    // 기존 키 업데이트
    if (hashTable->occupied[index] && !hashTable->deleted[index] &&
        hashTable->keys[index] != NULL && strcmp(hashTable->keys[index], key) == 0) {
        hashTable->values[index] = value;
        return;
    }

    // 새 키 삽입
    if (hashTable->keys[index] != NULL && hashTable->keys[index] != DELETED_MARKER) {
        free(hashTable->keys[index]);
    }

    hashTable->keys[index] = (char*)malloc(strlen(key) + 1);
    if (hashTable->keys[index] == NULL) return;

    strcpy(hashTable->keys[index], key);
    hashTable->values[index] = value;
    hashTable->occupied[index] = true;
    hashTable->deleted[index] = false;

    hashTable->size++;
    hashTable->loadFactor = (double)hashTable->size / hashTable->capacity;
}
```

#### 탐색 연산

```c
int* searchOpen(OpenHashTable* hashTable, const char* key) {
    if (hashTable == NULL || key == NULL) return NULL;

    int index = linearProbe(hashTable, key, false);
    if (index != -1 && hashTable->occupied[index] &&
        !hashTable->deleted[index] && hashTable->keys[index] != NULL) {
        return &(hashTable->values[index]);
    }

    return NULL;
}
```

#### 삭제 연산

```c
bool deleteOpen(OpenHashTable* hashTable, const char* key) {
    if (hashTable == NULL || key == NULL) return false;

    int index = linearProbe(hashTable, key, false);
    if (index != -1 && hashTable->occupied[index] &&
        !hashTable->deleted[index] && hashTable->keys[index] != NULL) {

        hashTable->deleted[index] = true;
        hashTable->size--;
        hashTable->loadFactor = (double)hashTable->size / hashTable->capacity;
        return true;
    }

    return false;
}
```

### 재해싱 (오픈 어드레싱)

```c
void rehashOpen(OpenHashTable* hashTable) {
    if (hashTable == NULL) return;

    // 기존 데이터 백업
    char** oldKeys = hashTable->keys;
    int* oldValues = hashTable->values;
    bool* oldOccupied = hashTable->occupied;
    bool* oldDeleted = hashTable->deleted;
    int oldCapacity = hashTable->capacity;

    // 새 테이블 생성
    hashTable->capacity *= 2;
    hashTable->size = 0;
    hashTable->loadFactor = 0.0;

    hashTable->keys = (char**)calloc(hashTable->capacity, sizeof(char*));
    hashTable->values = (int*)calloc(hashTable->capacity, sizeof(int));
    hashTable->occupied = (bool*)calloc(hashTable->capacity, sizeof(bool));
    hashTable->deleted = (bool*)calloc(hashTable->capacity, sizeof(bool));

    if (!hashTable->keys || !hashTable->values ||
        !hashTable->occupied || !hashTable->deleted) {
        printf("재해싱 실패\n");
        return;
    }

    // 기존 데이터 재삽입
    for (int i = 0; i < oldCapacity; i++) {
        if (oldOccupied[i] && !oldDeleted[i] && oldKeys[i] != NULL) {
            insertOpen(hashTable, oldKeys[i], oldValues[i]);
            free(oldKeys[i]);
        }
    }

    // 기존 배열 해제
    free(oldKeys);
    free(oldValues);
    free(oldOccupied);
    free(oldDeleted);
}
```

## 해시 테이블 유틸리티 함수

### 해시 테이블 출력

```c
void printChainHashTable(ChainHashTable* hashTable) {
    if (hashTable == NULL) return;

    printf("=== 체이닝 해시 테이블 ===\n");
    printf("크기: %d, 용량: %d, 로드팩터: %.2f\n",
           hashTable->size, hashTable->capacity, hashTable->loadFactor);

    for (int i = 0; i < hashTable->capacity; i++) {
        printf("버킷[%d]: ", i);
        HashNode* current = hashTable->buckets[i];
        if (current == NULL) {
            printf("비어있음\n");
        } else {
            while (current != NULL) {
                printf("(%s: %d)", current->key, current->value);
                current = current->next;
                if (current != NULL) printf(" -> ");
            }
            printf("\n");
        }
    }
}

void printOpenHashTable(OpenHashTable* hashTable) {
    if (hashTable == NULL) return;

    printf("=== 오픈 어드레싱 해시 테이블 ===\n");
    printf("크기: %d, 용량: %d, 로드팩터: %.2f\n",
           hashTable->size, hashTable->capacity, hashTable->loadFactor);

    for (int i = 0; i < hashTable->capacity; i++) {
        printf("슬롯[%d]: ", i);
        if (!hashTable->occupied[i]) {
            printf("비어있음\n");
        } else if (hashTable->deleted[i]) {
            printf("삭제됨\n");
        } else {
            printf("(%s: %d)\n", hashTable->keys[i], hashTable->values[i]);
        }
    }
}
```

### 해시 테이블 통계

```c
void printHashStatistics(ChainHashTable* hashTable) {
    if (hashTable == NULL) return;

    int emptyBuckets = 0;
    int maxChainLength = 0;
    int totalChainLength = 0;

    for (int i = 0; i < hashTable->capacity; i++) {
        int chainLength = 0;
        HashNode* current = hashTable->buckets[i];

        if (current == NULL) {
            emptyBuckets++;
        } else {
            while (current != NULL) {
                chainLength++;
                current = current->next;
            }
            if (chainLength > maxChainLength) {
                maxChainLength = chainLength;
            }
            totalChainLength += chainLength;
        }
    }

    double averageChainLength = (double)totalChainLength /
                               (hashTable->capacity - emptyBuckets);

    printf("=== 해시 테이블 통계 ===\n");
    printf("빈 버킷 수: %d (%.1f%%)\n", emptyBuckets,
           100.0 * emptyBuckets / hashTable->capacity);
    printf("최대 체인 길이: %d\n", maxChainLength);
    printf("평균 체인 길이: %.2f\n", averageChainLength);
    printf("예상 체인 길이: %.2f\n", hashTable->loadFactor);
}
```

## 해시 함수 테스트

```c
void testHashFunction(const char* keys[], int numKeys, int tableSize) {
    int* bucketCounts = (int*)calloc(tableSize, sizeof(int));

    printf("=== 해시 함수 분산 테스트 ===\n");
    printf("키 개수: %d, 테이블 크기: %d\n", numKeys, tableSize);

    for (int i = 0; i < numKeys; i++) {
        int index = getHashIndex(keys[i], tableSize);
        bucketCounts[index]++;
    }

    int emptyBuckets = 0;
    int maxCount = 0;
    for (int i = 0; i < tableSize; i++) {
        if (bucketCounts[i] == 0) emptyBuckets++;
        if (bucketCounts[i] > maxCount) maxCount = bucketCounts[i];
    }

    double expectedPerBucket = (double)numKeys / tableSize;
    printf("버킷당 예상 키 수: %.2f\n", expectedPerBucket);
    printf("빈 버킷 수: %d\n", emptyBuckets);
    printf("최대 버킷 키 수: %d\n", maxCount);

    free(bucketCounts);
}
```

## 실제 사용 예제

```c
int main() {
    printf("=== 체이닝 해시 테이블 테스트 ===\n");

    ChainHashTable* chainTable = createChainHashTable();

    // 데이터 삽입
    insertChain(chainTable, "apple", 100);
    insertChain(chainTable, "banana", 200);
    insertChain(chainTable, "cherry", 300);
    insertChain(chainTable, "date", 400);
    insertChain(chainTable, "elderberry", 500);

    printChainHashTable(chainTable);
    printHashStatistics(chainTable);

    // 탐색 테스트
    int* value = searchChain(chainTable, "banana");
    if (value != NULL) {
        printf("'banana' 찾음: %d\n", *value);
    }

    // 삭제 테스트
    if (deleteChain(chainTable, "cherry")) {
        printf("'cherry' 삭제 성공\n");
    }

    printChainHashTable(chainTable);

    printf("\n=== 오픈 어드레싱 해시 테이블 테스트 ===\n");

    OpenHashTable* openTable = createOpenHashTable();

    // 데이터 삽입
    insertOpen(openTable, "red", 1);
    insertOpen(openTable, "green", 2);
    insertOpen(openTable, "blue", 3);
    insertOpen(openTable, "yellow", 4);
    insertOpen(openTable, "purple", 5);

    printOpenHashTable(openTable);

    // 탐색 테스트
    int* openValue = searchOpen(openTable, "green");
    if (openValue != NULL) {
        printf("'green' 찾음: %d\n", *openValue);
    }

    // 삭제 테스트
    if (deleteOpen(openTable, "blue")) {
        printf("'blue' 삭제 성공\n");
    }

    printOpenHashTable(openTable);

    // 해시 함수 분산 테스트
    const char* testKeys[] = {
        "apple", "banana", "cherry", "date", "elderberry",
        "fig", "grape", "honeydew", "kiwi", "lemon",
        "mango", "nectarine", "orange", "papaya", "quince"
    };

    testHashFunction(testKeys, 15, 8);

    return 0;
}
```

## 고급 해시 테이블 기법

### 로빈 후드 해싱

```c
typedef struct RobinHoodEntry {
    char* key;
    int value;
    int distance; // 원래 위치로부터의 거리
} RobinHoodEntry;

// 로빈 후드 해싱에서 요소들의 불공평도를 최소화
void insertRobinHood(RobinHoodEntry* table, int capacity,
                     const char* key, int value) {
    int index = hash(key) % capacity;
    int distance = 0;

    RobinHoodEntry newEntry = {
        .key = strdup(key),
        .value = value,
        .distance = 0
    };

    while (true) {
        if (table[index].key == NULL) {
            // 빈 슬롯 발견
            table[index] = newEntry;
            return;
        }

        // 현재 항목이 새 항목보다 가까운 거리에 있으면 교체
        if (table[index].distance < distance) {
            RobinHoodEntry temp = table[index];
            table[index] = newEntry;
            newEntry = temp;
            distance = newEntry.distance;
        }

        index = (index + 1) % capacity;
        distance++;
        newEntry.distance = distance;
    }
}
```

### 쿠쿠 해싱 기본 구조

```c
#define CUCKOO_TABLE_SIZE 16

typedef struct CuckooHashTable {
    char* keys1[CUCKOO_TABLE_SIZE];
    int values1[CUCKOO_TABLE_SIZE];
    char* keys2[CUCKOO_TABLE_SIZE];
    int values2[CUCKOO_TABLE_SIZE];
    int size;
} CuckooHashTable;

// 두 개의 해시 함수
int hash1(const char* key) {
    return hash(key) % CUCKOO_TABLE_SIZE;
}

int hash2(const char* key) {
    return hashFNV1a(key) % CUCKOO_TABLE_SIZE;
}

bool insertCuckoo(CuckooHashTable* table, const char* key, int value) {
    int maxEvictions = CUCKOO_TABLE_SIZE; // 무한 루프 방지

    char* currentKey = strdup(key);
    int currentValue = value;
    bool useTable1 = true;

    for (int i = 0; i < maxEvictions; i++) {
        int index = useTable1 ? hash1(currentKey) : hash2(currentKey);

        if (useTable1) {
            if (table->keys1[index] == NULL) {
                table->keys1[index] = currentKey;
                table->values1[index] = currentValue;
                table->size++;
                return true;
            }

            // 축출
            char* tempKey = table->keys1[index];
            int tempValue = table->values1[index];
            table->keys1[index] = currentKey;
            table->values1[index] = currentValue;
            currentKey = tempKey;
            currentValue = tempValue;
        } else {
            if (table->keys2[index] == NULL) {
                table->keys2[index] = currentKey;
                table->values2[index] = currentValue;
                table->size++;
                return true;
            }

            // 축출
            char* tempKey = table->keys2[index];
            int tempValue = table->values2[index];
            table->keys2[index] = currentKey;
            table->values2[index] = currentValue;
            currentKey = tempKey;
            currentValue = tempValue;
        }

        useTable1 = !useTable1;
    }

    free(currentKey);
    return false; // 삽입 실패
}
```