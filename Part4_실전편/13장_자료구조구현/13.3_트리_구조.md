# 13.3 트리 구조 (Tree Structure)

## 핵심 개념: 계층의 수학과 분할의 지혜

트리는 **"계층적 관계"**와 **"분할 정복"**을 구현한 가장 자연스러운 자료구조입니다. 이는 현실 세계의 **조직도, 가족관계, 분류체계**를 디지털로 옮긴 것이며, 동시에 **그래프 이론**의 특수한 경우입니다.

### 트리의 수학적 기초: 그래프 이론의 특수 케이스

트리는 **"연결되고 순환이 없는 그래프"**로 정의됩니다. 이는 수학에서 **최소 연결 그래프**의 개념과 정확히 일치합니다.

#### 트리의 수학적 정의

**G = (V, E)**에서 트리의 조건:
1. **연결성**: 모든 정점 쌍에 경로 존재
2. **비순환성**: 사이클이 없음
3. **최소성**: |E| = |V| - 1 (최소 간선 수)

**중요한 정리**: n개의 정점을 가진 트리는 정확히 n-1개의 간선을 가집니다.

#### 수학적 귀납법으로 증명

- **기저 사례**: n=1일 때, 간선 수 = 0 = 1-1 ✓
- **귀납 가정**: k개 정점 트리는 k-1개 간선
- **귀납 단계**: 리프 노드 제거 시 (k+1-1) = k개 간선

**철학적 의미**: 트리는 **"가장 효율적인 연결"**을 보여줍니다. 하나의 간선도 빠뜨릴 수 없고, 하나도 추가할 수 없습니다.

### 트리의 위상학적 특성

#### 계층 구조의 수학적 모델

트리는 **편순서집합(Partially Ordered Set)**을 구현합니다:
- **반사적**: 모든 노드는 자기 자신과 관계
- **이행적**: a ≤ b이고 b ≤ c이면 a ≤ c
- **반대칭적**: a ≤ b이고 b ≤ a이면 a = b

#### 루트의 특별함

루트 노드는 **최대원소(Maximal Element)**입니다:
- **유일성**: 단 하나만 존재
- **도달성**: 모든 노드에서 도달 가능
- **최상위성**: 부모가 없는 유일한 노드

#### 트리의 기본 용어와 수학적 의미

- **높이(Height)**: 루트에서 가장 먼 리프까지의 거리
- **깊이(Depth)**: 루트에서 특정 노드까지의 거리
- **레벨(Level)**: 같은 깊이를 가진 노드들의 집합
- **차수(Degree)**: 한 노드가 가진 자식의 수

**수학적 관계**: height(T) = max{depth(v) | v ∈ V}

## 이진 트리: 분할 정복의 완벽한 구현체

### 이진 트리의 수학적 특성

이진 트리에서 각 노드는 **최대 2개의 자식**을 가집니다:
- **분기 인수**: degree ≤ 2
- **재귀적 구조**: 각 서브트리도 이진 트리
- **자연수와의 대응**: 완전 이진 트리는 2^k 형태

### 카탈란 수와의 관계

n개 노드를 가진 이진 트리의 개수는 **카탈란 수**입니다:

**Cₙ = (1/(n+1)) × (2n choose n) = (2n)! / ((n+1)! × n!)**

이는 **조합론(Combinatorics)**의 깊은 결과입니다.

**구체적 값들**:
- C₀ = 1 (공집합)
- C₁ = 1 (루트만)
- C₂ = 2 (2가지 형태)
- C₃ = 5 (5가지 형태)
- C₄ = 14 (14가지 형태)

### 완전 이진 트리의 수학적 아름다움

#### 노드 수와 높이의 관계

- **높이 h인 완전 이진 트리**: 2^(h+1) - 1개 노드
- **n개 노드 완전 이진 트리**: 높이 = ⌊log₂(n)⌋

**수학적 의미**: 지수와 로그라는 **역함수 관계**가 자연스럽게 나타납니다.

#### 배열 표현의 수학적 우아함

**인덱스 공식** (1-based):
- **부모**: i/2
- **왼쪽 자식**: 2i
- **오른쪽 자식**: 2i+1

**수학적 의미**: 이진 수 표현과 트리 구조의 **자연스러운 대응**입니다.

### 이진 트리의 순회: 함수형 프로그래밍의 원리

#### 전위 순회 (Preorder): 루트 → 왼쪽 → 오른쪽

**수학적 의미**: 함수 적용 순서
- **용도**: 트리 복사, 구조 출력, 표현식 트리의 prefix 표기
- **재귀 관계**: preorder(T) = root + preorder(left) + preorder(right)

#### 중위 순회 (Inorder): 왼쪽 → 루트 → 오른쪽

**수학적 의미**: 정렬된 순서 (BST에서)
- **용도**: 정렬된 데이터 추출, 표현식 트리의 infix 표기
- **특성**: 이진 탐색 트리에서 오름차순 출력

#### 후위 순회 (Postorder): 왼쪽 → 오른쪽 → 루트

**수학적 의미**: 의존성 해결 순서
- **용도**: 메모리 해제, 수식 계산, 표현식 트리의 postfix 표기
- **특성**: 자식을 먼저 처리하고 부모 처리

#### 레벨 순회 (Level-order): BFS의 트리 버전

**구현**: 큐를 이용한 너비 우선 탐색
- **용도**: 레벨별 처리, 최소 높이 찾기
- **특성**: 위에서 아래로, 왼쪽에서 오른쪽으로

## 이진 탐색 트리 (BST): 순서의 기하학적 표현

### BST의 불변 조건 (Invariant)

모든 노드 v에 대해:
- **왼쪽 서브트리의 모든 값 < v의 값**
- **오른쪽 서브트리의 모든 값 > v의 값**

이는 **전순서(Total Order)**를 **트리 구조로 임베딩**한 것입니다.

### 탐색의 시간 복잡도

- **균형 트리**: O(log n) - 이진 탐색과 동등
- **선형 트리**: O(n) - 연결 리스트로 퇴화

**수학적 분석**: 평균 높이는 O(log n)이지만, 최악의 경우 O(n)입니다.

### BST의 연산들

#### 탐색 (Search)
**알고리즘**: 값 비교를 통한 방향 결정
**복잡도**: O(h) - h는 트리의 높이

#### 삽입 (Insert)
**알고리즘**: 탐색 + 리프 위치에 새 노드 추가
**복잡도**: O(h)
**불변조건**: BST 속성 유지

#### 삭제 (Delete)
**세 가지 경우**:
1. **리프 노드**: 단순 제거
2. **한 자식**: 자식으로 대체
3. **두 자식**: 중위 순회 후속자로 대체

**복잡도**: O(h)

## 균형 트리: 최적화의 수학

### AVL 트리: 높이 균형의 엄격함

#### 균형 조건
**균형 조건**: 모든 노드에서 좌우 서브트리의 높이 차이 ≤ 1

**수학적 증명**: AVL 트리의 높이는 1.44 × log₂(n)을 넘지 않습니다.

#### 회전 연산의 기하학

**단순 회전**: 3개 노드의 재배치
```
    y                x
   / \              / \
  x   C    →       A   y
 / \                  / \
A   B                B   C
```

**이중 회전**: 단순 회전 2회 조합
- **좌-우 회전**: 왼쪽 자식을 좌회전 후 우회전
- **우-좌 회전**: 오른쪽 자식을 우회전 후 좌회전

**수학적 의미**: 회전은 **동형사상(Isomorphism)**을 보존하는 변환입니다.

### 빨강-검정 트리 (Red-Black Tree)

#### 색깔 규칙
1. 모든 노드는 빨강 또는 검정
2. 루트는 검정
3. 리프(NIL)는 검정
4. 빨강 노드의 자식은 모두 검정
5. 모든 경로의 검정 노드 수 동일

**수학적 특성**: 높이 ≤ 2 × log₂(n+1)

### B-트리: 외부 메모리의 최적화

#### B-트리의 설계 철학
- **높은 분기 인수**: 디스크 블록 크기에 맞춤
- **균형 유지**: 모든 리프가 같은 레벨
- **순차 접근 최적화**: 리프 노드 연결

**수학적 특성**: 높이 O(log_m n) - m은 분기 인수

## 힙 (Heap): 우선순위의 트리 표현

### 힙의 수학적 정의

**힙 속성**: 부모 노드의 값 ≥ 자식 노드의 값 (최대 힙)

이는 **부분 순서**를 구현하며, 완전한 정렬은 아닙니다.

### 힙 연산의 복잡도

- **삽입**: O(log n) - 상향 버블링
- **삭제**: O(log n) - 하향 버블링
- **힙 구성**: O(n) - 하향식 구성

#### 힙 구성이 O(n)인 수학적 증명

**하향식 힙 구성**에서:
- 높이 h인 노드는 최대 ⌈n/2^(h+1)⌉개
- 각 노드의 작업량은 최대 h
- 총 작업량: Σ(h × ⌈n/2^(h+1)⌉) ≤ n × Σ(h/2^h) = n × 2 = O(n)

**수학적 의미**: **기하급수의 수렴**이 핵심입니다.

## 트라이 (Trie): 문자열의 트리 표현

### 접두사 트리의 수학적 모델

트라이는 **접두사 관계**를 **포함 관계**로 매핑합니다:
- **노드**: 접두사
- **간선**: 문자 추가
- **리프까지의 경로**: 완전한 문자열

### 공간-시간 트레이드오프

- **공간 복잡도**: O(ALPHABET_SIZE × N × M)
- **탐색 시간**: O(M) - 문자열 길이에만 의존

**수학적 의미**: 문자열 길이가 **독립 변수**가 됩니다.

### 압축 트라이 (Compressed Trie)

**아이디어**: 단일 자식 경로를 압축
- **공간 최적화**: 불필요한 중간 노드 제거
- **구현 복잡도**: 증가하지만 메모리 효율성 개선

## 세그먼트 트리: 구간의 분할 정복

### 구간 분할의 수학적 기초

세그먼트 트리는 **구간 [1, n]**을 **재귀적으로 분할**합니다:
- **분할**: [l, r] → [l, mid], [mid+1, r]
- **정복**: 각 구간의 결과 계산
- **결합**: 부분 결과 합성

### 함수적 특성

세그먼트 트리가 지원하는 연산은 **결합법칙**을 만족해야 합니다:
- **합**: (a + b) + c = a + (b + c)
- **최댓값**: max(max(a, b), c) = max(a, max(b, c))
- **GCD**: gcd(gcd(a, b), c) = gcd(a, gcd(b, c))

**수학적 의미**: **모노이드(Monoid)** 구조를 구간 연산으로 확장합니다.

### 지연 전파 (Lazy Propagation)

**문제**: 구간 업데이트의 효율성
**해결**: 업데이트를 지연시켜 필요할 때만 적용

**복잡도**: 구간 업데이트와 쿼리 모두 O(log n)

## 트리의 고급 알고리즘

### 최소 공통 조상 (LCA)

#### 이진 점프 (Binary Lifting)
**전처리**: O(n log n)
**쿼리**: O(log n)
**아이디어**: 2^k 거리만큼 점프하는 테이블 구성

#### Tarjan의 오프라인 알고리즘
**복잡도**: O(n + q) - q는 쿼리 수
**아이디어**: DFS와 Union-Find를 결합

### 무거운-가벼운 분해 (Heavy-Light Decomposition)

**아이디어**: 트리를 무거운 경로들로 분해
- **무거운 간선**: 서브트리 크기가 절반 이상인 자식으로의 간선
- **가벼운 간선**: 나머지 간선들

**응용**: 경로 쿼리를 O(log²n)에 처리

### 센트로이드 분해 (Centroid Decomposition)

**센트로이드**: 제거 시 모든 서브트리가 n/2 이하가 되는 노드
**분해**: 센트로이드를 루트로 하는 재귀적 분해

**응용**: 경로 쿼리, 거리 계산 등

## 트리의 응용과 실제 사용

### 파일 시스템
- **디렉토리 구조**: 자연스러운 트리 구조
- **경로 표현**: 루트에서 파일까지의 경로
- **권한 상속**: 부모 디렉토리로부터 권한 상속

### 구문 분석 트리
- **추상 구문 트리(AST)**: 프로그램 구조 표현
- **파싱**: 문법 규칙을 트리로 변환
- **코드 생성**: 트리 순회를 통한 코드 생성

### 결정 트리
- **기계 학습**: 분류와 회귀 문제
- **규칙 기반 시스템**: if-then 규칙의 구조화
- **게임 트리**: 게임 상태와 가능한 수

### 인덱싱 구조
- **B+ 트리**: 데이터베이스 인덱스
- **LSM 트리**: NoSQL 데이터베이스
- **R 트리**: 공간 데이터 인덱싱

## 메모리 관리와 최적화

### 노드 할당 전략

#### 개별 할당
**장점**: 구현 단순성
**단점**: 할당 오버헤드, 메모리 단편화

#### 풀 할당
**장점**: 빠른 할당/해제, 메모리 지역성
**단점**: 메모리 낭비 가능성

#### 슬래브 할당
**장점**: 커널에서 사용하는 효율적 방법
**특성**: 고정 크기 객체의 빠른 할당

### 캐시 최적화

#### 암묵적 트리 (Implicit Tree)
**아이디어**: 배열을 이용한 트리 표현
**장점**: 포인터 오버헤드 없음, 캐시 친화적
**단점**: 완전 이진 트리에만 적용 가능

#### van Emde Boas 레이아웃
**아이디어**: 재귀적 블록 분할로 캐시 최적화
**효과**: 트리 순회의 캐시 미스 감소

## 마무리: 트리 구조의 철학적 의미

트리는 **"자연스러운 계층"**과 **"효율적인 분할"**을 동시에 구현하는 완벽한 자료구조입니다:

### 트리의 수학적 아름다움
- **재귀적 정의**: 트리는 트리들로 구성
- **분할 정복**: 큰 문제를 작은 문제로 나누기
- **최적 부분 구조**: 부분 문제의 최적해가 전체 최적해에 기여

### 트리의 철학적 의미
- **계층의 자연스러움**: 현실 세계의 조직 구조 반영
- **균형의 중요성**: 편향된 구조의 문제점과 균형의 가치
- **추상화의 힘**: 복잡한 관계를 단순한 구조로 표현

**핵심 통찰**: 트리를 이해하는 것은 **"구조적 사고"**의 기초입니다. 복잡한 문제를 계층적으로 분해하고, 각 레벨에서 적절한 추상화를 적용하는 능력은 프로그래밍을 넘어서 **시스템 설계의 핵심 역량**입니다.

**철학적 결론**: 트리는 **"질서 있는 복잡성"**의 구현체입니다. 단순한 규칙(부모-자식 관계)으로부터 무한히 복잡한 구조를 만들어낼 수 있으며, 동시에 그 복잡성을 효율적으로 관리할 수 있습니다. 이는 **"단순함에서 나오는 복잡성"**이라는 컴퓨터 과학의 핵심 철학을 보여주는 완벽한 예시입니다.

## 구현에 대한 개념 설명

### 1. 트리 구현의 설계 철학과 메모리 관리

#### 노드 중심 설계의 핵심 원리

트리의 구현은 **"노드와 포인터의 네트워크"**라는 추상화를 물리적 메모리 구조로 변환하는 과정입니다. 이는 **그래프 이론의 수학적 개념**을 **컴퓨터 메모리의 현실적 제약** 안에서 구현하는 도전적인 작업입니다.

```c
typedef struct TreeNode {
    int data;                    // 실제 저장할 데이터
    struct TreeNode* left;       // 왼쪽 자식으로의 포인터
    struct TreeNode* right;      // 오른쪽 자식으로의 포인터
} TreeNode;
```

**설계 철학의 핵심 요소들**:

1. **자기 참조 구조체**: `struct TreeNode*`로 자기 자신을 참조하는 구조
2. **포인터 기반 연결**: 물리적으로 분산된 노드들을 논리적으로 연결
3. **NULL 포인터의 의미**: 존재하지 않는 자식을 표현하는 센티넬 값
4. **재귀적 정의**: 트리는 노드와 두 개의 서브트리로 구성

#### 메모리 할당 패턴의 이해

**동적 할당의 필연성**:
```c
TreeNode* createNode(int data) {
    TreeNode* newNode = malloc(sizeof(TreeNode));
    if (newNode == NULL) return NULL;  // 메모리 부족 처리

    newNode->data = data;
    newNode->left = NULL;              // 명시적 NULL 초기화
    newNode->right = NULL;
    return newNode;
}
```

**중요한 설계 결정들**:
- **NULL 초기화의 중요성**: 쓰레기 값을 가진 포인터는 segmentation fault 유발
- **메모리 할당 실패 처리**: 현실적인 시스템 제약 인정
- **단일 책임 원칙**: 노드 생성만을 담당하는 순수 함수

#### 트리 구조체의 메타데이터 관리

```c
typedef struct BinaryTree {
    TreeNode* root;              // 트리의 진입점
    int size;                    // 현재 노드 개수 (O(1) 크기 조회)
} BinaryTree;
```

**메타데이터의 역할**:
- **Root 포인터**: 전체 트리에 대한 단일 접근점
- **크기 추적**: 재귀적 계산 없이 O(1) 시간에 크기 확인
- **일관성 유지**: 삽입/삭제 시 메타데이터 동기화 필요

### 2. 재귀적 구현의 수학적 기초와 실용적 고려사항

#### 재귀의 수학적 아름다움

트리 순회는 **수학적 귀납법**의 완벽한 구현체입니다:

```c
void inorderTraversal(TreeNode* node) {
    if (node == NULL) return;        // 기저 사례 (Base Case)

    inorderTraversal(node->left);    // 귀납 가정 (Inductive Hypothesis)
    printf("%d ", node->data);        // 현재 단계 처리
    inorderTraversal(node->right);   // 귀납 단계 (Inductive Step)
}
```

**재귀적 사고의 구조**:
1. **기저 사례**: 더 이상 분해할 수 없는 가장 단순한 경우
2. **분할**: 문제를 더 작은 동일한 구조의 문제로 분해
3. **정복**: 부분 문제의 해를 구함
4. **결합**: 부분 해를 전체 해로 조합

#### 스택 기반 반복 구현의 필요성

**재귀의 한계와 해결책**:
```c
void inorderTraversalIterative(TreeNode* root) {
    TreeNode* stack[1000];           // 명시적 스택 사용
    int top = -1;
    TreeNode* current = root;

    while (current != NULL || top >= 0) {
        // Phase 1: 가장 왼쪽까지 이동하며 스택에 저장
        while (current != NULL) {
            stack[++top] = current;
            current = current->left;
        }

        // Phase 2: 스택에서 노드를 꺼내서 처리
        current = stack[top--];
        printf("%d ", current->data);

        // Phase 3: 오른쪽 서브트리로 이동
        current = current->right;
    }
}
```

**반복 구현의 핵심 통찰**:
- **명시적 스택**: 재귀 호출 스택을 명시적으로 시뮬레이션
- **상태 추적**: 현재 처리 단계를 명시적으로 관리
- **메모리 제어**: 스택 오버플로우 위험 제거
- **성능 최적화**: 함수 호출 오버헤드 제거

### 3. 이진 탐색 트리(BST)의 불변 조건과 구현 전략

#### BST 불변 조건의 수학적 엄밀성

**BST 속성**: 모든 노드 v에 대해
- `v.left.data < v.data < v.right.data`
- 이 조건이 모든 서브트리에서 재귀적으로 성립

```c
TreeNode* insertBST(TreeNode* root, int value) {
    // 재귀의 기저 사례: 빈 위치 발견
    if (root == NULL) {
        return createNode(value);
    }

    // 불변 조건 유지를 위한 방향 결정
    if (value < root->data) {
        root->left = insertBST(root->left, value);
    } else if (value > root->data) {
        root->right = insertBST(root->right, value);
    }
    // value == root->data인 경우: 중복 허용하지 않음

    return root;  // 불변 조건을 만족하는 트리 반환
}
```

**구현의 핵심 원칙**:
1. **불변 조건 보존**: 모든 연산 후 BST 속성 유지
2. **재귀적 구조 활용**: 서브트리도 BST라는 성질 이용
3. **중복 처리 정책**: 명확한 중복 값 처리 규칙 정의

#### BST 삭제의 복잡성과 해결 전략

**삭제의 세 가지 경우**:
```c
TreeNode* deleteBST(TreeNode* root, int value) {
    if (root == NULL) return root;

    // 1단계: 삭제할 노드 탐색
    if (value < root->data) {
        root->left = deleteBST(root->left, value);
    } else if (value > root->data) {
        root->right = deleteBST(root->right, value);
    } else {
        // 2단계: 삭제할 노드 발견, 경우별 처리

        // 경우 1: 리프 노드 - 단순 제거
        if (root->left == NULL && root->right == NULL) {
            free(root);
            return NULL;
        }

        // 경우 2: 한 자식 - 자식으로 대체
        if (root->left == NULL) {
            TreeNode* temp = root->right;
            free(root);
            return temp;
        }
        if (root->right == NULL) {
            TreeNode* temp = root->left;
            free(root);
            return temp;
        }

        // 경우 3: 두 자식 - 중위 순회 후속자로 대체
        TreeNode* successor = findMin(root->right);
        root->data = successor->data;  // 값만 복사
        root->right = deleteBST(root->right, successor->data);
    }

    return root;
}
```

**중위 순회 후속자 선택의 수학적 근거**:
- **정의**: 중위 순회에서 현재 노드 다음에 오는 노드
- **위치**: 오른쪽 서브트리의 최솟값
- **BST 속성 보존**: 대체 후에도 모든 BST 조건 만족

### 4. 균형 트리(AVL)의 회전 연산과 복잡도 분석

#### 균형 인수의 수학적 정의와 추적

```c
typedef struct AVLNode {
    int data;
    int height;                      // 서브트리 높이 저장
    struct AVLNode* left;
    struct AVLNode* right;
} AVLNode;

int getBalance(AVLNode* node) {
    return (node == NULL) ? 0 :
           getHeight(node->left) - getHeight(node->right);
}
```

**균형 조건**: 모든 노드에서 `|balance| ≤ 1`

**높이 업데이트의 중요성**:
```c
void updateHeight(AVLNode* node) {
    if (node == NULL) return;

    int leftHeight = getHeight(node->left);
    int rightHeight = getHeight(node->right);
    node->height = 1 + max(leftHeight, rightHeight);
}
```

#### 회전 연산의 기하학적 이해

**우회전(Right Rotation)의 수학적 모델**:
```c
AVLNode* rotateRight(AVLNode* y) {
    // 회전 전 구조: y가 불균형, x가 y의 왼쪽 자식
    AVLNode* x = y->left;
    AVLNode* T2 = x->right;

    // 회전 수행: x를 새로운 루트로
    x->right = y;
    y->left = T2;

    // 높이 재계산 (순서 중요: 자식부터)
    updateHeight(y);
    updateHeight(x);

    return x;  // 새로운 서브트리 루트
}
```

**회전의 불변 속성**:
1. **BST 속성 보존**: 회전 후에도 정렬 순서 유지
2. **서브트리 구조 보존**: 회전에 직접 관련되지 않은 부분 그대로 유지
3. **균형 복구**: 불균형한 높이 차이를 1 이하로 조정

**4가지 회전 케이스의 체계적 분류**:
```c
// Case 1: Left-Left (LL) - 우회전만
if (balance > 1 && value < node->left->data) {
    return rotateRight(node);
}

// Case 2: Right-Right (RR) - 좌회전만
if (balance < -1 && value > node->right->data) {
    return rotateLeft(node);
}

// Case 3: Left-Right (LR) - 좌회전 후 우회전
if (balance > 1 && value > node->left->data) {
    node->left = rotateLeft(node->left);
    return rotateRight(node);
}

// Case 4: Right-Left (RL) - 우회전 후 좌회전
if (balance < -1 && value < node->right->data) {
    node->right = rotateRight(node->right);
    return rotateLeft(node);
}
```

### 5. 힙 구현의 배열 기반 설계와 인덱스 수학

#### 완전 이진 트리의 배열 매핑

**인덱스 관계의 수학적 우아함** (0-기반):
```c
int parent(int i) { return (i - 1) / 2; }
int leftChild(int i) { return 2 * i + 1; }
int rightChild(int i) { return 2 * i + 2; }
```

**1-기반 인덱스의 더 직관적인 형태**:
```c
int parent(int i) { return i / 2; }
int leftChild(int i) { return 2 * i; }
int rightChild(int i) { return 2 * i + 1; }
```

**수학적 근거**: 이진 표현에서 비트 시프트와 자연스럽게 대응
- 부모로 이동: 우측 1비트 시프트 (나누기 2)
- 자식으로 이동: 좌측 1비트 시프트 + 0 또는 1

#### 힙 속성 유지 알고리즘

**상향 버블링 (Heapify Up)**:
```c
void heapifyUp(MaxHeap* heap, int index) {
    while (index > 0) {
        int parentIndex = parent(index);

        // 힙 속성이 만족되면 종료
        if (heap->data[parentIndex] >= heap->data[index]) {
            break;
        }

        // 부모와 교환하고 위로 이동
        swap(&heap->data[parentIndex], &heap->data[index]);
        index = parentIndex;
    }
}
```

**하향 버블링 (Heapify Down)**:
```c
void heapifyDown(MaxHeap* heap, int index) {
    while (true) {
        int largest = index;
        int left = leftChild(index);
        int right = rightChild(index);

        // 자식들과 비교하여 가장 큰 값 찾기
        if (left < heap->size &&
            heap->data[left] > heap->data[largest]) {
            largest = left;
        }

        if (right < heap->size &&
            heap->data[right] > heap->data[largest]) {
            largest = right;
        }

        // 힙 속성이 만족되면 종료
        if (largest == index) break;

        // 가장 큰 자식과 교환하고 아래로 이동
        swap(&heap->data[index], &heap->data[largest]);
        index = largest;
    }
}
```

**Floyd의 buildHeap 알고리즘**:
```c
void buildMaxHeap(MaxHeap* heap, int arr[], int n) {
    // 배열 복사
    memcpy(heap->data, arr, n * sizeof(int));
    heap->size = n;

    // 마지막 내부 노드부터 역순으로 heapify
    for (int i = parent(n - 1); i >= 0; i--) {
        heapifyDown(heap, i);
    }
}
```

**시간 복잡도 분석의 수학적 증명**:
- **직관적 분석**: n개 노드 × log n 높이 = O(n log n)
- **정확한 분석**: 각 레벨의 노드 수와 이동 거리를 고려하면 O(n)
- **수학적 증명**: Σ(h × nodes_at_height_h) = O(n)

### 6. 메모리 관리와 성능 최적화 전략

#### 메모리 풀링과 캐시 최적화

**노드 풀 구현**:
```c
typedef struct NodePool {
    TreeNode nodes[POOL_SIZE];
    bool used[POOL_SIZE];
    TreeNode* freeList;
    int freeCount;
} NodePool;

TreeNode* allocateFromPool(NodePool* pool) {
    if (pool->freeCount == 0) {
        return NULL;  // 풀 고갈
    }

    TreeNode* node = pool->freeList;
    pool->freeList = pool->freeList->left;  // next 포인터로 사용
    pool->freeCount--;

    // 노드 초기화
    node->left = node->right = NULL;
    return node;
}
```

**캐시 친화적 트리 배치**:
```c
// van Emde Boas 레이아웃 구현
typedef struct CacheOptimizedTree {
    int* data;                   // 선형 배치된 데이터
    int* structure;              // 구조 정보
    int size;
    int height;
} CacheOptimizedTree;
```

#### 메모리 해제 전략

**후위 순회 기반 안전한 해제**:
```c
void destroyTree(TreeNode* root) {
    if (root == NULL) return;

    // 자식들을 먼저 해제 (후위 순회)
    destroyTree(root->left);
    destroyTree(root->right);

    // 마지막에 자신을 해제
    free(root);
}

void destroyTreeSafe(TreeNode** root) {
    if (root == NULL || *root == NULL) return;

    destroyTree(*root);
    *root = NULL;  // 댕글링 포인터 방지
}
```

### 7. 동시성과 락-프리 트리 구현

#### 읽기-쓰기 락을 이용한 동시성

```c
typedef struct ConcurrentBST {
    TreeNode* root;
    pthread_rwlock_t lock;
    int size;
} ConcurrentBST;

bool searchConcurrent(ConcurrentBST* tree, int value) {
    pthread_rwlock_rdlock(&tree->lock);
    bool found = (searchBST(tree->root, value) != NULL);
    pthread_rwlock_unlock(&tree->lock);
    return found;
}

void insertConcurrent(ConcurrentBST* tree, int value) {
    pthread_rwlock_wrlock(&tree->lock);
    tree->root = insertBST(tree->root, value);
    tree->size++;
    pthread_rwlock_unlock(&tree->lock);
}
```

#### 락-프리 구현의 도전과 해결책

**문제점들**:
1. **ABA 문제**: 포인터 재사용으로 인한 오판
2. **메모리 순서**: 멀티코어에서의 메모리 가시성
3. **노드 삭제**: 동시 접근 중인 노드의 안전한 삭제

**해결 전략**:
```c
// 태그된 포인터 사용
typedef struct TaggedPointer {
    TreeNode* ptr;
    uint64_t tag;
} TaggedPointer;

// Hazard Pointer를 이용한 안전한 메모리 관리
typedef struct HazardPointer {
    TreeNode* ptr;
    int threadId;
} HazardPointer;
```

### 8. 트리 구현의 검증과 테스팅

#### 불변 조건 검증 함수

```c
bool validateBST(TreeNode* root, int minVal, int maxVal) {
    if (root == NULL) return true;

    // 현재 노드 값 검증
    if (root->data <= minVal || root->data >= maxVal) {
        return false;
    }

    // 서브트리 재귀 검증
    return validateBST(root->left, minVal, root->data) &&
           validateBST(root->right, root->data, maxVal);
}

bool validateAVL(AVLNode* root) {
    if (root == NULL) return true;

    // 높이 정보 검증
    int expectedHeight = 1 + max(getHeight(root->left),
                                 getHeight(root->right));
    if (root->height != expectedHeight) return false;

    // 균형 조건 검증
    int balance = getBalance(root);
    if (abs(balance) > 1) return false;

    // 서브트리 재귀 검증
    return validateAVL(root->left) && validateAVL(root->right);
}
```

**핵심 통찰**: 트리 구현은 단순한 포인터 조작을 넘어서 **수학적 원리와 시스템 제약의 완벽한 조화**를 요구합니다. 재귀적 사고, 불변 조건 유지, 메모리 관리, 성능 최적화가 모두 조화롭게 어우러져야 비로소 실용적이고 신뢰할 수 있는 트리 자료구조가 완성됩니다.

**철학적 결론**: 트리 구현을 마스터하는 것은 **"추상적 사고와 구체적 구현의 간극을 메우는 능력"**을 기르는 것입니다. 이는 복잡한 시스템을 설계할 때 반드시 필요한 **"개념적 모델링과 물리적 제약 사이의 균형"**을 찾는 핵심 역량입니다.

## 이진 트리 구현

### 기본 구조 정의

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

// 이진 트리 노드 구조체
typedef struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

// 트리 구조체
typedef struct BinaryTree {
    TreeNode* root;
    int size;
} BinaryTree;

// 노드 생성
TreeNode* createNode(int data) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    if (newNode == NULL) {
        printf("메모리 할당 실패\n");
        return NULL;
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// 트리 초기화
BinaryTree* createBinaryTree() {
    BinaryTree* tree = (BinaryTree*)malloc(sizeof(BinaryTree));
    if (tree == NULL) {
        printf("메모리 할당 실패\n");
        return NULL;
    }
    tree->root = NULL;
    tree->size = 0;
    return tree;
}
```

### 트리 순회 구현

#### 전위 순회 (Preorder)

```c
void preorderTraversal(TreeNode* node) {
    if (node == NULL) return;

    printf("%d ", node->data);      // 루트 방문
    preorderTraversal(node->left);  // 왼쪽 서브트리
    preorderTraversal(node->right); // 오른쪽 서브트리
}

void preorderTraversalIterative(TreeNode* root) {
    if (root == NULL) return;

    TreeNode* stack[1000];
    int top = -1;

    stack[++top] = root;

    while (top >= 0) {
        TreeNode* current = stack[top--];
        printf("%d ", current->data);

        // 오른쪽을 먼저 스택에 넣음 (나중에 처리)
        if (current->right) stack[++top] = current->right;
        if (current->left) stack[++top] = current->left;
    }
}
```

#### 중위 순회 (Inorder)

```c
void inorderTraversal(TreeNode* node) {
    if (node == NULL) return;

    inorderTraversal(node->left);   // 왼쪽 서브트리
    printf("%d ", node->data);      // 루트 방문
    inorderTraversal(node->right);  // 오른쪽 서브트리
}

void inorderTraversalIterative(TreeNode* root) {
    TreeNode* stack[1000];
    int top = -1;
    TreeNode* current = root;

    while (current != NULL || top >= 0) {
        // 가장 왼쪽 노드까지 이동
        while (current != NULL) {
            stack[++top] = current;
            current = current->left;
        }

        // 스택에서 노드를 꺼내서 방문
        current = stack[top--];
        printf("%d ", current->data);

        // 오른쪽 서브트리로 이동
        current = current->right;
    }
}
```

#### 후위 순회 (Postorder)

```c
void postorderTraversal(TreeNode* node) {
    if (node == NULL) return;

    postorderTraversal(node->left);  // 왼쪽 서브트리
    postorderTraversal(node->right); // 오른쪽 서브트리
    printf("%d ", node->data);       // 루트 방문
}

void postorderTraversalIterative(TreeNode* root) {
    if (root == NULL) return;

    TreeNode* stack1[1000], *stack2[1000];
    int top1 = -1, top2 = -1;

    stack1[++top1] = root;

    // 첫 번째 스택으로 노드를 역순으로 두 번째 스택에 저장
    while (top1 >= 0) {
        TreeNode* current = stack1[top1--];
        stack2[++top2] = current;

        if (current->left) stack1[++top1] = current->left;
        if (current->right) stack1[++top1] = current->right;
    }

    // 두 번째 스택에서 노드를 꺼내서 출력
    while (top2 >= 0) {
        printf("%d ", stack2[top2--]->data);
    }
}
```

#### 레벨 순회 (Level-order)

```c
void levelOrderTraversal(TreeNode* root) {
    if (root == NULL) return;

    TreeNode* queue[1000];
    int front = 0, rear = 0;

    queue[rear++] = root;

    while (front < rear) {
        TreeNode* current = queue[front++];
        printf("%d ", current->data);

        if (current->left) queue[rear++] = current->left;
        if (current->right) queue[rear++] = current->right;
    }
}
```

### 트리 유틸리티 함수들

#### 트리 높이 계산

```c
int treeHeight(TreeNode* node) {
    if (node == NULL) return -1;

    int leftHeight = treeHeight(node->left);
    int rightHeight = treeHeight(node->right);

    return 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);
}
```

#### 노드 개수 계산

```c
int countNodes(TreeNode* node) {
    if (node == NULL) return 0;

    return 1 + countNodes(node->left) + countNodes(node->right);
}
```

#### 리프 노드 개수 계산

```c
int countLeaves(TreeNode* node) {
    if (node == NULL) return 0;

    if (node->left == NULL && node->right == NULL) return 1;

    return countLeaves(node->left) + countLeaves(node->right);
}
```

#### 트리에서 값 검색

```c
TreeNode* searchTree(TreeNode* node, int value) {
    if (node == NULL || node->data == value) {
        return node;
    }

    TreeNode* leftResult = searchTree(node->left, value);
    if (leftResult != NULL) return leftResult;

    return searchTree(node->right, value);
}
```

## 이진 탐색 트리 (BST) 구현

### BST 구조체

```c
typedef struct BST {
    TreeNode* root;
    int size;
} BST;

BST* createBST() {
    BST* bst = (BST*)malloc(sizeof(BST));
    if (bst == NULL) return NULL;
    bst->root = NULL;
    bst->size = 0;
    return bst;
}
```

### BST 삽입

```c
TreeNode* insertBST(TreeNode* root, int value) {
    // 빈 위치에 도달하면 새 노드 생성
    if (root == NULL) {
        return createNode(value);
    }

    // 중복 값은 삽입하지 않음
    if (value == root->data) {
        return root;
    }

    // 값에 따라 왼쪽 또는 오른쪽으로 이동
    if (value < root->data) {
        root->left = insertBST(root->left, value);
    } else {
        root->right = insertBST(root->right, value);
    }

    return root;
}

void insertBSTWrapper(BST* bst, int value) {
    if (bst == NULL) return;

    TreeNode* oldRoot = bst->root;
    bst->root = insertBST(bst->root, value);

    // 새 노드가 실제로 삽입되었는지 확인
    if (bst->root != oldRoot || oldRoot == NULL) {
        bst->size++;
    }
}
```

### BST 탐색

```c
TreeNode* searchBST(TreeNode* root, int value) {
    // 빈 트리이거나 값을 찾았으면 반환
    if (root == NULL || root->data == value) {
        return root;
    }

    // 값에 따라 왼쪽 또는 오른쪽으로 이동
    if (value < root->data) {
        return searchBST(root->left, value);
    } else {
        return searchBST(root->right, value);
    }
}

bool containsBST(BST* bst, int value) {
    return searchBST(bst->root, value) != NULL;
}
```

### BST 삭제

```c
TreeNode* findMin(TreeNode* root) {
    while (root && root->left) {
        root = root->left;
    }
    return root;
}

TreeNode* deleteBST(TreeNode* root, int value) {
    if (root == NULL) return root;

    // 삭제할 노드 찾기
    if (value < root->data) {
        root->left = deleteBST(root->left, value);
    } else if (value > root->data) {
        root->right = deleteBST(root->right, value);
    } else {
        // 삭제할 노드를 찾음

        // 케이스 1: 리프 노드 (자식이 없음)
        if (root->left == NULL && root->right == NULL) {
            free(root);
            return NULL;
        }

        // 케이스 2: 한 개의 자식만 있음
        if (root->left == NULL) {
            TreeNode* temp = root->right;
            free(root);
            return temp;
        }
        if (root->right == NULL) {
            TreeNode* temp = root->left;
            free(root);
            return temp;
        }

        // 케이스 3: 두 개의 자식이 있음
        // 중위 순회 후속자 (오른쪽 서브트리의 최솟값)를 찾음
        TreeNode* successor = findMin(root->right);

        // 후속자의 값을 현재 노드에 복사
        root->data = successor->data;

        // 후속자 삭제
        root->right = deleteBST(root->right, successor->data);
    }

    return root;
}

void deleteBSTWrapper(BST* bst, int value) {
    if (bst == NULL) return;

    if (searchBST(bst->root, value) != NULL) {
        bst->root = deleteBST(bst->root, value);
        bst->size--;
    }
}
```

## 힙 구현

### 최대 힙 구조체

```c
#define MAX_HEAP_SIZE 100

typedef struct MaxHeap {
    int data[MAX_HEAP_SIZE];
    int size;
    int capacity;
} MaxHeap;

MaxHeap* createMaxHeap() {
    MaxHeap* heap = (MaxHeap*)malloc(sizeof(MaxHeap));
    if (heap == NULL) return NULL;

    heap->size = 0;
    heap->capacity = MAX_HEAP_SIZE;
    return heap;
}

// 부모 인덱스 계산
int parent(int i) { return (i - 1) / 2; }

// 왼쪽 자식 인덱스 계산
int leftChild(int i) { return 2 * i + 1; }

// 오른쪽 자식 인덱스 계산
int rightChild(int i) { return 2 * i + 2; }

// 두 값 교환
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}
```

### 힙 삽입

```c
void insertHeap(MaxHeap* heap, int value) {
    if (heap == NULL || heap->size >= heap->capacity) {
        printf("힙이 가득 찼습니다.\n");
        return;
    }

    // 새 원소를 맨 끝에 추가
    int index = heap->size++;
    heap->data[index] = value;

    // 상향 버블링 (heapify up)
    while (index > 0 && heap->data[parent(index)] < heap->data[index]) {
        swap(&heap->data[parent(index)], &heap->data[index]);
        index = parent(index);
    }
}
```

### 힙 삭제 (최댓값 추출)

```c
void heapifyDown(MaxHeap* heap, int index) {
    int largest = index;
    int left = leftChild(index);
    int right = rightChild(index);

    // 왼쪽 자식이 더 큰지 확인
    if (left < heap->size && heap->data[left] > heap->data[largest]) {
        largest = left;
    }

    // 오른쪽 자식이 더 큰지 확인
    if (right < heap->size && heap->data[right] > heap->data[largest]) {
        largest = right;
    }

    // 가장 큰 원소가 현재 노드가 아니면 교환하고 계속
    if (largest != index) {
        swap(&heap->data[index], &heap->data[largest]);
        heapifyDown(heap, largest);
    }
}

int extractMax(MaxHeap* heap) {
    if (heap == NULL || heap->size == 0) {
        printf("힙이 비어있습니다.\n");
        return -1;
    }

    int max = heap->data[0];

    // 마지막 원소를 루트로 이동
    heap->data[0] = heap->data[--heap->size];

    // 하향 버블링 (heapify down)
    heapifyDown(heap, 0);

    return max;
}
```

### 배열에서 힙 구성

```c
void buildMaxHeap(MaxHeap* heap, int arr[], int n) {
    if (heap == NULL || n > heap->capacity) return;

    // 배열 복사
    for (int i = 0; i < n; i++) {
        heap->data[i] = arr[i];
    }
    heap->size = n;

    // 마지막 내부 노드부터 루트까지 heapify
    for (int i = parent(n - 1); i >= 0; i--) {
        heapifyDown(heap, i);
    }
}
```

## AVL 트리 구현

### AVL 노드 구조체

```c
typedef struct AVLNode {
    int data;
    int height;
    struct AVLNode* left;
    struct AVLNode* right;
} AVLNode;

typedef struct AVLTree {
    AVLNode* root;
    int size;
} AVLTree;

AVLNode* createAVLNode(int data) {
    AVLNode* node = (AVLNode*)malloc(sizeof(AVLNode));
    if (node == NULL) return NULL;

    node->data = data;
    node->height = 1;
    node->left = NULL;
    node->right = NULL;
    return node;
}

int getHeight(AVLNode* node) {
    return (node == NULL) ? 0 : node->height;
}

int getBalance(AVLNode* node) {
    return (node == NULL) ? 0 : getHeight(node->left) - getHeight(node->right);
}

void updateHeight(AVLNode* node) {
    if (node == NULL) return;

    int leftHeight = getHeight(node->left);
    int rightHeight = getHeight(node->right);
    node->height = 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);
}
```

### AVL 회전 연산

```c
// 우회전 (Right Rotation)
AVLNode* rotateRight(AVLNode* y) {
    AVLNode* x = y->left;
    AVLNode* T2 = x->right;

    // 회전 수행
    x->right = y;
    y->left = T2;

    // 높이 업데이트
    updateHeight(y);
    updateHeight(x);

    return x;
}

// 좌회전 (Left Rotation)
AVLNode* rotateLeft(AVLNode* x) {
    AVLNode* y = x->right;
    AVLNode* T2 = y->left;

    // 회전 수행
    y->left = x;
    x->right = T2;

    // 높이 업데이트
    updateHeight(x);
    updateHeight(y);

    return y;
}
```

### AVL 삽입

```c
AVLNode* insertAVL(AVLNode* node, int value) {
    // 1. 일반적인 BST 삽입
    if (node == NULL) {
        return createAVLNode(value);
    }

    if (value < node->data) {
        node->left = insertAVL(node->left, value);
    } else if (value > node->data) {
        node->right = insertAVL(node->right, value);
    } else {
        return node; // 중복 값은 삽입하지 않음
    }

    // 2. 높이 업데이트
    updateHeight(node);

    // 3. 균형 인수 계산
    int balance = getBalance(node);

    // 4. 균형이 깨진 경우 회전으로 복구

    // Left Left Case
    if (balance > 1 && value < node->left->data) {
        return rotateRight(node);
    }

    // Right Right Case
    if (balance < -1 && value > node->right->data) {
        return rotateLeft(node);
    }

    // Left Right Case
    if (balance > 1 && value > node->left->data) {
        node->left = rotateLeft(node->left);
        return rotateRight(node);
    }

    // Right Left Case
    if (balance < -1 && value < node->right->data) {
        node->right = rotateRight(node->right);
        return rotateLeft(node);
    }

    return node;
}
```

## 트리 검증 함수들

### BST 유효성 검사

```c
bool isValidBSTHelper(TreeNode* node, int min, int max) {
    if (node == NULL) return true;

    if (node->data <= min || node->data >= max) {
        return false;
    }

    return isValidBSTHelper(node->left, min, node->data) &&
           isValidBSTHelper(node->right, node->data, max);
}

bool isValidBST(TreeNode* root) {
    return isValidBSTHelper(root, INT_MIN, INT_MAX);
}
```

### 트리가 균형 잡혔는지 확인

```c
bool isBalancedHelper(TreeNode* node, int* height) {
    if (node == NULL) {
        *height = 0;
        return true;
    }

    int leftHeight, rightHeight;
    bool leftBalanced = isBalancedHelper(node->left, &leftHeight);
    bool rightBalanced = isBalancedHelper(node->right, &rightHeight);

    *height = 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);

    if (!leftBalanced || !rightBalanced) return false;

    return abs(leftHeight - rightHeight) <= 1;
}

bool isBalanced(TreeNode* root) {
    int height;
    return isBalancedHelper(root, &height);
}
```

## 실제 사용 예제

```c
int main() {
    printf("=== 이진 트리 테스트 ===\n");

    // 수동으로 트리 구성
    TreeNode* root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);
    root->left->left = createNode(4);
    root->left->right = createNode(5);

    printf("전위 순회: ");
    preorderTraversal(root);
    printf("\n");

    printf("중위 순회: ");
    inorderTraversal(root);
    printf("\n");

    printf("후위 순회: ");
    postorderTraversal(root);
    printf("\n");

    printf("레벨 순회: ");
    levelOrderTraversal(root);
    printf("\n");

    printf("트리 높이: %d\n", treeHeight(root));
    printf("노드 개수: %d\n", countNodes(root));

    printf("\n=== BST 테스트 ===\n");
    BST* bst = createBST();

    insertBSTWrapper(bst, 50);
    insertBSTWrapper(bst, 30);
    insertBSTWrapper(bst, 70);
    insertBSTWrapper(bst, 20);
    insertBSTWrapper(bst, 40);
    insertBSTWrapper(bst, 60);
    insertBSTWrapper(bst, 80);

    printf("BST 중위 순회 (정렬된 순서): ");
    inorderTraversal(bst->root);
    printf("\n");

    printf("값 40 검색: %s\n", containsBST(bst, 40) ? "찾음" : "없음");
    printf("값 90 검색: %s\n", containsBST(bst, 90) ? "찾음" : "없음");

    deleteBSTWrapper(bst, 30);
    printf("30 삭제 후 중위 순회: ");
    inorderTraversal(bst->root);
    printf("\n");

    printf("\n=== 힙 테스트 ===\n");
    MaxHeap* heap = createMaxHeap();

    insertHeap(heap, 10);
    insertHeap(heap, 20);
    insertHeap(heap, 15);
    insertHeap(heap, 40);
    insertHeap(heap, 50);
    insertHeap(heap, 100);
    insertHeap(heap, 25);

    printf("힙에서 최댓값들 추출: ");
    while (heap->size > 0) {
        printf("%d ", extractMax(heap));
    }
    printf("\n");

    return 0;
}
```