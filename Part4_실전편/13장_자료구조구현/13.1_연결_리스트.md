# 13.1 연결 리스트 (Linked List)

## 핵심 개념: 연결의 철학과 순서의 수학

연결 리스트는 **"연결(Connection)"**과 **"순서(Sequence)"**라는 두 가지 근본적 개념을 구현한 자료구조입니다. 이는 수학의 **순열(Sequence)**과 **그래프 이론(Graph Theory)**의 만남이라고 할 수 있습니다.

### 연결 리스트의 수학적 모델링

연결 리스트를 수학적으로 모델링하면:
- **집합 S = {a₁, a₂, a₃, ..., aₙ}**: 데이터 원소들
- **함수 f: S → S ∪ {NULL}**: 다음 원소를 가리키는 관계
- **순서 관계**: f(aᵢ) = aᵢ₊₁ (1 ≤ i < n), f(aₙ) = NULL

**핵심 통찰**: 배열이 **"인덱스를 통한 직접 접근"**이라면, 연결 리스트는 **"관계를 통한 순차 접근"**입니다.

### 메모리 구조의 철학적 대립

#### 배열 vs 연결 리스트: 메모리 철학의 근본적 차이

**배열의 철학**:
- **연속성(Contiguity)**: 모든 원소가 메모리상 연속으로 배치
- **예측 가능성(Predictability)**: 위치 = 시작주소 + (인덱스 × 크기)
- **캐시 효율성**: 공간 지역성(Spatial Locality) 활용

**연결 리스트의 철학**:
- **분산성(Distribution)**: 원소들이 메모리 전체에 분산
- **유연성(Flexibility)**: 동적 크기 조정 가능
- **포인터 비용**: 각 노드마다 추가 메모리 필요

**철학적 의미**: 이는 **"효율성과 유연성"**의 근본적 트레이드오프를 보여줍니다.

## 시간 복잡도의 수학적 분석

### 접근 연산의 비교
- **배열**: T(n) = O(1) - 상수 시간
- **연결 리스트**: T(n) = O(k) - k번째 원소까지 순차 탐색

**수학적 증명**: 연결 리스트에서 k번째 원소에 접근하려면 k-1번의 포인터 따라가기가 필요합니다.

### 삽입/삭제 연산의 분석
- **배열 중간 삽입**: O(n) - 뒤의 모든 원소 이동
- **연결 리스트 중간 삽입**: O(1) - 포인터만 조정 (위치를 안다면)

**수학적 의미**: 연결 리스트는 **"구조적 변경에 대한 지역성"**을 제공합니다.

### 메모리 오버헤드 분석
- **배열**: 추가 메모리 = 0
- **연결 리스트**: 추가 메모리 = n × sizeof(pointer)

**트레이드오프**: 메모리 효율성 vs 구조적 유연성

## 연결 리스트의 변형과 수학적 특성

### 단일 연결 리스트 (Singly Linked List)

#### 수학적 특성
- **방향성**: 단방향 그래프와 동치
- **순환 검출**: Floyd의 거북이-토끼 알고리즘 적용 가능
- **수학적 모델**: 함수 f: Node → Node ∪ {NULL}

#### 구조적 제약
- **역방향 탐색 불가**: 단방향성의 제약
- **삭제 시 이전 노드 필요**: O(n) 탐색 필요

### 이중 연결 리스트 (Doubly Linked List)

#### 수학적 특성
- **양방향성**: 무방향 그래프의 경로와 유사
- **대칭성**: f(x) = y ⟺ g(y) = x (g는 역방향 함수)
- **공간 비용**: 2배의 포인터 오버헤드

#### 연산의 개선
- **역방향 탐색**: O(1) 시간에 이전 노드 접근
- **삭제 연산**: 노드 자체만으로 O(1) 삭제 가능

### 원형 연결 리스트 (Circular Linked List)

#### 수학적 특성
- **순환성**: 마지막 노드가 첫 번째 노드를 가리킴
- **수학적 특성**: 유한 순환군과 동형
- **모듈러 산술**: 인덱스 연산에서 mod n 적용

#### 응용 영역
- **라운드 로빈 스케줄링**: 공정한 자원 배분
- **버퍼링**: 순환 버퍼 구현
- **게임 개발**: 턴 기반 시스템

## 연결 리스트의 고급 연산과 알고리즘

### 리스트 뒤집기 (List Reversal)

#### 반복적 방법의 수학적 분석
**시간 복잡도**: O(n) - 각 노드를 정확히 한 번 방문
**공간 복잡도**: O(1) - 추가 공간 불필요

**수학적 의미**: 순서 관계의 **역함수**를 구성하는 과정

#### 재귀적 방법의 수학적 분석
**시간 복잡도**: O(n) - 각 노드를 정확히 한 번 방문
**공간 복잡도**: O(n) - 콜 스택의 깊이

**수학적 의미**: **구조적 귀납법**을 이용한 문제 해결

### 두 리스트 합병 (Merge Two Lists)

#### 정렬된 리스트 합병
**시간 복잡도**: O(m + n) - 각 원소를 한 번씩 비교
**공간 복잡도**: O(1) - 포인터 조작만 수행

**수학적 원리**: 두 **단조증가 수열**의 **병합 정렬** 원리

### 순환 검출 (Cycle Detection)

#### Floyd의 거북이-토끼 알고리즘
**수학적 원리**: 서로 다른 속도로 움직이는 두 포인터가 순환에서 만나는 현상

**시간 복잡도**: O(n)
**공간 복잡도**: O(1)

**수학적 증명**: 순환이 있다면 빠른 포인터와 느린 포인터는 반드시 만납니다.

## 메모리 관리와 성능 최적화

### 메모리 할당 패턴
- **개별 할당**: 각 노드마다 malloc() 호출
- **블록 할당**: 여러 노드를 한 번에 할당
- **메모리 풀**: 미리 할당된 메모리 영역 사용

### 캐시 성능 고려사항
- **공간 지역성 부족**: 연속되지 않은 메모리 접근
- **프리페칭 효과 없음**: 예측 가능한 접근 패턴 부재
- **캐시 미스 빈도 높음**: 포인터 따라가기의 비용

### 최적화 기법
- **노드 크기 최적화**: 캐시 라인에 맞춘 크기 설계
- **메모리 정렬**: 구조체 패딩 최소화
- **지역성 개선**: 관련 노드들의 근접 배치

## 연결 리스트의 실제 응용

### 운영체제에서의 활용
- **프로세스 리스트**: 실행 중인 프로세스 관리
- **메모리 관리**: 빈 블록 리스트
- **파일 시스템**: 디렉토리 엔트리 연결

### 알고리즘에서의 활용
- **그래프 표현**: 인접 리스트로 그래프 구현
- **해시 테이블**: 체이닝을 통한 충돌 해결
- **스택/큐 구현**: 동적 크기의 스택과 큐

### 언어별 구현 특성
- **C**: 명시적 포인터 관리 필요
- **C++**: 스마트 포인터를 통한 자동 메모리 관리
- **Java/Python**: 가비지 컬렉션을 통한 자동 해제

## 연결 리스트의 한계와 대안

### 근본적 한계
- **순차 접근**: 임의 접근 불가능
- **메모리 오버헤드**: 포인터로 인한 추가 메모리
- **캐시 성능**: 연속되지 않은 메모리 접근

### 현대적 대안들
- **동적 배열**: vector, ArrayList 등
- **덱(Deque)**: 양방향 성능 최적화
- **B+ 트리**: 블록 단위 접근으로 캐시 최적화

## 마무리: 연결 리스트의 철학적 가치

연결 리스트는 **"동적 구조의 원형"**입니다. 비록 현대의 최적화된 자료구조들이 더 나은 성능을 제공하지만, 연결 리스트는 여전히 중요한 가치를 가집니다:

1. **개념적 단순성**: 포인터와 동적 할당의 기초 개념
2. **구조적 유연성**: 크기 제약 없는 동적 확장
3. **교육적 가치**: 자료구조 설계의 기본 원리 학습

**핵심 통찰**: 연결 리스트를 이해하는 것은 **"포인터의 힘"**과 **"동적 메모리의 가능성"**을 이해하는 첫걸음입니다. 이는 더 복잡한 자료구조들의 **기초 토대**가 됩니다.

**철학적 결론**: 연결 리스트는 **"단순함 속의 깊이"**를 보여줍니다. 포인터라는 단순한 개념으로 무한한 확장성을 가진 구조를 만들어내는 것은, 프로그래밍에서 **"기본기의 중요성"**을 일깨워주는 완벽한 예시입니다.

## 실제 구현: 단일 연결 리스트

### 구현 설계 철학

연결 리스트의 구현에서 가장 중요한 것은 **"포인터 관리"**와 **"메모리 안전성"**입니다. 각 노드는 독립적인 메모리 블록이며, 이들 사이의 연결은 순전히 포인터를 통해 이루어집니다.

#### 핵심 설계 원칙

1. **캡슐화**: 내부 구조를 숨기고 안전한 인터페이스 제공
2. **일관성**: 모든 연산 후 리스트의 불변조건 유지
3. **안전성**: NULL 포인터 검사와 메모리 누수 방지
4. **효율성**: 불필요한 순회 최소화

#### 메모리 관리 전략

- **명시적 할당/해제**: malloc과 free를 통한 수동 메모리 관리
- **소유권 명확화**: 각 노드의 메모리 소유권을 명확히 정의
- **예외 안전성**: 할당 실패 시 기존 구조 보존

### 기본 구조 정의

```c
#include <stdio.h>
#include <stdlib.h>

// 노드 구조체 정의
typedef struct Node {
    int data;           // 데이터 필드
    struct Node* next;  // 다음 노드를 가리키는 포인터
} Node;

// 리스트 구조체 정의
typedef struct LinkedList {
    Node* head;         // 첫 번째 노드를 가리키는 포인터
    int size;           // 리스트의 크기
} LinkedList;
```

#### 구조체 설계 해석

**Node 구조체**:
- `int data`: 실제 저장할 데이터 (일반화 가능)
- `struct Node* next`: 다음 노드를 가리키는 포인터 (핵심!)

**LinkedList 구조체**:
- `Node* head`: 첫 번째 노드의 주소 (진입점)
- `int size`: 현재 노드 개수 (효율성을 위한 캐시)

**설계 철학**: 구조체는 **"데이터와 연결의 분리"**를 구현합니다. 데이터는 각 노드에, 전체 구조 정보는 리스트 객체에 저장합니다.

### 리스트 초기화

```c
LinkedList* createList() {
    LinkedList* list = (LinkedList*)malloc(sizeof(LinkedList));
    if (list == NULL) {
        printf("메모리 할당 실패\n");
        return NULL;
    }
    list->head = NULL;
    list->size = 0;
    return list;
}
```

#### 초기화 과정 해석

1. **동적 할당**: 힙에 LinkedList 크기만큼 메모리 요청
2. **실패 처리**: malloc 실패 시 NULL 반환으로 안전성 확보
3. **초기 상태 설정**: 빈 리스트 상태로 초기화
   - `head = NULL`: 아직 노드가 없음을 표현
   - `size = 0`: 명시적 크기 정보 초기화

**핵심 개념**: NULL 포인터는 **"없음"**을 나타내는 특별한 값으로, 연결 리스트의 끝을 표시합니다.

### 노드 생성

```c
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        printf("메모리 할당 실패\n");
        return NULL;
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}
```

#### 노드 생성 과정의 세부 분석

1. **메모리 할당**: `sizeof(Node)` 크기의 메모리 블록 요청
2. **타입 캐스팅**: `malloc` 반환값을 `Node*`로 명시적 변환
3. **실패 검사**: 메모리 부족 시 NULL 반환 처리
4. **초기화**:
   - `data` 필드에 값 저장
   - `next`를 NULL로 설정 (중요!)

**왜 next를 NULL로 설정하는가?**
- **안전성**: 초기화되지 않은 포인터는 예측 불가능한 주소를 가질 수 있음
- **의미론**: NULL은 "연결되지 않음"을 명확히 표현
- **디버깅**: NULL 포인터 접근은 즉시 감지 가능한 오류

**메모리 레이아웃 시각화**:
```
메모리 주소    내용
0x1000    [data: 값] [next: NULL]
```

### 삽입 연산들

#### 맨 앞에 삽입

```c
void insertFront(LinkedList* list, int data) {
    if (list == NULL) return;

    Node* newNode = createNode(data);
    if (newNode == NULL) return;

    newNode->next = list->head;
    list->head = newNode;
    list->size++;
}
```

#### 앞쪽 삽입의 핵심 아이디어

**왜 맨 앞 삽입이 O(1)인가?**
연결 리스트에서 `head` 포인터는 항상 첫 번째 노드를 가리키므로, 새 노드를 앞에 추가하는 것은 **포인터 두 개만 조정**하면 됩니다.

**단계별 분석**:
1. **새 노드 생성**: `createNode(data)`로 독립된 노드 생성
2. **연결 설정**: `newNode->next = list->head` (기존 첫 노드와 연결)
3. **헤드 업데이트**: `list->head = newNode` (새 노드가 새로운 첫 노드)
4. **크기 증가**: `list->size++`

**시각적 과정**:
```
삽입 전: head -> [A] -> [B] -> NULL
삽입 후: head -> [새노드] -> [A] -> [B] -> NULL
```

**순서가 중요한 이유**: `newNode->next`를 먼저 설정해야 기존 리스트와의 연결이 끊어지지 않습니다.

#### 맨 뒤에 삽입

```c
void insertBack(LinkedList* list, int data) {
    if (list == NULL) return;

    Node* newNode = createNode(data);
    if (newNode == NULL) return;

    if (list->head == NULL) {
        list->head = newNode;
    } else {
        Node* current = list->head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = newNode;
    }
    list->size++;
}
```

#### 뒤쪽 삽입의 복잡성

**왜 맨 뒤 삽입이 O(n)인가?**
단일 연결 리스트는 **한 방향으로만 순회 가능**하므로, 마지막 노드를 찾기 위해 전체 리스트를 순회해야 합니다.

**두 가지 경우 처리**:
1. **빈 리스트**: `head == NULL`인 경우, 새 노드가 첫 번째이자 마지막 노드
2. **비어있지 않은 리스트**: 마지막 노드까지 순회 후 연결

**순회 과정의 핵심**:
```c
while (current->next != NULL) {
    current = current->next;
}
```
- **종료 조건**: `current->next == NULL` (마지막 노드 도달)
- **반복 불변조건**: `current`는 항상 유효한 노드를 가리킴

**시각적 과정**:
```
1. current = head -> [A] -> [B] -> [C] -> NULL
2. current = [A].next -> [B] -> [C] -> NULL
3. current = [B].next -> [C] -> NULL
4. [C].next == NULL이므로 종료, current는 마지막 노드
5. current->next = newNode로 연결
```

**최적화 가능성**: tail 포인터를 유지하면 O(1)로 개선 가능하지만, 메모리 오버헤드와 복잡성 증가

#### 특정 위치에 삽입

```c
void insertAt(LinkedList* list, int index, int data) {
    if (list == NULL || index < 0 || index > list->size) {
        printf("잘못된 인덱스입니다.\n");
        return;
    }

    if (index == 0) {
        insertFront(list, data);
        return;
    }

    Node* newNode = createNode(data);
    if (newNode == NULL) return;

    Node* current = list->head;
    for (int i = 0; i < index - 1; i++) {
        current = current->next;
    }

    newNode->next = current->next;
    current->next = newNode;
    list->size++;
}
```

### 삭제 연산들

#### 맨 앞 노드 삭제

```c
void deleteFront(LinkedList* list) {
    if (list == NULL || list->head == NULL) {
        printf("삭제할 노드가 없습니다.\n");
        return;
    }

    Node* temp = list->head;
    list->head = list->head->next;
    free(temp);
    list->size--;
}
```

#### 특정 값 삭제

```c
void deleteValue(LinkedList* list, int value) {
    if (list == NULL || list->head == NULL) {
        printf("삭제할 노드가 없습니다.\n");
        return;
    }

    // 첫 번째 노드가 삭제할 값인 경우
    if (list->head->data == value) {
        deleteFront(list);
        return;
    }

    Node* current = list->head;
    while (current->next != NULL && current->next->data != value) {
        current = current->next;
    }

    if (current->next != NULL) {
        Node* temp = current->next;
        current->next = current->next->next;
        free(temp);
        list->size--;
    } else {
        printf("값 %d를 찾을 수 없습니다.\n", value);
    }
}
```

### 탐색 연산들

#### 값으로 탐색

```c
int search(LinkedList* list, int value) {
    if (list == NULL || list->head == NULL) {
        return -1;
    }

    Node* current = list->head;
    int index = 0;

    while (current != NULL) {
        if (current->data == value) {
            return index;
        }
        current = current->next;
        index++;
    }

    return -1; // 찾지 못함
}
```

#### 인덱스로 접근

```c
int getAt(LinkedList* list, int index) {
    if (list == NULL || index < 0 || index >= list->size) {
        printf("잘못된 인덱스입니다.\n");
        return -1;
    }

    Node* current = list->head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }

    return current->data;
}
```

### 유틸리티 함수들

#### 리스트 출력

```c
void printList(LinkedList* list) {
    if (list == NULL || list->head == NULL) {
        printf("빈 리스트입니다.\n");
        return;
    }

    Node* current = list->head;
    printf("리스트: ");
    while (current != NULL) {
        printf("%d", current->data);
        if (current->next != NULL) {
            printf(" -> ");
        }
        current = current->next;
    }
    printf(" -> NULL\n");
}
```

#### 리스트 크기 반환

```c
int getSize(LinkedList* list) {
    return (list != NULL) ? list->size : 0;
}
```

#### 리스트가 비어있는지 확인

```c
int isEmpty(LinkedList* list) {
    return (list == NULL || list->head == NULL);
}
```

### 메모리 해제

```c
void destroyList(LinkedList* list) {
    if (list == NULL) return;

    Node* current = list->head;
    while (current != NULL) {
        Node* temp = current;
        current = current->next;
        free(temp);
    }

    free(list);
}
```

## 이중 연결 리스트 구현

### 이중 연결 리스트의 설계 철학

**단일 vs 이중 연결 리스트의 핵심 차이**:
- **양방향 탐색**: 앞뒤 모든 방향으로 이동 가능
- **tail 포인터**: 마지막 노드에 O(1) 접근
- **메모리 비용**: 노드당 포인터 2개 (prev, next)

**trade-off 분석**:
- **장점**: 역방향 탐색, 빠른 삭제, 양방향 삽입
- **단점**: 메모리 사용량 증가, 포인터 관리 복잡도 증가

### 구조 정의

```c
typedef struct DoublyNode {
    int data;
    struct DoublyNode* prev;
    struct DoublyNode* next;
} DoublyNode;

typedef struct DoublyLinkedList {
    DoublyNode* head;
    DoublyNode* tail;
    int size;
} DoublyLinkedList;
```

#### 이중 연결 리스트의 불변조건 (Invariants)

1. **양방향 일관성**: `node->next->prev == node` (NULL이 아닌 경우)
2. **경계 조건**:
   - `head->prev == NULL` (첫 번째 노드)
   - `tail->next == NULL` (마지막 노드)
3. **빈 리스트**: `head == NULL ⇔ tail == NULL`
4. **단일 노드**: `head == tail` (하나의 노드만 있는 경우)

### 기본 연산들

```c
DoublyLinkedList* createDoublyList() {
    DoublyLinkedList* list = (DoublyLinkedList*)malloc(sizeof(DoublyLinkedList));
    if (list == NULL) return NULL;

    list->head = NULL;
    list->tail = NULL;
    list->size = 0;
    return list;
}

DoublyNode* createDoublyNode(int data) {
    DoublyNode* newNode = (DoublyNode*)malloc(sizeof(DoublyNode));
    if (newNode == NULL) return NULL;

    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}

void insertDoublyFront(DoublyLinkedList* list, int data) {
    if (list == NULL) return;

    DoublyNode* newNode = createDoublyNode(data);
    if (newNode == NULL) return;

    if (list->head == NULL) {
        list->head = list->tail = newNode;
    } else {
        newNode->next = list->head;
        list->head->prev = newNode;
        list->head = newNode;
    }
    list->size++;
}

void insertDoublyBack(DoublyLinkedList* list, int data) {
    if (list == NULL) return;

    DoublyNode* newNode = createDoublyNode(data);
    if (newNode == NULL) return;

    if (list->tail == NULL) {
        list->head = list->tail = newNode;
    } else {
        newNode->prev = list->tail;
        list->tail->next = newNode;
        list->tail = newNode;
    }
    list->size++;
}
```

#### 이중 연결 리스트 삽입 연산 분석

**앞쪽 삽입의 경우 처리**:
1. **빈 리스트**: `head == NULL`이면 새 노드가 head이자 tail
2. **비어있지 않은 리스트**:
   - 새 노드와 기존 head 연결: `newNode->next = head`
   - 기존 head의 prev 설정: `head->prev = newNode`
   - head 업데이트: `head = newNode`

**포인터 설정 순서의 중요성**:
- 기존 연결을 끊기 전에 새로운 연결을 먼저 설정
- 양방향 연결을 모두 올바르게 설정해야 불변조건 유지

**시각적 과정 (앞쪽 삽입)**:
```
삽입 전: NULL <- [A] <-> [B] -> NULL
                  ↑              ↑
                head            tail

삽입 후: NULL <- [새] <-> [A] <-> [B] -> NULL
                  ↑                     ↑
                head                   tail
```

## 고급 알고리즘 구현

### 리스트 뒤집기

```c
void reverseList(LinkedList* list) {
    if (list == NULL || list->head == NULL) return;

    Node* prev = NULL;
    Node* current = list->head;
    Node* next = NULL;

    while (current != NULL) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }

    list->head = prev;
}
```

#### 리스트 뒤집기의 핵심 아이디어

**문제의 본질**: 각 노드의 `next` 포인터 방향을 역전시키는 것

**3-포인터 기법**:
- `prev`: 이전에 처리한 노드 (역전된 부분의 마지막)
- `current`: 현재 처리 중인 노드
- `next`: 다음에 처리할 노드 (연결이 끊어지기 전에 저장)

**단계별 과정**:
1. **백업**: `next = current->next` (연결 끊어지기 전에 저장)
2. **역전**: `current->next = prev` (포인터 방향 역전)
3. **전진**: `prev = current`, `current = next` (다음 단계로 이동)

**시각적 변화**:
```
원래:    NULL <- prev  current -> next -> ...
단계1:   NULL <- prev  current    next -> ...  (백업)
단계2:   NULL <- prev <- current   next -> ...  (역전)
단계3:   NULL <- ... <- prev      current -> ...  (전진)
```

**왜 3개의 포인터가 필요한가?**
- 연결을 끊기 전에 다음 노드를 저장해야 함
- 이전 노드와 현재 노드를 동시에 추적해야 함
- 단일 연결 리스트는 역방향 탐색이 불가능

### Floyd의 순환 검출 알고리즘

```c
int hasCycle(LinkedList* list) {
    if (list == NULL || list->head == NULL) return 0;

    Node* slow = list->head;
    Node* fast = list->head;

    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast) {
            return 1; // 순환 존재
        }
    }

    return 0; // 순환 없음
}
```

#### Floyd 알고리즘의 수학적 원리

**기본 아이디어**: 서로 다른 속도로 움직이는 두 포인터가 순환에서 만나는 현상

**수학적 증명**:
- 순환이 있다면, 빠른 포인터는 느린 포인터를 **반드시 따라잡음**
- 빠른 포인터가 한 번에 1노드씩 느린 포인터에 접근
- 순환 내에서는 유한한 공간이므로 **만남이 보장됨**

**시간 복잡도**: O(n) - 각 노드를 최대 상수 번 방문
**공간 복잡도**: O(1) - 포인터 2개만 사용

**실제 응용**:
- 메모리 누수 검출
- 무한 루프 방지
- 자료구조 검증

## 실제 사용 예제

```c
int main() {
    // 단일 연결 리스트 테스트
    LinkedList* list = createList();

    printf("=== 단일 연결 리스트 테스트 ===\n");

    // 데이터 삽입
    insertFront(list, 10);
    insertFront(list, 20);
    insertBack(list, 30);
    insertAt(list, 1, 15);

    printf("삽입 후: ");
    printList(list);
    printf("크기: %d\n", getSize(list));

    // 탐색
    int index = search(list, 15);
    printf("값 15의 인덱스: %d\n", index);

    // 삭제
    deleteValue(list, 20);
    printf("20 삭제 후: ");
    printList(list);

    // 메모리 해제
    destroyList(list);

    return 0;
}
```

## 고급 알고리즘 구현

### 리스트 뒤집기

```c
void reverseList(LinkedList* list) {
    if (list == NULL || list->head == NULL) return;

    Node* prev = NULL;
    Node* current = list->head;
    Node* next = NULL;

    while (current != NULL) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }

    list->head = prev;
}
```

### 두 정렬된 리스트 합병

```c
LinkedList* mergeSortedLists(LinkedList* list1, LinkedList* list2) {
    LinkedList* mergedList = createList();
    if (mergedList == NULL) return NULL;

    Node* ptr1 = list1->head;
    Node* ptr2 = list2->head;

    while (ptr1 != NULL && ptr2 != NULL) {
        if (ptr1->data <= ptr2->data) {
            insertBack(mergedList, ptr1->data);
            ptr1 = ptr1->next;
        } else {
            insertBack(mergedList, ptr2->data);
            ptr2 = ptr2->next;
        }
    }

    // 남은 노드들 추가
    while (ptr1 != NULL) {
        insertBack(mergedList, ptr1->data);
        ptr1 = ptr1->next;
    }

    while (ptr2 != NULL) {
        insertBack(mergedList, ptr2->data);
        ptr2 = ptr2->next;
    }

    return mergedList;
}
```

### Floyd의 순환 검출 알고리즘

```c
int hasCycle(LinkedList* list) {
    if (list == NULL || list->head == NULL) return 0;

    Node* slow = list->head;
    Node* fast = list->head;

    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast) {
            return 1; // 순환 존재
        }
    }

    return 0; // 순환 없음
}
```