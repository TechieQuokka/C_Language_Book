# 14.2 탐색 알고리즘 (Search Algorithms)

## 핵심 개념: 정보 탐지의 수학과 효율성의 철학

탐색은 **"광대한 정보 공간에서 특정 목표를 찾는 것"**의 알고리즘적 구현입니다. 이는 **정보 이론(Information Theory)**, **확률론(Probability Theory)**, **복잡도 이론(Complexity Theory)**이 만나는 지점이며, 동시에 **"찾기"**라는 가장 기본적인 계산 문제의 수학적 모델링입니다.

### 탐색의 수학적 기초: 결정 트리와 정보량

#### 결정 트리 모델
탐색 과정은 **결정 트리(Decision Tree)**로 모델링할 수 있습니다:
- **내부 노드**: 비교 연산
- **리프 노드**: 탐색 결과 (성공/실패)
- **경로**: 특정 입력에 대한 실행 과정

#### 정보 이론적 하한
**정리**: n개 원소에서 하나를 찾는 비교 기반 탐색의 최악 경우 비교 횟수는 Ω(log n)입니다.

**증명**:
- 가능한 결과: n+1가지 (n개 위치 + 1개 실패)
- k번 비교로 구별 가능한 경우: 2^k가지
- 모든 경우 구별하려면: 2^k ≥ n+1
- 따라서: k ≥ log₂(n+1) = Ω(log n)

**섀넌의 정보 이론**: 평균 정보량 H = -Σpᵢlog₂(pᵢ) ≥ log₂(n)

### 탐색 공간의 분류학

#### 구조적 분류
1. **선형 구조**: 배열, 연결 리스트
2. **계층 구조**: 트리, 힙
3. **해시 구조**: 해시 테이블
4. **그래프 구조**: 일반 그래프, 네트워크

#### 정보 활용도에 따른 분류
1. **무정보 탐색**: 목표에 대한 사전 정보 없음
2. **정보 기반 탐색**: 순서, 패턴 등의 추가 정보 활용
3. **휴리스틱 탐색**: 목표까지의 거리 추정 함수 활용

## 선형 탐색: 무차별 대입의 단순함

### 순차 탐색의 수학적 분석

#### 기본 순차 탐색
```c
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;  // 찾은 위치 반환
        }
    }
    return -1;  // 찾지 못함
}
```

#### 확률론적 분석
**가정**: 모든 원소가 찾는 확률이 동일 (1/n)

**평균 비교 횟수**:
- **성공 시**: (1 + 2 + ... + n)/n = (n+1)/2
- **실패 시**: n
- **전체 평균**: p×(n+1)/2 + (1-p)×n, 여기서 p는 성공 확률

**점근적 분석**:
- **최선**: O(1) - 첫 번째 원소가 목표
- **최악**: O(n) - 마지막 원소이거나 없음
- **평균**: O(n)

### 순차 탐색의 최적화

#### 보초(Sentinel) 기법
```c
int linearSearchSentinel(int arr[], int n, int target) {
    // 배열 끝에 보초값 설정 (원본 값 백업 필요)
    int last = arr[n-1];
    arr[n-1] = target;

    int i = 0;
    while (arr[i] != target) {
        i++;
    }

    // 원본 값 복원
    arr[n-1] = last;

    // 실제로 찾았는지 아니면 보초에 걸렸는지 확인
    if (i < n-1 || arr[n-1] == target) {
        return i;
    }

    return -1;
}
```

**최적화 효과**: 매 반복마다 경계 검사 제거 → 약 2배 성능 향상

#### 이진 이동(Binary Move-to-Front)
```c
typedef struct {
    int* data;
    int* frequency;
    int size;
} AdaptiveArray;

int adaptiveSearch(AdaptiveArray* arr, int target) {
    for (int i = 0; i < arr->size; i++) {
        if (arr->data[i] == target) {
            arr->frequency[i]++;

            // 빈도에 따라 앞으로 이동 (버블업)
            while (i > 0 && arr->frequency[i] > arr->frequency[i-1]) {
                // 데이터와 빈도 모두 교환
                swap(&arr->data[i], &arr->data[i-1]);
                swap(&arr->frequency[i], &arr->frequency[i-1]);
                i--;
            }

            return i;
        }
    }
    return -1;
}
```

**적응적 성능**: 자주 찾는 원소는 O(1)에 가까워짐

## 이진 탐색: 분할 정복의 우아함

### 이진 탐색의 수학적 기초

#### 전제 조건과 불변 조건
**전제 조건**: 배열이 정렬되어 있음
**불변 조건**: target이 존재한다면 [left, right] 구간에 있음

```c
int binarySearch(int arr[], int n, int target) {
    int left = 0;
    int right = n - 1;

    while (left <= right) {
        // 오버플로우 방지를 위한 중점 계산
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;  // 오른쪽 절반 탐색
        } else {
            right = mid - 1; // 왼쪽 절반 탐색
        }
    }

    return -1;  // 찾지 못함
}
```

#### 수렴성 분석
**루프 불변 조건**: target ∈ [left, right] ∪ {존재하지 않음}

**종료 조건**:
1. **성공**: arr[mid] == target
2. **실패**: left > right (탐색 공간 소진)

**수렴 속도**: 매 반복마다 탐색 공간이 절반으로 줄어듦
- 반복 횟수: ⌊log₂(n)⌋ + 1

### 이진 탐색의 변형

#### 하한 탐색 (Lower Bound)
```c
int lowerBound(int arr[], int n, int target) {
    int left = 0;
    int right = n;  // n+1 크기의 가상 배열

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;  // target 이상인 첫 번째 위치
}
```

**수학적 의미**: target ≤ x인 최소 인덱스 반환

#### 상한 탐색 (Upper Bound)
```c
int upperBound(int arr[], int n, int target) {
    int left = 0;
    int right = n;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;  // target 초과인 첫 번째 위치
}
```

**응용**: 중복 원소가 있는 배열에서 특정 값의 범위 찾기

#### 삼진 탐색 (Ternary Search)
```c
double ternarySearch(double left, double right, double epsilon,
                    double (*func)(double)) {
    while (right - left > epsilon) {
        double m1 = left + (right - left) / 3;
        double m2 = right - (right - left) / 3;

        if (func(m1) > func(m2)) {
            left = m1;
        } else {
            right = m2;
        }
    }

    return (left + right) / 2;
}
```

**적용 분야**: 단봉 함수(unimodal function)의 최댓값 탐색

### 이진 탐색의 일반화

#### 추상적 이진 탐색
```c
typedef bool (*Predicate)(int value, void* context);

int binarySearchGeneric(int left, int right, Predicate pred, void* context) {
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (pred(mid, context)) {
            result = mid;
            right = mid - 1;  // 더 작은 값 탐색
        } else {
            left = mid + 1;
        }
    }

    return result;
}

// 사용 예: 제곱근의 정수 부분 찾기
bool isSquareRootValid(int value, void* context) {
    int target = *(int*)context;
    return (long long)value * value <= target;
}

int integerSquareRoot(int n) {
    return binarySearchGeneric(0, n, isSquareRootValid, &n);
}
```

**추상화의 힘**: 단조성을 만족하는 모든 함수에 적용 가능

## 해시 기반 탐색: 직접 주소화의 마법

### 해시 테이블의 탐색 복잡도

#### 이론적 성능
```c
typedef struct HashEntry {
    int key;
    int value;
    bool occupied;
    bool deleted;
} HashEntry;

typedef struct HashTable {
    HashEntry* entries;
    int size;
    int capacity;
    double loadFactor;
} HashTable;

int hashSearch(HashTable* table, int key) {
    int hash = hashFunction(key) % table->capacity;
    int originalHash = hash;

    while (table->entries[hash].occupied) {
        if (!table->entries[hash].deleted &&
            table->entries[hash].key == key) {
            return hash;  // 찾음
        }

        hash = (hash + 1) % table->capacity;  // 선형 탐사

        // 전체 테이블을 다 봤으면 종료
        if (hash == originalHash) break;
    }

    return -1;  // 찾지 못함
}
```

#### 로드 팩터와 성능의 관계
**수학적 분석**:
- **성공 탐색**: E[성공] ≈ 1 + λ/2(1 - λ)
- **실패 탐색**: E[실패] ≈ 1 + λ²/2(1 - λ)
- 여기서 λ는 로드 팩터 (size/capacity)

**임계점**: λ ≈ 0.7에서 급격한 성능 저하 시작

### 완벽한 해시 함수

#### FKS 완벽 해싱
2단계 해싱으로 O(1) 최악 시간 보장:

```c
typedef struct PerfectHashTable {
    HashTable** secondaryTables;
    int* hashParams;  // (a, b) 매개변수 쌍들
    int primarySize;
    int universeSize;
} PerfectHashTable;

int perfectHashSearch(PerfectHashTable* pht, int key) {
    // 1차 해시 함수
    int primaryHash = universalHash(key, pht->hashParams[0],
                                   pht->hashParams[1], pht->primarySize);

    // 2차 테이블에서 탐색
    if (pht->secondaryTables[primaryHash] != NULL) {
        return hashSearch(pht->secondaryTables[primaryHash], key);
    }

    return -1;
}
```

**공간 복잡도**: O(n) - 2차 테이블들의 크기 합이 선형

#### 쿠쿠 해싱의 최악 시간 보장
```c
bool cuckooSearch(CuckooHashTable* table, int key, int* result) {
    // 첫 번째 테이블 확인
    int hash1 = hashFunction1(key) % table->size;
    if (table->table1[hash1].occupied && table->table1[hash1].key == key) {
        *result = hash1;
        return true;
    }

    // 두 번째 테이블 확인
    int hash2 = hashFunction2(key) % table->size;
    if (table->table2[hash2].occupied && table->table2[hash2].key == key) {
        *result = hash2 + table->size;  // 두 번째 테이블 오프셋
        return true;
    }

    return false;  // 최대 2번 메모리 접근으로 결과 확정
}
```

**보장**: 정확히 2번의 메모리 접근으로 탐색 완료

## 트리 기반 탐색: 계층적 효율성

### 이진 탐색 트리의 탐색

#### 기본 BST 탐색
```c
typedef struct TreeNode {
    int key;
    int value;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

TreeNode* bstSearch(TreeNode* root, int key) {
    if (root == NULL || root->key == key) {
        return root;
    }

    if (key < root->key) {
        return bstSearch(root->left, key);
    } else {
        return bstSearch(root->right, key);
    }
}
```

#### 반복적 구현 (스택 오버플로우 방지)
```c
TreeNode* bstSearchIterative(TreeNode* root, int key) {
    TreeNode* current = root;

    while (current != NULL && current->key != key) {
        if (key < current->key) {
            current = current->left;
        } else {
            current = current->right;
        }
    }

    return current;
}
```

**성능 분석**:
- **균형 트리**: O(log n)
- **편향 트리**: O(n)
- **평균**: O(log n) - 랜덤 삽입 순서 가정

### 자가 균형 트리의 탐색

#### AVL 트리의 보장된 성능
```c
int avlSearch(AVLNode* root, int key) {
    while (root != NULL) {
        if (key == root->key) {
            return root->value;
        } else if (key < root->key) {
            root = root->left;
        } else {
            root = root->right;
        }
    }

    return -1;  // 찾지 못함
}
```

**수학적 보장**: 높이 ≤ 1.44 log₂(n+2) - 1

#### B-트리의 대용량 데이터 탐색
```c
typedef struct BTreeNode {
    int* keys;
    void** values;
    struct BTreeNode** children;
    int numKeys;
    bool isLeaf;
} BTreeNode;

void* btreeSearch(BTreeNode* root, int key) {
    int i = 0;

    // 현재 노드에서 적절한 키 찾기
    while (i < root->numKeys && key > root->keys[i]) {
        i++;
    }

    // 키를 찾았으면 값 반환
    if (i < root->numKeys && key == root->keys[i]) {
        return root->values[i];
    }

    // 리프 노드인데 찾지 못했으면 실패
    if (root->isLeaf) {
        return NULL;
    }

    // 적절한 자식으로 재귀 탐색
    return btreeSearch(root->children[i], key);
}
```

**디스크 I/O 최적화**:
- 노드 크기 = 디스크 블록 크기
- 높이 = O(log_m n), m은 분기 인수

### 트라이 (Trie)의 문자열 탐색

#### 기본 트라이 구조
```c
#define ALPHABET_SIZE 26

typedef struct TrieNode {
    struct TrieNode* children[ALPHABET_SIZE];
    bool isEndOfWord;
    void* value;  // 단어의 값 (선택적)
} TrieNode;

bool trieSearch(TrieNode* root, const char* word) {
    TrieNode* current = root;

    for (int i = 0; word[i] != '\0'; i++) {
        int index = word[i] - 'a';

        if (current->children[index] == NULL) {
            return false;  // 경로가 존재하지 않음
        }

        current = current->children[index];
    }

    return current->isEndOfWord;
}
```

**시간 복잡도**: O(m), m은 단어 길이 - 사전 크기와 무관!

#### 압축 트라이 (Radix Tree)
```c
typedef struct RadixNode {
    char* edgeLabel;
    int edgeLength;
    struct RadixNode** children;
    int numChildren;
    bool isEndOfWord;
    void* value;
} RadixNode;

bool radixSearch(RadixNode* root, const char* word) {
    RadixNode* current = root;
    int wordIndex = 0;
    int wordLength = strlen(word);

    while (wordIndex < wordLength && current != NULL) {
        // 적절한 자식 찾기
        RadixNode* child = NULL;
        for (int i = 0; i < current->numChildren; i++) {
            if (current->children[i]->edgeLabel[0] == word[wordIndex]) {
                child = current->children[i];
                break;
            }
        }

        if (child == NULL) {
            return false;  // 매칭되는 경로 없음
        }

        // 엣지 라벨과 단어 부분 매칭 확인
        int matchLength = 0;
        while (matchLength < child->edgeLength &&
               wordIndex + matchLength < wordLength &&
               child->edgeLabel[matchLength] == word[wordIndex + matchLength]) {
            matchLength++;
        }

        if (matchLength < child->edgeLength) {
            return false;  // 부분 매칭 실패
        }

        wordIndex += matchLength;
        current = child;
    }

    return (wordIndex == wordLength) && current->isEndOfWord;
}
```

**공간 효율성**: 공통 접두사 압축으로 메모리 사용량 감소

## 근사 탐색과 유사성 검색

### 편집 거리 기반 근사 매칭

#### 레벤슈타인 거리 계산
```c
int editDistance(const char* str1, const char* str2) {
    int len1 = strlen(str1);
    int len2 = strlen(str2);

    // DP 테이블 생성
    int** dp = (int**)malloc((len1 + 1) * sizeof(int*));
    for (int i = 0; i <= len1; i++) {
        dp[i] = (int*)malloc((len2 + 1) * sizeof(int));
    }

    // 초기화
    for (int i = 0; i <= len1; i++) dp[i][0] = i;
    for (int j = 0; j <= len2; j++) dp[0][j] = j;

    // DP 계산
    for (int i = 1; i <= len1; i++) {
        for (int j = 1; j <= len2; j++) {
            if (str1[i-1] == str2[j-1]) {
                dp[i][j] = dp[i-1][j-1];  // 매칭
            } else {
                dp[i][j] = 1 + min3(
                    dp[i-1][j],     // 삭제
                    dp[i][j-1],     // 삽입
                    dp[i-1][j-1]    // 치환
                );
            }
        }
    }

    int result = dp[len1][len2];

    // 메모리 해제
    for (int i = 0; i <= len1; i++) {
        free(dp[i]);
    }
    free(dp);

    return result;
}
```

#### BK-Tree를 이용한 효율적 근사 탐색
```c
typedef struct BKTreeNode {
    char* word;
    struct BKTreeNode** children;
    int* distances;
    int numChildren;
} BKTreeNode;

void bkTreeSearch(BKTreeNode* root, const char* query, int tolerance,
                  char** results, int* numResults) {
    if (root == NULL) return;

    int distance = editDistance(root->word, query);

    if (distance <= tolerance) {
        results[(*numResults)++] = strdup(root->word);
    }

    // 삼각 부등식을 이용한 가지치기
    for (int i = 0; i < root->numChildren; i++) {
        if (abs(root->distances[i] - distance) <= tolerance) {
            bkTreeSearch(root->children[i], query, tolerance,
                        results, numResults);
        }
    }
}
```

**최적화 원리**: 삼각 부등식 |d(a,c) - d(b,c)| ≤ d(a,b)

### 지리적 탐색과 공간 분할

#### KD-트리를 이용한 최근접 이웃 탐색
```c
typedef struct KDTreeNode {
    double* point;
    int dimension;
    struct KDTreeNode* left;
    struct KDTreeNode* right;
} KDTreeNode;

KDTreeNode* nearestNeighbor(KDTreeNode* root, double* query,
                          int dimensions, KDTreeNode* best,
                          double* bestDistance) {
    if (root == NULL) return best;

    double distance = euclideanDistance(root->point, query, dimensions);

    if (best == NULL || distance < *bestDistance) {
        best = root;
        *bestDistance = distance;
    }

    int axis = root->dimension;
    double diff = query[axis] - root->point[axis];

    // 적절한 쪽부터 탐색
    KDTreeNode* nextBranch = (diff < 0) ? root->left : root->right;
    KDTreeNode* otherBranch = (diff < 0) ? root->right : root->left;

    best = nearestNeighbor(nextBranch, query, dimensions,
                          best, bestDistance);

    // 다른 쪽도 탐색할 가치가 있는지 확인
    if (fabs(diff) < *bestDistance) {
        best = nearestNeighbor(otherBranch, query, dimensions,
                              best, bestDistance);
    }

    return best;
}
```

**차원의 저주**: 고차원에서는 성능이 선형 탐색과 비슷해짐

## 확률적 탐색 알고리즘

### 블룸 필터: 확률적 집합 멤버십

#### 기본 블룸 필터 구현
```c
typedef struct BloomFilter {
    unsigned char* bitArray;
    int size;
    int numHashFunctions;
    int numElements;
} BloomFilter;

bool bloomSearch(BloomFilter* bf, const void* element, size_t elementSize) {
    for (int i = 0; i < bf->numHashFunctions; i++) {
        int hash = hashFunction(element, elementSize, i) % bf->size;
        int byteIndex = hash / 8;
        int bitIndex = hash % 8;

        if (!(bf->bitArray[byteIndex] & (1 << bitIndex))) {
            return false;  // 확실히 없음
        }
    }

    return true;  // 아마도 있음 (거짓 양성 가능)
}
```

#### 거짓 양성 확률 계산
**수학적 분석**:
- m: 비트 배열 크기
- n: 삽입된 원소 수
- k: 해시 함수 개수

**거짓 양성 확률**: P ≈ (1 - e^(-kn/m))^k

**최적 해시 함수 개수**: k = (m/n) × ln(2)

### 스킵 리스트: 확률적 균형

#### 스킵 리스트 탐색
```c
typedef struct SkipListNode {
    int key;
    void* value;
    struct SkipListNode** forward;
    int level;
} SkipListNode;

typedef struct SkipList {
    SkipListNode* header;
    int maxLevel;
    int currentLevel;
} SkipList;

SkipListNode* skipListSearch(SkipList* list, int key) {
    SkipListNode* current = list->header;

    // 위 레벨부터 아래로 탐색
    for (int level = list->currentLevel; level >= 0; level--) {
        while (current->forward[level] != NULL &&
               current->forward[level]->key < key) {
            current = current->forward[level];
        }
    }

    current = current->forward[0];

    if (current != NULL && current->key == key) {
        return current;
    }

    return NULL;
}
```

**확률적 분석**:
- 평균 시간 복잡도: O(log n)
- 공간 복잡도: O(n) 기댓값

## 병렬 탐색 알고리즘

### 병렬 이진 탐색

#### 분할 정복 병렬화
```c
#include <omp.h>

int parallelBinarySearch(int arr[], int n, int target, int numThreads) {
    int result = -1;

    #pragma omp parallel num_threads(numThreads)
    {
        int threadId = omp_get_thread_num();
        int threadsTotal = omp_get_num_threads();

        // 각 스레드가 담당할 구간 계산
        int chunkSize = n / threadsTotal;
        int start = threadId * chunkSize;
        int end = (threadId == threadsTotal - 1) ? n - 1 : start + chunkSize - 1;

        // 구간 내에서 이진 탐색
        int localResult = binarySearch(arr + start, end - start + 1, target);

        if (localResult != -1) {
            #pragma omp critical
            {
                if (result == -1) {  // 첫 번째 발견
                    result = start + localResult;
                }
            }
        }
    }

    return result;
}
```

**확장성 한계**: 검색 문제는 본질적으로 직렬적 특성이 강함

### GPU를 이용한 대용량 병렬 탐색

#### CUDA 커널을 이용한 병렬 선형 탐색
```c
__global__ void parallelLinearSearchKernel(int* data, int n, int target,
                                          int* result, int* found) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < n && data[idx] == target) {
        atomicExch(found, 1);
        atomicExch(result, idx);
    }
}

int gpuLinearSearch(int* hostData, int n, int target) {
    int* deviceData;
    int* deviceResult;
    int* deviceFound;

    // GPU 메모리 할당 및 데이터 복사
    cudaMalloc(&deviceData, n * sizeof(int));
    cudaMalloc(&deviceResult, sizeof(int));
    cudaMalloc(&deviceFound, sizeof(int));

    cudaMemcpy(deviceData, hostData, n * sizeof(int), cudaMemcpyHostToDevice);

    int initialValue = -1;
    cudaMemcpy(deviceResult, &initialValue, sizeof(int), cudaMemcpyHostToDevice);
    initialValue = 0;
    cudaMemcpy(deviceFound, &initialValue, sizeof(int), cudaMemcpyHostToDevice);

    // 커널 실행
    int blockSize = 256;
    int gridSize = (n + blockSize - 1) / blockSize;
    parallelLinearSearchKernel<<<gridSize, blockSize>>>(
        deviceData, n, target, deviceResult, deviceFound);

    // 결과 복사
    int result, found;
    cudaMemcpy(&result, deviceResult, sizeof(int), cudaMemcpyDeviceToHost);
    cudaMemcpy(&found, deviceFound, sizeof(int), cudaMemcpyDeviceToHost);

    // 메모리 해제
    cudaFree(deviceData);
    cudaFree(deviceResult);
    cudaFree(deviceFound);

    return found ? result : -1;
}
```

**성능 특성**: 매우 큰 n에서만 유의미한 성능 향상

## 탐색 알고리즘의 성능 비교

### 시간 복잡도 매트릭스

| 알고리즘 | 최선 | 평균 | 최악 | 공간 | 전제조건 |
|---------|------|------|------|------|----------|
| 선형 탐색 | O(1) | O(n) | O(n) | O(1) | 없음 |
| 이진 탐색 | O(1) | O(log n) | O(log n) | O(1) | 정렬됨 |
| 해시 탐색 | O(1) | O(1) | O(n) | O(n) | 좋은 해시 함수 |
| BST 탐색 | O(log n) | O(log n) | O(n) | O(n) | 균형 유지 |
| B-트리 탐색 | O(log n) | O(log n) | O(log n) | O(n) | 정렬됨 |
| 트라이 탐색 | O(m) | O(m) | O(m) | O(ALPHABET×n) | 문자열 |

### 실제 성능 고려사항

#### 캐시 효율성
- **선형 탐색**: 높은 캐시 지역성
- **이진 탐색**: 중간 수준의 지역성
- **해시 탐색**: 랜덤 접근으로 낮은 지역성
- **트리 탐색**: 포인터 추적으로 매우 낮은 지역성

#### 분기 예측
```c
// 분기 예측에 친화적인 버전
int binarySearchBranchless(int arr[], int n, int target) {
    int left = 0;
    int right = n;

    while (left < right) {
        int mid = (left + right) / 2;
        int cmp = (arr[mid] < target);
        left = cmp ? mid + 1 : left;
        right = cmp ? right : mid;
    }

    return (left < n && arr[left] == target) ? left : -1;
}
```

## 탐색 알고리즘의 선택 기준

### 데이터 특성에 따른 선택

#### 데이터 크기
- **n < 100**: 선형 탐색 (단순함의 이득)
- **100 ≤ n < 10,000**: 이진 탐색 (정렬된 경우)
- **n ≥ 10,000**: 해시 테이블 또는 인덱스 구조

#### 데이터 패턴
- **정적 데이터**: 정렬 후 이진 탐색
- **동적 데이터**: 해시 테이블 또는 자가 균형 트리
- **문자열 데이터**: 트라이 또는 접미사 배열
- **다차원 데이터**: KD-트리 또는 공간 해시

#### 성능 요구사항
- **최악 시간 보장**: B-트리, AVL 트리
- **평균 성능 최적화**: 해시 테이블, 스킵 리스트
- **메모리 제약**: 이진 탐색, 압축 트라이
- **실시간 시스템**: 완벽 해시, 정적 구조

## 마무리: 탐색의 철학적 의의

탐색 알고리즘은 **"찾기"**라는 가장 기본적인 계산 문제의 수학적 모델링입니다:

### 탐색의 수학적 아름다움
- **정보 이론적 한계**: 로그 복잡도의 근본적 이유
- **확률론적 보장**: 평균적 성능과 최악 성능의 트레이드오프
- **기하학적 직관**: 공간 분할과 계층적 구조의 활용

### 탐색의 공학적 지혜
- **구조의 활용**: 데이터 구조가 알고리즘 성능을 결정
- **전처리의 가치**: 정렬, 인덱싱 등의 사전 작업의 중요성
- **확률적 접근**: 평균적 성능을 위한 무작위화의 활용

**핵심 통찰**: 탐색은 **"정보의 조직화"**와 **"접근 패턴의 최적화"**입니다. 단순히 찾는 것이 아니라, 찾기 쉽게 구조화하고, 찾는 방법을 지능적으로 선택하는 것입니다.

**철학적 결론**: 최적의 탐색 알고리즘은 존재하지 않습니다. 데이터의 특성, 사용 패턴, 하드웨어 제약, 성능 요구사항이 모두 고려되어야 하는 **다차원 최적화 문제**입니다. 이는 공학에서 **"상황에 맞는 최선의 선택"**이라는 중요한 원칙을 보여주는 완벽한 사례입니다.