# 14.4 동적 프로그래밍 (Dynamic Programming)

## 1. 동적 프로그래밍의 이론적 기초

### 1.1 수학적 정의와 원리

동적 프로그래밍(Dynamic Programming)은 복잡한 문제를 작은 부분 문제들로 분해하여 해결하는 알고리즘 설계 기법입니다. 이는 두 가지 핵심 수학적 성질에 기반합니다:

**최적 부분 구조 (Optimal Substructure)**
```
∀ 문제 P에 대한 최적해 S가 있을 때,
S = opt(S₁, S₂, ..., Sₖ) ⟺ S₁, S₂, ..., Sₖ는 각각의 부분 문제에 대한 최적해
```

**중복 부분 문제 (Overlapping Subproblems)**
```
문제 P = {P₁, P₂, ..., Pₙ}일 때,
∃ Pᵢ, Pⱼ (i ≠ j) such that Pᵢ ∩ Pⱼ ≠ ∅
```

### 1.2 벨만 최적성 원리 (Bellman's Principle of Optimality)

리처드 벨만이 정의한 최적성 원리는 동적 프로그래밍의 수학적 기반을 제공합니다:

**정리**: 최적 정책의 어떤 부분도 그 자체로 최적 정책이어야 한다.

**수학적 표현**:
```
V*(s) = max{R(s,a) + γ∑ₛ' P(s'|s,a)V*(s')}
```

여기서:
- V*(s): 상태 s에서의 최적 가치 함수
- R(s,a): 상태 s에서 행동 a를 취할 때의 즉시 보상
- γ: 할인 인자 (0 ≤ γ ≤ 1)
- P(s'|s,a): 전이 확률

## 2. 메모화와 타불레이션

### 2.1 메모화 (Memoization) - Top-Down 접근

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 1000
#define UNDEFINED -1

// 메모화를 이용한 피보나치 수열
int memo[MAX_N];

void initMemo() {
    for (int i = 0; i < MAX_N; i++) {
        memo[i] = UNDEFINED;
    }
}

int fibonacciMemo(int n) {
    // 기저 조건
    if (n <= 1) return n;

    // 이미 계산된 값이 있는지 확인
    if (memo[n] != UNDEFINED) {
        return memo[n];
    }

    // 계산하고 메모에 저장
    memo[n] = fibonacciMemo(n-1) + fibonacciMemo(n-2);
    return memo[n];
}

// 성능 분석 함수
void analyzeMemoization(int n) {
    printf("=== 메모화 성능 분석 ===\n");
    printf("입력 크기: %d\n", n);
    printf("시간 복잡도: O(n)\n");
    printf("공간 복잡도: O(n)\n");
    printf("스택 깊이: O(n)\n");

    initMemo();
    int result = fibonacciMemo(n);
    printf("F(%d) = %d\n", n, result);
}
```

**메모화의 수학적 분석**:
- 시간 복잡도: T(n) = O(n) (각 부분 문제를 한 번만 계산)
- 공간 복잡도: S(n) = O(n) (메모 테이블 + 재귀 스택)
- 점화식: T(n) = T(n-1) + T(n-2) + O(1) → O(n) (메모화 적용 시)

### 2.2 타불레이션 (Tabulation) - Bottom-Up 접근

```c
// 타불레이션을 이용한 피보나치 수열
int fibonacciTabulation(int n) {
    if (n <= 1) return n;

    int dp[n + 1];
    dp[0] = 0;
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }

    return dp[n];
}

// 공간 최적화된 버전
int fibonacciOptimized(int n) {
    if (n <= 1) return n;

    int prev2 = 0, prev1 = 1, current;

    for (int i = 2; i <= n; i++) {
        current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }

    return current;
}

// 행렬 거듭제곱을 이용한 로그 시간 피보나치
void matrixMultiply(long long F[2][2], long long M[2][2]) {
    long long x = F[0][0] * M[0][0] + F[0][1] * M[1][0];
    long long y = F[0][0] * M[0][1] + F[0][1] * M[1][1];
    long long z = F[1][0] * M[0][0] + F[1][1] * M[1][0];
    long long w = F[1][0] * M[0][1] + F[1][1] * M[1][1];

    F[0][0] = x;
    F[0][1] = y;
    F[1][0] = z;
    F[1][1] = w;
}

void matrixPower(long long F[2][2], int n) {
    if (n == 0 || n == 1) return;

    long long M[2][2] = {{1, 1}, {1, 0}};

    matrixPower(F, n / 2);
    matrixMultiply(F, F);

    if (n % 2 != 0) {
        matrixMultiply(F, M);
    }
}

long long fibonacciMatrix(int n) {
    if (n == 0) return 0;

    long long F[2][2] = {{1, 1}, {1, 0}};
    matrixPower(F, n - 1);

    return F[0][0];
}
```

## 3. 클래식 동적 프로그래밍 문제들

### 3.1 최장 공통 부분 수열 (Longest Common Subsequence)

```c
#include <string.h>

// LCS 길이 계산
int lcsLength(char* X, char* Y, int m, int n) {
    int dp[m + 1][n + 1];

    // 기저 조건 초기화
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0 || j == 0) {
                dp[i][j] = 0;
            } else if (X[i-1] == Y[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = (dp[i-1][j] > dp[i][j-1]) ?
                           dp[i-1][j] : dp[i][j-1];
            }
        }
    }

    return dp[m][n];
}

// LCS 복원
void printLCS(char* X, char* Y, int m, int n) {
    int dp[m + 1][n + 1];

    // DP 테이블 채우기
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0 || j == 0) {
                dp[i][j] = 0;
            } else if (X[i-1] == Y[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = (dp[i-1][j] > dp[i][j-1]) ?
                           dp[i-1][j] : dp[i][j-1];
            }
        }
    }

    // LCS 복원
    int lcsLen = dp[m][n];
    char lcs[lcsLen + 1];
    lcs[lcsLen] = '\0';

    int i = m, j = n;
    while (i > 0 && j > 0) {
        if (X[i-1] == Y[j-1]) {
            lcs[lcsLen-1] = X[i-1];
            i--; j--; lcsLen--;
        } else if (dp[i-1][j] > dp[i][j-1]) {
            i--;
        } else {
            j--;
        }
    }

    printf("LCS: %s\n", lcs);
}

// 공간 최적화된 LCS
int lcsLengthOptimized(char* X, char* Y, int m, int n) {
    int prev[n + 1], curr[n + 1];

    // 기저 조건
    for (int j = 0; j <= n; j++) {
        prev[j] = 0;
    }

    for (int i = 1; i <= m; i++) {
        curr[0] = 0;
        for (int j = 1; j <= n; j++) {
            if (X[i-1] == Y[j-1]) {
                curr[j] = prev[j-1] + 1;
            } else {
                curr[j] = (prev[j] > curr[j-1]) ? prev[j] : curr[j-1];
            }
        }

        // 배열 교체
        for (int j = 0; j <= n; j++) {
            prev[j] = curr[j];
        }
    }

    return prev[n];
}
```

**LCS의 수학적 분석**:
- 점화식:
  ```
  LCS[i][j] = {
    0                           if i = 0 or j = 0
    LCS[i-1][j-1] + 1          if X[i] = Y[j]
    max(LCS[i-1][j], LCS[i][j-1])  otherwise
  }
  ```
- 시간 복잡도: O(mn)
- 공간 복잡도: O(mn) → O(min(m,n)) (최적화 시)

### 3.2 배낭 문제 (Knapsack Problem)

```c
typedef struct {
    int weight;
    int value;
    double ratio; // value/weight 비율
} Item;

// 0/1 배낭 문제
int knapsack01(Item items[], int n, int capacity) {
    int dp[n + 1][capacity + 1];

    // 기저 조건 초기화
    for (int i = 0; i <= n; i++) {
        for (int w = 0; w <= capacity; w++) {
            if (i == 0 || w == 0) {
                dp[i][w] = 0;
            } else if (items[i-1].weight <= w) {
                int include = items[i-1].value + dp[i-1][w - items[i-1].weight];
                int exclude = dp[i-1][w];
                dp[i][w] = (include > exclude) ? include : exclude;
            } else {
                dp[i][w] = dp[i-1][w];
            }
        }
    }

    return dp[n][capacity];
}

// 배낭 문제 해 복원
void printKnapsackSolution(Item items[], int n, int capacity) {
    int dp[n + 1][capacity + 1];

    // DP 테이블 채우기
    for (int i = 0; i <= n; i++) {
        for (int w = 0; w <= capacity; w++) {
            if (i == 0 || w == 0) {
                dp[i][w] = 0;
            } else if (items[i-1].weight <= w) {
                int include = items[i-1].value + dp[i-1][w - items[i-1].weight];
                int exclude = dp[i-1][w];
                dp[i][w] = (include > exclude) ? include : exclude;
            } else {
                dp[i][w] = dp[i-1][w];
            }
        }
    }

    // 해 복원
    printf("선택된 아이템들:\n");
    int w = capacity;
    for (int i = n; i > 0 && w > 0; i--) {
        if (dp[i][w] != dp[i-1][w]) {
            printf("아이템 %d (무게: %d, 가치: %d)\n",
                   i, items[i-1].weight, items[i-1].value);
            w -= items[i-1].weight;
        }
    }

    printf("최대 가치: %d\n", dp[n][capacity]);
}

// 공간 최적화된 0/1 배낭
int knapsack01Optimized(Item items[], int n, int capacity) {
    int dp[capacity + 1];

    // 초기화
    for (int w = 0; w <= capacity; w++) {
        dp[w] = 0;
    }

    for (int i = 0; i < n; i++) {
        // 역순으로 처리 (중복 사용 방지)
        for (int w = capacity; w >= items[i].weight; w--) {
            int include = items[i].value + dp[w - items[i].weight];
            if (include > dp[w]) {
                dp[w] = include;
            }
        }
    }

    return dp[capacity];
}

// 무한 배낭 문제 (Unbounded Knapsack)
int knapsackUnbounded(Item items[], int n, int capacity) {
    int dp[capacity + 1];

    // 초기화
    for (int w = 0; w <= capacity; w++) {
        dp[w] = 0;
    }

    for (int w = 1; w <= capacity; w++) {
        for (int i = 0; i < n; i++) {
            if (items[i].weight <= w) {
                int include = items[i].value + dp[w - items[i].weight];
                if (include > dp[w]) {
                    dp[w] = include;
                }
            }
        }
    }

    return dp[capacity];
}
```

**배낭 문제의 수학적 분석**:
- 점화식:
  ```
  K[i][w] = {
    0                                      if i = 0 or w = 0
    K[i-1][w]                             if wi > w
    max(K[i-1][w], vi + K[i-1][w-wi])     otherwise
  }
  ```
- 시간 복잡도: O(nW) (의사 다항시간)
- 공간 복잡도: O(nW) → O(W) (최적화 시)

### 3.3 편집 거리 (Edit Distance)

```c
#include <string.h>

// 레벤슈타인 거리 계산
int editDistance(char* str1, char* str2, int m, int n) {
    int dp[m + 1][n + 1];

    // 기저 조건
    for (int i = 0; i <= m; i++) {
        dp[i][0] = i; // 삭제 연산
    }
    for (int j = 0; j <= n; j++) {
        dp[0][j] = j; // 삽입 연산
    }

    // DP 테이블 채우기
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (str1[i-1] == str2[j-1]) {
                dp[i][j] = dp[i-1][j-1]; // 문자가 같으면 비용 없음
            } else {
                int insert = dp[i][j-1] + 1;      // 삽입
                int delete = dp[i-1][j] + 1;      // 삭제
                int replace = dp[i-1][j-1] + 1;   // 대체

                dp[i][j] = (insert < delete) ? insert : delete;
                dp[i][j] = (dp[i][j] < replace) ? dp[i][j] : replace;
            }
        }
    }

    return dp[m][n];
}

// 편집 연산 복원
void printEditOperations(char* str1, char* str2, int m, int n) {
    int dp[m + 1][n + 1];

    // DP 테이블 계산
    for (int i = 0; i <= m; i++) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= n; j++) {
        dp[0][j] = j;
    }

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (str1[i-1] == str2[j-1]) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                int insert = dp[i][j-1] + 1;
                int delete = dp[i-1][j] + 1;
                int replace = dp[i-1][j-1] + 1;

                dp[i][j] = (insert < delete) ? insert : delete;
                dp[i][j] = (dp[i][j] < replace) ? dp[i][j] : replace;
            }
        }
    }

    // 연산 역추적
    printf("편집 연산 순서:\n");
    int i = m, j = n;
    while (i > 0 || j > 0) {
        if (i > 0 && j > 0 && str1[i-1] == str2[j-1]) {
            printf("Match: %c\n", str1[i-1]);
            i--; j--;
        } else if (i > 0 && j > 0 && dp[i][j] == dp[i-1][j-1] + 1) {
            printf("Replace: %c -> %c\n", str1[i-1], str2[j-1]);
            i--; j--;
        } else if (i > 0 && dp[i][j] == dp[i-1][j] + 1) {
            printf("Delete: %c\n", str1[i-1]);
            i--;
        } else {
            printf("Insert: %c\n", str2[j-1]);
            j--;
        }
    }

    printf("총 편집 거리: %d\n", dp[m][n]);
}

// 가중치가 있는 편집 거리
int weightedEditDistance(char* str1, char* str2, int m, int n,
                        int insertCost, int deleteCost, int replaceCost) {
    int dp[m + 1][n + 1];

    // 기저 조건
    for (int i = 0; i <= m; i++) {
        dp[i][0] = i * deleteCost;
    }
    for (int j = 0; j <= n; j++) {
        dp[0][j] = j * insertCost;
    }

    // DP 테이블 채우기
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (str1[i-1] == str2[j-1]) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                int insert = dp[i][j-1] + insertCost;
                int delete = dp[i-1][j] + deleteCost;
                int replace = dp[i-1][j-1] + replaceCost;

                dp[i][j] = (insert < delete) ? insert : delete;
                dp[i][j] = (dp[i][j] < replace) ? dp[i][j] : replace;
            }
        }
    }

    return dp[m][n];
}
```

## 4. 고급 동적 프로그래밍 기법

### 4.1 구간 동적 프로그래밍 (Interval DP)

```c
// 행렬 체인 곱셈 최적화
int matrixChainOrder(int p[], int n) {
    int dp[n][n];

    // 기저 조건: 단일 행렬은 곱셈 비용이 0
    for (int i = 1; i < n; i++) {
        dp[i][i] = 0;
    }

    // l은 체인의 길이
    for (int l = 2; l < n; l++) {
        for (int i = 1; i < n - l + 1; i++) {
            int j = i + l - 1;
            dp[i][j] = INT_MAX;

            for (int k = i; k <= j - 1; k++) {
                int cost = dp[i][k] + dp[k+1][j] + p[i-1] * p[k] * p[j];
                if (cost < dp[i][j]) {
                    dp[i][j] = cost;
                }
            }
        }
    }

    return dp[1][n-1];
}

// 최적 괄호화 복원
void printOptimalParens(int s[][100], int i, int j) {
    if (i == j) {
        printf("M%d", i);
    } else {
        printf("(");
        printOptimalParens(s, i, s[i][j]);
        printOptimalParens(s, s[i][j] + 1, j);
        printf(")");
    }
}

int matrixChainOrderWithParens(int p[], int n) {
    int dp[n][n];
    int s[100][100]; // 분할점 저장

    for (int i = 1; i < n; i++) {
        dp[i][i] = 0;
    }

    for (int l = 2; l < n; l++) {
        for (int i = 1; i < n - l + 1; i++) {
            int j = i + l - 1;
            dp[i][j] = INT_MAX;

            for (int k = i; k <= j - 1; k++) {
                int cost = dp[i][k] + dp[k+1][j] + p[i-1] * p[k] * p[j];
                if (cost < dp[i][j]) {
                    dp[i][j] = cost;
                    s[i][j] = k;
                }
            }
        }
    }

    printf("최적 괄호화: ");
    printOptimalParens(s, 1, n-1);
    printf("\n");

    return dp[1][n-1];
}
```

### 4.2 확률적 동적 프로그래밍

```c
#include <math.h>

// 주식 매매 문제 (확률적 모델)
typedef struct {
    double probability;
    double return_rate;
} MarketState;

double optimalTradingStrategy(MarketState states[], int numStates,
                             int timeSteps, double initialWealth) {
    double dp[timeSteps + 1][numStates];

    // 기저 조건: 마지막 시점에서의 부
    for (int s = 0; s < numStates; s++) {
        dp[timeSteps][s] = initialWealth;
    }

    // 역방향 동적 프로그래밍
    for (int t = timeSteps - 1; t >= 0; t--) {
        for (int s = 0; s < numStates; s++) {
            double maxExpectedValue = 0.0;

            // 모든 가능한 투자 비율에 대해 탐색
            for (int investRatio = 0; investRatio <= 100; investRatio += 10) {
                double ratio = investRatio / 100.0;
                double expectedValue = 0.0;

                for (int nextState = 0; nextState < numStates; nextState++) {
                    double wealth = initialWealth * (1 + ratio * states[nextState].return_rate);
                    expectedValue += states[nextState].probability * dp[t+1][nextState];
                }

                if (expectedValue > maxExpectedValue) {
                    maxExpectedValue = expectedValue;
                }
            }

            dp[t][s] = maxExpectedValue;
        }
    }

    return dp[0][0];
}

// 베이지안 추론을 이용한 동적 프로그래밍
double bayesianDP(double prior[], double likelihood[][10],
                  int observations[], int numObs, int numStates) {
    double dp[numObs + 1][numStates];

    // 사전 확률로 초기화
    for (int s = 0; s < numStates; s++) {
        dp[0][s] = prior[s];
    }

    // 베이지안 업데이트
    for (int t = 1; t <= numObs; t++) {
        double total = 0.0;

        for (int s = 0; s < numStates; s++) {
            dp[t][s] = dp[t-1][s] * likelihood[s][observations[t-1]];
            total += dp[t][s];
        }

        // 정규화
        for (int s = 0; s < numStates; s++) {
            dp[t][s] /= total;
        }
    }

    // 최대 사후 확률 상태 반환
    double maxProb = 0.0;
    int maxState = 0;
    for (int s = 0; s < numStates; s++) {
        if (dp[numObs][s] > maxProb) {
            maxProb = dp[numObs][s];
            maxState = s;
        }
    }

    return maxState;
}
```

### 4.3 상태 압축 동적 프로그래밍

```c
// 외판원 문제 (TSP) - 비트마스크 DP
#define MAX_N 20
#define INF 1e9

int tsp(int graph[MAX_N][MAX_N], int n) {
    int dp[1 << n][n];

    // 초기화
    for (int mask = 0; mask < (1 << n); mask++) {
        for (int i = 0; i < n; i++) {
            dp[mask][i] = INF;
        }
    }

    // 시작점에서 출발
    dp[1][0] = 0; // 비트마스크 1 = 도시 0만 방문

    for (int mask = 0; mask < (1 << n); mask++) {
        for (int u = 0; u < n; u++) {
            if (!(mask & (1 << u))) continue; // u가 방문되지 않은 경우
            if (dp[mask][u] == INF) continue;

            for (int v = 0; v < n; v++) {
                if (mask & (1 << v)) continue; // v가 이미 방문된 경우
                if (graph[u][v] == INF) continue; // 경로가 없는 경우

                int newMask = mask | (1 << v);
                if (dp[newMask][v] > dp[mask][u] + graph[u][v]) {
                    dp[newMask][v] = dp[mask][u] + graph[u][v];
                }
            }
        }
    }

    // 모든 도시를 방문하고 시작점으로 돌아가는 최소 비용
    int result = INF;
    int finalMask = (1 << n) - 1;
    for (int i = 1; i < n; i++) {
        if (graph[i][0] != INF) {
            result = (result < dp[finalMask][i] + graph[i][0]) ?
                     result : dp[finalMask][i] + graph[i][0];
        }
    }

    return result;
}

// 부분집합 합 문제 (비트마스크 DP)
bool subsetSum(int arr[], int n, int target) {
    bool dp[1 << n];

    // 초기화
    for (int mask = 0; mask < (1 << n); mask++) {
        dp[mask] = false;
    }
    dp[0] = true; // 빈 집합의 합은 0

    for (int mask = 0; mask < (1 << n); mask++) {
        if (!dp[mask]) continue;

        int currentSum = 0;
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                currentSum += arr[i];
            }
        }

        if (currentSum == target) {
            return true;
        }

        for (int i = 0; i < n; i++) {
            if (!(mask & (1 << i))) { // i번째 원소가 포함되지 않은 경우
                int newMask = mask | (1 << i);
                dp[newMask] = true;
            }
        }
    }

    return false;
}
```

## 5. 최적화 기법과 고급 응용

### 5.1 순열 동적 프로그래밍

```c
// 해밀토니안 경로 개수 세기
long long countHamiltonianPaths(int graph[MAX_N][MAX_N], int n) {
    long long dp[1 << n][n];

    // 초기화
    for (int mask = 0; mask < (1 << n); mask++) {
        for (int i = 0; i < n; i++) {
            dp[mask][i] = 0;
        }
    }

    // 각 노드에서 시작하는 경로는 1개
    for (int i = 0; i < n; i++) {
        dp[1 << i][i] = 1;
    }

    for (int mask = 1; mask < (1 << n); mask++) {
        for (int u = 0; u < n; u++) {
            if (!(mask & (1 << u))) continue;
            if (dp[mask][u] == 0) continue;

            for (int v = 0; v < n; v++) {
                if (mask & (1 << v)) continue;
                if (!graph[u][v]) continue;

                dp[mask | (1 << v)][v] += dp[mask][u];
            }
        }
    }

    // 모든 노드를 방문하는 경로의 총 개수
    long long total = 0;
    int fullMask = (1 << n) - 1;
    for (int i = 0; i < n; i++) {
        total += dp[fullMask][i];
    }

    return total;
}

// 순열의 순환 구조 분석
int countCyclicPermutations(int n) {
    int dp[n + 1];
    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]);
    }

    return dp[n];
}
```

### 5.2 수치적 동적 프로그래밍

```c
#include <math.h>

// 이산화된 연속 최적 제어 문제
typedef struct {
    double state;
    double control;
    double cost;
} StateAction;

double continuousDP(double (*stateDynamics)(double, double),
                   double (*costFunction)(double, double),
                   double initialState, double finalTime,
                   int timeSteps, int stateDiscretization) {

    double dt = finalTime / timeSteps;
    double stateMin = -10.0, stateMax = 10.0;
    double ds = (stateMax - stateMin) / stateDiscretization;

    // DP 테이블
    double dp[timeSteps + 1][stateDiscretization + 1];

    // 종료 조건
    for (int s = 0; s <= stateDiscretization; s++) {
        double state = stateMin + s * ds;
        dp[timeSteps][s] = costFunction(state, 0.0); // 종료 비용
    }

    // 역방향 DP
    for (int t = timeSteps - 1; t >= 0; t--) {
        for (int s = 0; s <= stateDiscretization; s++) {
            double state = stateMin + s * ds;
            double minCost = INF;

            // 모든 가능한 제어 입력에 대해 최적화
            for (int u = -10; u <= 10; u++) {
                double control = u;
                double nextState = stateDynamics(state, control);

                // 다음 상태를 이산화
                int nextStateIndex = (int)round((nextState - stateMin) / ds);
                if (nextStateIndex < 0) nextStateIndex = 0;
                if (nextStateIndex > stateDiscretization) nextStateIndex = stateDiscretization;

                double cost = costFunction(state, control) * dt + dp[t+1][nextStateIndex];
                if (cost < minCost) {
                    minCost = cost;
                }
            }

            dp[t][s] = minCost;
        }
    }

    // 초기 상태에서의 최적 비용
    int initialStateIndex = (int)round((initialState - stateMin) / ds);
    return dp[0][initialStateIndex];
}

// 확률적 최적 제어 (가치 반복)
double valueIteration(double rewards[100][100], double transitions[100][100][100],
                     int numStates, int numActions, double gamma,
                     double epsilon, int maxIterations) {

    double V[numStates], newV[numStates];

    // 초기화
    for (int s = 0; s < numStates; s++) {
        V[s] = 0.0;
    }

    for (int iter = 0; iter < maxIterations; iter++) {
        double maxChange = 0.0;

        for (int s = 0; s < numStates; s++) {
            double maxValue = -INF;

            for (int a = 0; a < numActions; a++) {
                double expectedValue = 0.0;

                for (int nextS = 0; nextS < numStates; nextS++) {
                    expectedValue += transitions[s][a][nextS] *
                                   (rewards[s][a] + gamma * V[nextS]);
                }

                if (expectedValue > maxValue) {
                    maxValue = expectedValue;
                }
            }

            newV[s] = maxValue;
            double change = fabs(newV[s] - V[s]);
            if (change > maxChange) {
                maxChange = change;
            }
        }

        // 값 업데이트
        for (int s = 0; s < numStates; s++) {
            V[s] = newV[s];
        }

        // 수렴 검사
        if (maxChange < epsilon) {
            printf("수렴: %d 반복\n", iter + 1);
            break;
        }
    }

    return V[0]; // 초기 상태의 가치
}
```

## 6. 성능 분석과 복잡도 이론

### 6.1 동적 프로그래밍의 시간 복잡도 분석

```c
// 복잡도 분석 함수
void analyzeComplexity() {
    printf("=== 동적 프로그래밍 복잡도 분석 ===\n\n");

    printf("1. 피보나치 수열:\n");
    printf("   - 순진한 재귀: O(φⁿ) ≈ O(1.618ⁿ)\n");
    printf("   - 메모화/타불레이션: O(n)\n");
    printf("   - 행렬 거듭제곱: O(log n)\n\n");

    printf("2. LCS (길이 m, n):\n");
    printf("   - 시간 복잡도: O(mn)\n");
    printf("   - 공간 복잡도: O(mn) → O(min(m,n))\n\n");

    printf("3. 0/1 배낭 (n개 아이템, 용량 W):\n");
    printf("   - 시간 복잡도: O(nW) (의사 다항시간)\n");
    printf("   - 공간 복잡도: O(nW) → O(W)\n\n");

    printf("4. TSP (비트마스크 DP):\n");
    printf("   - 시간 복잡도: O(n²2ⁿ)\n");
    printf("   - 공간 복잡도: O(n2ⁿ)\n\n");

    printf("5. 행렬 체인 곱셈:\n");
    printf("   - 시간 복잡도: O(n³)\n");
    printf("   - 공간 복잡도: O(n²)\n\n");
}

// 실험적 성능 측정
void measurePerformance() {
    clock_t start, end;

    printf("=== 성능 측정 ===\n");

    // 피보나치 성능 비교
    int n = 40;

    start = clock();
    initMemo();
    int result1 = fibonacciMemo(n);
    end = clock();
    printf("메모화 피보나치(%d): %d, 시간: %f초\n",
           n, result1, ((double)(end - start)) / CLOCKS_PER_SEC);

    start = clock();
    int result2 = fibonacciTabulation(n);
    end = clock();
    printf("타불레이션 피보나치(%d): %d, 시간: %f초\n",
           n, result2, ((double)(end - start)) / CLOCKS_PER_SEC);

    start = clock();
    long long result3 = fibonacciMatrix(n);
    end = clock();
    printf("행렬 거듭제곱 피보나치(%d): %lld, 시간: %f초\n",
           n, result3, ((double)(end - start)) / CLOCKS_PER_SEC);
}
```

### 6.2 메모리 효율성 최적화

```c
// 슬라이딩 윈도우 기법
int lcsOptimalSpace(char* X, char* Y, int m, int n) {
    // 더 짧은 문자열을 열로 사용
    if (m < n) {
        return lcsOptimalSpace(Y, X, n, m);
    }

    int prev[n + 1], curr[n + 1];

    // 초기화
    for (int j = 0; j <= n; j++) {
        prev[j] = 0;
    }

    for (int i = 1; i <= m; i++) {
        curr[0] = 0;
        for (int j = 1; j <= n; j++) {
            if (X[i-1] == Y[j-1]) {
                curr[j] = prev[j-1] + 1;
            } else {
                curr[j] = (prev[j] > curr[j-1]) ? prev[j] : curr[j-1];
            }
        }

        // 배열 교체
        for (int j = 0; j <= n; j++) {
            prev[j] = curr[j];
        }
    }

    return prev[n];
}

// 압축된 상태 표현
typedef struct {
    unsigned int state : 20;  // 최대 2^20 = 1M 상태
    unsigned int value : 12;  // 최대 4095 값
} CompressedState;

// 해시 테이블을 이용한 상태 압축
#define HASH_SIZE 100007

typedef struct HashNode {
    unsigned int key;
    int value;
    struct HashNode* next;
} HashNode;

HashNode* hashTable[HASH_SIZE];

unsigned int hash(unsigned int key) {
    return key % HASH_SIZE;
}

void insertHash(unsigned int key, int value) {
    unsigned int index = hash(key);
    HashNode* newNode = malloc(sizeof(HashNode));
    newNode->key = key;
    newNode->value = value;
    newNode->next = hashTable[index];
    hashTable[index] = newNode;
}

int searchHash(unsigned int key) {
    unsigned int index = hash(key);
    HashNode* current = hashTable[index];

    while (current) {
        if (current->key == key) {
            return current->value;
        }
        current = current->next;
    }

    return -1; // 찾지 못함
}

void clearHash() {
    for (int i = 0; i < HASH_SIZE; i++) {
        HashNode* current = hashTable[i];
        while (current) {
            HashNode* next = current->next;
            free(current);
            current = next;
        }
        hashTable[i] = NULL;
    }
}
```

## 7. 실습 및 응용 예제

### 7.1 종합 예제: 최적 투자 포트폴리오

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef struct {
    char name[20];
    double expectedReturn;
    double risk;
    double correlation[10]; // 다른 자산과의 상관관계
} Asset;

typedef struct {
    double weight;
    double return;
    double risk;
} Portfolio;

// 포트폴리오 최적화 (동적 프로그래밍)
Portfolio optimizePortfolio(Asset assets[], int numAssets,
                          double targetReturn, int precision) {

    int maxWeight = 100; // 100% = 1.0을 100으로 스케일링
    Portfolio dp[maxWeight + 1];

    // 초기화
    for (int w = 0; w <= maxWeight; w++) {
        dp[w].return = 0.0;
        dp[w].risk = INF;
        dp[w].weight = 0.0;
    }
    dp[0].risk = 0.0;

    // 각 자산에 대해 동적 프로그래밍
    for (int i = 0; i < numAssets; i++) {
        for (int w = maxWeight; w >= 0; w--) {
            if (dp[w].risk == INF) continue;

            for (int allocation = 1; allocation <= maxWeight - w; allocation++) {
                int newWeight = w + allocation;
                double weight = allocation / 100.0;

                double newReturn = dp[w].return + weight * assets[i].expectedReturn;
                double newRisk = sqrt(dp[w].risk * dp[w].risk +
                                    weight * weight * assets[i].risk * assets[i].risk);

                if (newReturn >= targetReturn && newRisk < dp[newWeight].risk) {
                    dp[newWeight].return = newReturn;
                    dp[newWeight].risk = newRisk;
                    dp[newWeight].weight = newWeight / 100.0;
                }
            }
        }
    }

    // 최적 포트폴리오 찾기
    Portfolio optimal = {0.0, 0.0, INF};
    for (int w = 0; w <= maxWeight; w++) {
        if (dp[w].return >= targetReturn && dp[w].risk < optimal.risk) {
            optimal = dp[w];
        }
    }

    return optimal;
}

// 다단계 투자 결정
double multiStageInvestment(double initialCapital, double interestRate,
                          int timeHorizon, double volatility) {

    int numStates = 1000;
    double dp[timeHorizon + 1][numStates + 1];

    double minCapital = initialCapital * 0.1;
    double maxCapital = initialCapital * 10.0;
    double capitalStep = (maxCapital - minCapital) / numStates;

    // 종료 조건
    for (int s = 0; s <= numStates; s++) {
        double capital = minCapital + s * capitalStep;
        dp[timeHorizon][s] = capital; // 최종 자본이 목적 함수
    }

    // 역방향 동적 프로그래밍
    for (int t = timeHorizon - 1; t >= 0; t--) {
        for (int s = 0; s <= numStates; s++) {
            double capital = minCapital + s * capitalStep;
            double maxUtility = 0.0;

            // 투자 비율 결정 (0%부터 100%까지)
            for (int investRatio = 0; investRatio <= 100; investRatio += 5) {
                double ratio = investRatio / 100.0;
                double safeAmount = capital * (1 - ratio);
                double riskyAmount = capital * ratio;

                // 확률적 수익률 (정규분포 근사)
                double expectedCapital = safeAmount * (1 + interestRate) +
                                       riskyAmount * (1 + interestRate + 0.05);

                // 다음 상태 인덱스
                int nextState = (int)round((expectedCapital - minCapital) / capitalStep);
                if (nextState < 0) nextState = 0;
                if (nextState > numStates) nextState = numStates;

                double utility = log(expectedCapital) + dp[t+1][nextState];
                if (utility > maxUtility) {
                    maxUtility = utility;
                }
            }

            dp[t][s] = maxUtility;
        }
    }

    // 초기 상태에서의 최적 가치
    int initialState = (int)round((initialCapital - minCapital) / capitalStep);
    return exp(dp[0][initialState]);
}

// 메인 실행 함수
void runDynamicProgrammingDemo() {
    printf("=== 동적 프로그래밍 종합 예제 ===\n\n");

    // 1. 피보나치 성능 비교
    printf("1. 피보나치 수열 성능 비교\n");
    analyzeComplexity();
    measurePerformance();

    // 2. LCS 예제
    printf("\n2. 최장 공통 부분 수열\n");
    char str1[] = "ABCDGH";
    char str2[] = "AEDFHR";
    int lcsLen = lcsLength(str1, str2, strlen(str1), strlen(str2));
    printf("LCS 길이: %d\n", lcsLen);
    printLCS(str1, str2, strlen(str1), strlen(str2));

    // 3. 배낭 문제
    printf("\n3. 0/1 배낭 문제\n");
    Item items[] = {
        {10, 60, 6.0}, {20, 100, 5.0}, {30, 120, 4.0}
    };
    int capacity = 50;
    int maxValue = knapsack01(items, 3, capacity);
    printf("최대 가치: %d\n", maxValue);
    printKnapsackSolution(items, 3, capacity);

    // 4. 편집 거리
    printf("\n4. 편집 거리\n");
    char word1[] = "kitten";
    char word2[] = "sitting";
    int distance = editDistance(word1, word2, strlen(word1), strlen(word2));
    printf("편집 거리: %d\n", distance);
    printEditOperations(word1, word2, strlen(word1), strlen(word2));

    // 5. 투자 포트폴리오 최적화
    printf("\n5. 투자 포트폴리오 최적화\n");
    double optimalCapital = multiStageInvestment(10000.0, 0.03, 5, 0.2);
    printf("5년 후 최적 예상 자본: %.2f\n", optimalCapital);

    printf("\n=== 모든 예제 완료 ===\n");
}
```

### 7.2 성능 벤치마크와 최적화

```c
#include <time.h>

// 벤치마크 결과 구조체
typedef struct {
    char algorithm[50];
    double executionTime;
    int memoryUsage;
    int problemSize;
} BenchmarkResult;

// 벤치마크 실행
void runBenchmarks() {
    printf("=== 동적 프로그래밍 벤치마크 ===\n\n");

    BenchmarkResult results[10];
    int resultCount = 0;

    // 피보나치 벤치마크
    for (int n = 10; n <= 40; n += 10) {
        clock_t start = clock();
        initMemo();
        fibonacciMemo(n);
        clock_t end = clock();

        strcpy(results[resultCount].algorithm, "Fibonacci_Memo");
        results[resultCount].executionTime = ((double)(end - start)) / CLOCKS_PER_SEC;
        results[resultCount].memoryUsage = n * sizeof(int);
        results[resultCount].problemSize = n;
        resultCount++;
    }

    // LCS 벤치마크
    char testStr1[1000], testStr2[1000];
    for (int len = 100; len <= 500; len += 100) {
        // 랜덤 문자열 생성
        for (int i = 0; i < len; i++) {
            testStr1[i] = 'A' + (rand() % 26);
            testStr2[i] = 'A' + (rand() % 26);
        }
        testStr1[len] = testStr2[len] = '\0';

        clock_t start = clock();
        lcsLength(testStr1, testStr2, len, len);
        clock_t end = clock();

        strcpy(results[resultCount].algorithm, "LCS");
        results[resultCount].executionTime = ((double)(end - start)) / CLOCKS_PER_SEC;
        results[resultCount].memoryUsage = len * len * sizeof(int);
        results[resultCount].problemSize = len;
        resultCount++;
    }

    // 결과 출력
    printf("알고리즘\t\t문제 크기\t실행 시간(초)\t메모리(바이트)\n");
    printf("=========================================================\n");
    for (int i = 0; i < resultCount; i++) {
        printf("%-15s\t%d\t\t%.6f\t\t%d\n",
               results[i].algorithm,
               results[i].problemSize,
               results[i].executionTime,
               results[i].memoryUsage);
    }
}

// 메모리 프로파일링
void profileMemoryUsage() {
    printf("\n=== 메모리 사용량 프로파일링 ===\n");

    printf("1. 피보나치 (n=1000):\n");
    printf("   - 메모화: %lu 바이트\n", 1000 * sizeof(int));
    printf("   - 타불레이션: %lu 바이트\n", 1000 * sizeof(int));
    printf("   - 최적화: %lu 바이트\n", 3 * sizeof(int));

    printf("\n2. LCS (m=n=1000):\n");
    printf("   - 기본 DP: %lu 바이트\n", 1000 * 1000 * sizeof(int));
    printf("   - 공간 최적화: %lu 바이트\n", 2 * 1000 * sizeof(int));

    printf("\n3. 0/1 배낭 (n=100, W=1000):\n");
    printf("   - 기본 DP: %lu 바이트\n", 100 * 1000 * sizeof(int));
    printf("   - 공간 최적화: %lu 바이트\n", 1000 * sizeof(int));

    printf("\n4. TSP (n=20):\n");
    printf("   - 비트마스크 DP: %lu 바이트\n", (1 << 20) * 20 * sizeof(int));
    printf("   - 압축 상태: %lu 바이트 (해시 테이블 사용)\n", HASH_SIZE * sizeof(HashNode*));
}
```

## 8. 이론적 배경과 수학적 증명

### 8.1 최적성 증명

**정리 8.1 (동적 프로그래밍의 최적성)**
문제 P가 최적 부분 구조와 중복 부분 문제를 만족한다면, 동적 프로그래밍으로 구한 해는 최적해이다.

**증명**: 귀납법을 사용한다.
- 기저 조건: 가장 작은 부분 문제들에 대해 최적해가 올바르다.
- 귀납 가정: 크기 k 이하의 모든 부분 문제에 대해 DP가 최적해를 구한다고 가정.
- 귀납 단계: 크기 k+1인 문제 P에 대해, 최적 부분 구조에 의해 P의 최적해는 더 작은 부분 문제들의 최적해로 구성된다. 귀납 가정에 의해 이들은 DP로 올바르게 구해지므로, P의 최적해도 올바르게 구해진다. ∎

### 8.2 복잡도 하한

**정리 8.2 (정렬 기반 DP의 하한)**
비교 기반 동적 프로그래밍 문제의 시간 복잡도는 Ω(n log n)이다.

**증명**: 정보 이론적 논증을 사용한다. n개의 원소에 대한 n! 가지 순열을 구별하려면 log₂(n!) = Ω(n log n) 비트의 정보가 필요하다. 각 비교는 최대 1비트의 정보를 제공하므로, 적어도 Ω(n log n) 번의 비교가 필요하다. ∎

### 8.3 공간-시간 트레이드오프

**정리 8.3 (Savitch의 정리 응용)**
S(n) 공간을 사용하는 동적 프로그래밍 알고리즘은 O(S(n)²) 시간에 O(log S(n)) 공간으로 시뮬레이션할 수 있다.

이는 분할 정복과 메모화를 결합하여 달성할 수 있다.

## 9. 철학적 고찰과 설계 원칙

### 9.1 최적화의 철학

동적 프로그래밍은 "과거의 지혜를 기억하여 미래의 결정을 최적화한다"는 철학을 구현합니다. 이는 다음과 같은 깊은 의미를 가집니다:

**메모리와 시간의 교환**: 공간을 사용하여 시간을 절약하는 근본적인 컴퓨팅 원리를 체현합니다.

**분할 정복의 진화**: 단순한 분할이 아닌, 중복을 인식하고 활용하는 고급 패러다임입니다.

**최적성의 수학적 기반**: 벨만의 최적성 원리는 경제학, 제어 이론, 기계 학습 등 다양한 분야의 기반이 됩니다.

### 9.2 설계 지침

1. **부분 문제 식별**: 원래 문제를 어떻게 더 작은 문제들로 분해할 수 있는가?
2. **점화식 도출**: 부분 문제들 간의 관계를 수학적으로 표현하라.
3. **기저 조건 정의**: 재귀의 종료 조건을 명확히 하라.
4. **계산 순서 결정**: Top-down (메모화) vs Bottom-up (타불레이션)
5. **최적화 고려**: 공간 복잡도를 줄일 수 있는가?

동적 프로그래밍은 단순한 알고리즘 기법을 넘어서, 복잡한 최적화 문제를 해결하는 수학적이고 철학적인 접근법입니다. 이를 통해 우리는 계산의 효율성과 최적성을 동시에 추구할 수 있습니다.