# 14.3 그래프 알고리즘 (Graph Algorithms)

## 핵심 개념: 관계의 수학과 네트워크의 기하학

그래프는 **"관계와 연결"**을 수학적으로 모델링하는 가장 강력하고 일반적인 자료구조입니다. 이는 **그래프 이론(Graph Theory)**, **조합론(Combinatorics)**, **위상수학(Topology)**이 만나는 지점이며, 동시에 현실 세계의 복잡한 네트워크 현상을 추상화하는 핵심 도구입니다.

### 그래프의 수학적 기초: 이산 구조의 정수론

#### 그래프의 형식적 정의
**그래프 G = (V, E)**에서:
- **V**: 정점(Vertex) 집합, |V| = n
- **E**: 간선(Edge) 집합, |E| = m
- **관계**: E ⊆ V × V (방향 그래프) 또는 E ⊆ {{u,v} : u,v ∈ V} (무방향 그래프)

#### 그래프의 수학적 특성

**핸드셰이킹 정리**: Σ(v∈V) degree(v) = 2|E|
- **의미**: 모든 정점의 차수 합은 간선 수의 2배
- **증명**: 각 간선이 두 정점의 차수에 기여

**오일러의 공식** (평면 그래프): V - E + F = 2
- **V**: 정점 수, **E**: 간선 수, **F**: 면의 수

**쿠라토프스키 정리**: 그래프가 평면 그래프 ⟺ K₅, K₃,₃의 세분이 없음

### 그래프 표현의 계산 복잡도

#### 인접 행렬 (Adjacency Matrix)
```c
typedef struct GraphMatrix {
    int** adjMatrix;
    int numVertices;
    bool isDirected;
} GraphMatrix;

GraphMatrix* createGraphMatrix(int numVertices, bool isDirected) {
    GraphMatrix* graph = (GraphMatrix*)malloc(sizeof(GraphMatrix));
    graph->numVertices = numVertices;
    graph->isDirected = isDirected;

    // 2차원 배열 동적 할당
    graph->adjMatrix = (int**)malloc(numVertices * sizeof(int*));
    for (int i = 0; i < numVertices; i++) {
        graph->adjMatrix[i] = (int*)calloc(numVertices, sizeof(int));
    }

    return graph;
}

void addEdgeMatrix(GraphMatrix* graph, int src, int dest, int weight) {
    if (src < 0 || src >= graph->numVertices ||
        dest < 0 || dest >= graph->numVertices) {
        return;
    }

    graph->adjMatrix[src][dest] = weight;
    if (!graph->isDirected) {
        graph->adjMatrix[dest][src] = weight;
    }
}
```

**공간 복잡도**: O(V²)
**간선 존재 확인**: O(1)
**모든 인접 정점 순회**: O(V)

#### 인접 리스트 (Adjacency List)
```c
typedef struct EdgeNode {
    int destination;
    int weight;
    struct EdgeNode* next;
} EdgeNode;

typedef struct GraphList {
    EdgeNode** adjList;
    int numVertices;
    bool isDirected;
} GraphList;

GraphList* createGraphList(int numVertices, bool isDirected) {
    GraphList* graph = (GraphList*)malloc(sizeof(GraphList));
    graph->numVertices = numVertices;
    graph->isDirected = isDirected;

    graph->adjList = (EdgeNode**)calloc(numVertices, sizeof(EdgeNode*));
    return graph;
}

void addEdgeList(GraphList* graph, int src, int dest, int weight) {
    // 새 간선 노드 생성
    EdgeNode* newNode = (EdgeNode*)malloc(sizeof(EdgeNode));
    newNode->destination = dest;
    newNode->weight = weight;
    newNode->next = graph->adjList[src];
    graph->adjList[src] = newNode;

    // 무방향 그래프인 경우 반대 방향도 추가
    if (!graph->isDirected) {
        newNode = (EdgeNode*)malloc(sizeof(EdgeNode));
        newNode->destination = src;
        newNode->weight = weight;
        newNode->next = graph->adjList[dest];
        graph->adjList[dest] = newNode;
    }
}
```

**공간 복잡도**: O(V + E)
**간선 존재 확인**: O(degree(v))
**모든 인접 정점 순회**: O(degree(v))

#### 표현 방법의 선택 기준
- **밀집 그래프** (E ≈ V²): 인접 행렬
- **희소 그래프** (E << V²): 인접 리스트
- **빈번한 간선 존재 확인**: 인접 행렬
- **메모리 효율성**: 인접 리스트

## 그래프 탐색: 연결성의 발견

### 깊이 우선 탐색 (DFS): 스택의 재귀적 본질

#### 재귀적 DFS 구현
```c
void dfsRecursive(GraphList* graph, int vertex, bool* visited) {
    visited[vertex] = true;
    printf("%d ", vertex);

    EdgeNode* current = graph->adjList[vertex];
    while (current != NULL) {
        if (!visited[current->destination]) {
            dfsRecursive(graph, current->destination, visited);
        }
        current = current->next;
    }
}

void dfs(GraphList* graph, int startVertex) {
    bool* visited = (bool*)calloc(graph->numVertices, sizeof(bool));
    dfsRecursive(graph, startVertex, visited);
    free(visited);
}
```

#### 반복적 DFS 구현 (명시적 스택)
```c
void dfsIterative(GraphList* graph, int startVertex) {
    bool* visited = (bool*)calloc(graph->numVertices, sizeof(bool));
    int* stack = (int*)malloc(graph->numVertices * sizeof(int));
    int top = -1;

    stack[++top] = startVertex;

    while (top >= 0) {
        int vertex = stack[top--];

        if (!visited[vertex]) {
            visited[vertex] = true;
            printf("%d ", vertex);

            // 인접 정점들을 스택에 추가 (역순으로 추가하여 순서 맞춤)
            EdgeNode* current = graph->adjList[vertex];
            while (current != NULL) {
                if (!visited[current->destination]) {
                    stack[++top] = current->destination;
                }
                current = current->next;
            }
        }
    }

    free(visited);
    free(stack);
}
```

**시간 복잡도**: O(V + E)
**공간 복잡도**: O(V) - 재귀 스택 또는 명시적 스택

#### DFS의 수학적 특성
**DFS 트리**: DFS 과정에서 생성되는 신장 트리
- **트리 간선**: DFS 트리의 간선
- **후진 간선**: 조상으로 가는 간선
- **전진 간선**: 후손으로 가는 간선
- **교차 간선**: 형제 서브트리 간의 간선

### 너비 우선 탐색 (BFS): 큐의 레벨 순회

#### BFS 구현
```c
void bfs(GraphList* graph, int startVertex) {
    bool* visited = (bool*)calloc(graph->numVertices, sizeof(bool));
    int* queue = (int*)malloc(graph->numVertices * sizeof(int));
    int front = 0, rear = 0;

    visited[startVertex] = true;
    queue[rear++] = startVertex;

    while (front < rear) {
        int vertex = queue[front++];
        printf("%d ", vertex);

        EdgeNode* current = graph->adjList[vertex];
        while (current != NULL) {
            if (!visited[current->destination]) {
                visited[current->destination] = true;
                queue[rear++] = current->destination;
            }
            current = current->next;
        }
    }

    free(visited);
    free(queue);
}
```

#### BFS의 거리 계산
```c
int* bfsDistances(GraphList* graph, int startVertex) {
    int* distances = (int*)malloc(graph->numVertices * sizeof(int));
    bool* visited = (bool*)calloc(graph->numVertices, sizeof(bool));
    int* queue = (int*)malloc(graph->numVertices * sizeof(int));
    int front = 0, rear = 0;

    // 초기화
    for (int i = 0; i < graph->numVertices; i++) {
        distances[i] = -1;  // 무한대로 초기화
    }

    distances[startVertex] = 0;
    visited[startVertex] = true;
    queue[rear++] = startVertex;

    while (front < rear) {
        int vertex = queue[front++];

        EdgeNode* current = graph->adjList[vertex];
        while (current != NULL) {
            if (!visited[current->destination]) {
                visited[current->destination] = true;
                distances[current->destination] = distances[vertex] + 1;
                queue[rear++] = current->destination;
            }
            current = current->next;
        }
    }

    free(visited);
    free(queue);
    return distances;
}
```

**핵심 성질**: BFS는 무가중치 그래프에서 최단 거리를 보장합니다.

### 연결 요소와 강연결 요소

#### 연결 요소 찾기
```c
int findConnectedComponents(GraphList* graph, int* componentId) {
    bool* visited = (bool*)calloc(graph->numVertices, sizeof(bool));
    int numComponents = 0;

    for (int i = 0; i < graph->numVertices; i++) {
        if (!visited[i]) {
            // 새로운 연결 요소 발견
            dfsComponentMarking(graph, i, visited, componentId, numComponents);
            numComponents++;
        }
    }

    free(visited);
    return numComponents;
}

void dfsComponentMarking(GraphList* graph, int vertex, bool* visited,
                        int* componentId, int currentComponent) {
    visited[vertex] = true;
    componentId[vertex] = currentComponent;

    EdgeNode* current = graph->adjList[vertex];
    while (current != NULL) {
        if (!visited[current->destination]) {
            dfsComponentMarking(graph, current->destination, visited,
                               componentId, currentComponent);
        }
        current = current->next;
    }
}
```

#### 코사라주 알고리즘 (강연결 요소)
```c
void kosaraju(GraphList* graph, int** stronglyConnectedComponents,
              int* numSCC) {
    int* finishOrder = (int*)malloc(graph->numVertices * sizeof(int));
    bool* visited = (bool*)calloc(graph->numVertices, sizeof(bool));
    int finishIndex = 0;

    // 1단계: 원본 그래프에서 DFS 수행하여 완료 순서 기록
    for (int i = 0; i < graph->numVertices; i++) {
        if (!visited[i]) {
            dfsWithFinishTime(graph, i, visited, finishOrder, &finishIndex);
        }
    }

    // 2단계: 전치 그래프 생성
    GraphList* transposedGraph = createTransposedGraph(graph);

    // 3단계: 완료 순서의 역순으로 전치 그래프에서 DFS
    memset(visited, false, graph->numVertices * sizeof(bool));
    *numSCC = 0;

    for (int i = graph->numVertices - 1; i >= 0; i--) {
        int vertex = finishOrder[i];
        if (!visited[vertex]) {
            dfsComponentMarking(transposedGraph, vertex, visited,
                               stronglyConnectedComponents[*numSCC], *numSCC);
            (*numSCC)++;
        }
    }

    free(finishOrder);
    free(visited);
    // transposedGraph 메모리 해제...
}
```

**코사라주 알고리즘의 수학적 원리**:
1. **완료 시간**: DFS에서 정점의 탐색이 완료되는 시간
2. **전치 그래프**: 모든 간선의 방향을 뒤바꾼 그래프
3. **핵심 정리**: 강연결 요소들은 전치 그래프에서도 강연결 요소로 남음

## 최단 경로 알고리즘: 거리의 최적화

### 다익스트라 알고리즘: 욕심쟁이의 최적성

#### 기본 다익스트라 구현
```c
#define INF 999999

int* dijkstra(GraphList* graph, int source) {
    int* distances = (int*)malloc(graph->numVertices * sizeof(int));
    bool* visited = (bool*)calloc(graph->numVertices, sizeof(bool));
    int* previous = (int*)malloc(graph->numVertices * sizeof(int));

    // 초기화
    for (int i = 0; i < graph->numVertices; i++) {
        distances[i] = INF;
        previous[i] = -1;
    }
    distances[source] = 0;

    for (int count = 0; count < graph->numVertices; count++) {
        // 방문하지 않은 정점 중 최단 거리인 정점 선택
        int u = findMinDistance(distances, visited, graph->numVertices);
        if (u == -1) break;  // 더 이상 도달 가능한 정점 없음

        visited[u] = true;

        // u의 인접 정점들의 거리 업데이트
        EdgeNode* current = graph->adjList[u];
        while (current != NULL) {
            int v = current->destination;
            int weight = current->weight;

            if (!visited[v] && distances[u] != INF &&
                distances[u] + weight < distances[v]) {
                distances[v] = distances[u] + weight;
                previous[v] = u;
            }
            current = current->next;
        }
    }

    free(visited);
    free(previous);
    return distances;
}

int findMinDistance(int* distances, bool* visited, int numVertices) {
    int min = INF;
    int minIndex = -1;

    for (int v = 0; v < numVertices; v++) {
        if (!visited[v] && distances[v] < min) {
            min = distances[v];
            minIndex = v;
        }
    }

    return minIndex;
}
```

**시간 복잡도**: O(V²) - 인접 행렬 사용 시

#### 우선순위 큐를 이용한 최적화
```c
typedef struct PriorityQueueNode {
    int vertex;
    int distance;
} PQNode;

typedef struct PriorityQueue {
    PQNode* heap;
    int size;
    int capacity;
} PriorityQueue;

int* dijkstraOptimized(GraphList* graph, int source) {
    int* distances = (int*)malloc(graph->numVertices * sizeof(int));
    bool* inQueue = (bool*)calloc(graph->numVertices, sizeof(bool));
    PriorityQueue* pq = createPriorityQueue(graph->numVertices);

    // 초기화
    for (int i = 0; i < graph->numVertices; i++) {
        distances[i] = INF;
    }
    distances[source] = 0;

    enqueue(pq, source, 0);
    inQueue[source] = true;

    while (!isEmpty(pq)) {
        PQNode current = dequeue(pq);
        int u = current.vertex;
        inQueue[u] = false;

        // 중복 방문 검사 (같은 정점이 큐에 여러 번 들어갈 수 있음)
        if (current.distance > distances[u]) continue;

        EdgeNode* edge = graph->adjList[u];
        while (edge != NULL) {
            int v = edge->destination;
            int weight = edge->weight;

            if (distances[u] + weight < distances[v]) {
                distances[v] = distances[u] + weight;

                if (!inQueue[v]) {
                    enqueue(pq, v, distances[v]);
                    inQueue[v] = true;
                }
            }
            edge = edge->next;
        }
    }

    free(inQueue);
    destroyPriorityQueue(pq);
    return distances;
}
```

**시간 복잡도**: O((V + E) log V) - 이진 힙 사용 시

#### 다익스트라 알고리즘의 수학적 증명
**정리**: 다익스트라 알고리즘은 음이 아닌 가중치에서 최단 경로를 찾습니다.

**증명** (귀납법):
1. **기저**: 시작 정점까지의 거리는 0으로 정확
2. **귀납 가정**: 처리된 정점들까지의 거리는 모두 최단 거리
3. **귀납 단계**: 새로 선택된 정점 u까지의 거리도 최단 거리임을 증명
   - 반증: u까지 더 짧은 경로가 있다면, 그 경로의 첫 미처리 정점이 u보다 먼저 선택되었을 것

### 벨만-포드 알고리즘: 음수 가중치의 처리

#### 벨만-포드 구현
```c
bool bellmanFord(GraphList* graph, int source, int* distances) {
    // 초기화
    for (int i = 0; i < graph->numVertices; i++) {
        distances[i] = INF;
    }
    distances[source] = 0;

    // V-1번 반복하여 최단 거리 완화
    for (int i = 0; i < graph->numVertices - 1; i++) {
        for (int u = 0; u < graph->numVertices; u++) {
            if (distances[u] != INF) {
                EdgeNode* edge = graph->adjList[u];
                while (edge != NULL) {
                    int v = edge->destination;
                    int weight = edge->weight;

                    if (distances[u] + weight < distances[v]) {
                        distances[v] = distances[u] + weight;
                    }
                    edge = edge->next;
                }
            }
        }
    }

    // 음수 사이클 검출
    for (int u = 0; u < graph->numVertices; u++) {
        if (distances[u] != INF) {
            EdgeNode* edge = graph->adjList[u];
            while (edge != NULL) {
                int v = edge->destination;
                int weight = edge->weight;

                if (distances[u] + weight < distances[v]) {
                    return false;  // 음수 사이클 존재
                }
                edge = edge->next;
            }
        }
    }

    return true;  // 음수 사이클 없음
}
```

**시간 복잡도**: O(VE)
**핵심 아이디어**: V-1번 반복으로 모든 최단 경로 발견, V번째에서 변화가 있으면 음수 사이클

### 플로이드-워셜 알고리즘: 모든 쌍 최단 경로

#### 플로이드-워셜 구현
```c
void floydWarshall(int** graph, int numVertices, int** distances) {
    // 거리 행렬 초기화
    for (int i = 0; i < numVertices; i++) {
        for (int j = 0; j < numVertices; j++) {
            if (i == j) {
                distances[i][j] = 0;
            } else if (graph[i][j] != 0) {
                distances[i][j] = graph[i][j];
            } else {
                distances[i][j] = INF;
            }
        }
    }

    // 중간 정점 k를 거치는 경로 고려
    for (int k = 0; k < numVertices; k++) {
        for (int i = 0; i < numVertices; i++) {
            for (int j = 0; j < numVertices; j++) {
                if (distances[i][k] != INF && distances[k][j] != INF &&
                    distances[i][k] + distances[k][j] < distances[i][j]) {
                    distances[i][j] = distances[i][k] + distances[k][j];
                }
            }
        }
    }
}
```

**시간 복잡도**: O(V³)
**공간 복잡도**: O(V²)

**수학적 원리**: 동적 계획법
- **상태**: dist[i][j][k] = i에서 j로 가는 최단 거리 (정점 0~k-1만 경유)
- **점화식**: dist[i][j][k] = min(dist[i][j][k-1], dist[i][k][k-1] + dist[k][j][k-1])

## 최소 신장 트리: 연결의 최적화

### 크루스칼 알고리즘: 간선 중심의 욕심쟁이

#### 크루스칼 구현 (Union-Find 사용)
```c
typedef struct Edge {
    int src, dest, weight;
} Edge;

typedef struct UnionFind {
    int* parent;
    int* rank;
    int size;
} UnionFind;

UnionFind* createUnionFind(int n) {
    UnionFind* uf = (UnionFind*)malloc(sizeof(UnionFind));
    uf->parent = (int*)malloc(n * sizeof(int));
    uf->rank = (int*)calloc(n, sizeof(int));
    uf->size = n;

    for (int i = 0; i < n; i++) {
        uf->parent[i] = i;
    }

    return uf;
}

int find(UnionFind* uf, int x) {
    if (uf->parent[x] != x) {
        uf->parent[x] = find(uf, uf->parent[x]);  // 경로 압축
    }
    return uf->parent[x];
}

bool unionSets(UnionFind* uf, int x, int y) {
    int rootX = find(uf, x);
    int rootY = find(uf, y);

    if (rootX == rootY) return false;  // 이미 같은 집합

    // 랭크에 따른 합집합
    if (uf->rank[rootX] < uf->rank[rootY]) {
        uf->parent[rootX] = rootY;
    } else if (uf->rank[rootX] > uf->rank[rootY]) {
        uf->parent[rootY] = rootX;
    } else {
        uf->parent[rootY] = rootX;
        uf->rank[rootX]++;
    }

    return true;
}

Edge* kruskal(Edge* edges, int numEdges, int numVertices, int* mstWeight) {
    // 간선을 가중치 순으로 정렬
    qsort(edges, numEdges, sizeof(Edge), compareEdges);

    Edge* mst = (Edge*)malloc((numVertices - 1) * sizeof(Edge));
    UnionFind* uf = createUnionFind(numVertices);
    int mstEdges = 0;
    *mstWeight = 0;

    for (int i = 0; i < numEdges && mstEdges < numVertices - 1; i++) {
        Edge currentEdge = edges[i];

        // 사이클을 형성하지 않으면 MST에 추가
        if (unionSets(uf, currentEdge.src, currentEdge.dest)) {
            mst[mstEdges++] = currentEdge;
            *mstWeight += currentEdge.weight;
        }
    }

    destroyUnionFind(uf);
    return mst;
}

int compareEdges(const void* a, const void* b) {
    Edge* edgeA = (Edge*)a;
    Edge* edgeB = (Edge*)b;
    return edgeA->weight - edgeB->weight;
}
```

**시간 복잡도**: O(E log E) - 정렬이 지배적

### 프림 알고리즘: 정점 중심의 성장

#### 프림 구현
```c
Edge* prim(GraphList* graph, int* mstWeight) {
    bool* inMST = (bool*)calloc(graph->numVertices, sizeof(bool));
    int* key = (int*)malloc(graph->numVertices * sizeof(int));
    int* parent = (int*)malloc(graph->numVertices * sizeof(int));
    Edge* mst = (Edge*)malloc((graph->numVertices - 1) * sizeof(Edge));

    // 초기화
    for (int i = 0; i < graph->numVertices; i++) {
        key[i] = INF;
        parent[i] = -1;
    }
    key[0] = 0;  // 시작 정점

    *mstWeight = 0;
    int mstEdges = 0;

    for (int count = 0; count < graph->numVertices; count++) {
        // MST에 포함되지 않은 정점 중 최소 키 값을 가진 정점 선택
        int u = findMinKey(key, inMST, graph->numVertices);
        inMST[u] = true;

        // MST 간선 추가 (첫 정점 제외)
        if (parent[u] != -1) {
            Edge edge = {parent[u], u, key[u]};
            mst[mstEdges++] = edge;
            *mstWeight += key[u];
        }

        // u의 인접 정점들의 키 값 업데이트
        EdgeNode* current = graph->adjList[u];
        while (current != NULL) {
            int v = current->destination;
            int weight = current->weight;

            if (!inMST[v] && weight < key[v]) {
                parent[v] = u;
                key[v] = weight;
            }
            current = current->next;
        }
    }

    free(inMST);
    free(key);
    free(parent);
    return mst;
}

int findMinKey(int* key, bool* inMST, int numVertices) {
    int min = INF;
    int minIndex = -1;

    for (int v = 0; v < numVertices; v++) {
        if (!inMST[v] && key[v] < min) {
            min = key[v];
            minIndex = v;
        }
    }

    return minIndex;
}
```

**시간 복잡도**: O(V²) - 인접 행렬 사용 시, O((V + E) log V) - 우선순위 큐 사용 시

### MST 알고리즘의 정당성 증명

#### 컷 성질 (Cut Property)
**정리**: 그래프의 임의의 컷에서 최소 가중치 간선은 어떤 MST에 포함됩니다.

**증명**: 반증법
1. 최소 간선 e가 어떤 MST T에도 포함되지 않는다고 가정
2. T에 e를 추가하면 사이클 형성
3. 이 사이클에는 컷을 가로지르는 다른 간선 f가 존재
4. e를 추가하고 f를 제거하면 더 작은 가중치의 신장 트리 생성 → 모순

#### 사이클 성질 (Cycle Property)
**정리**: 그래프의 임의의 사이클에서 최대 가중치 간선은 어떤 MST에도 포함되지 않습니다.

## 네트워크 플로우: 유량의 최적화

### 포드-풀커슨 알고리즘: 증가 경로의 발견

#### 최대 플로우 구현
```c
typedef struct FlowNetwork {
    int** capacity;    // 용량 행렬
    int** flow;        // 현재 플로우
    int numVertices;
} FlowNetwork;

int maxFlow(FlowNetwork* network, int source, int sink) {
    int totalFlow = 0;
    int* parent = (int*)malloc(network->numVertices * sizeof(int));

    // 증가 경로가 존재하는 동안 반복
    while (bfsForFlow(network, source, sink, parent)) {
        // 증가 경로에서 최소 잔여 용량 찾기
        int pathFlow = INF;
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            int residual = network->capacity[u][v] - network->flow[u][v];
            pathFlow = min(pathFlow, residual);
        }

        // 증가 경로를 따라 플로우 업데이트
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            network->flow[u][v] += pathFlow;
            network->flow[v][u] -= pathFlow;  // 역방향 플로우
        }

        totalFlow += pathFlow;
    }

    free(parent);
    return totalFlow;
}

bool bfsForFlow(FlowNetwork* network, int source, int sink, int* parent) {
    bool* visited = (bool*)calloc(network->numVertices, sizeof(bool));
    int* queue = (int*)malloc(network->numVertices * sizeof(int));
    int front = 0, rear = 0;

    visited[source] = true;
    queue[rear++] = source;
    parent[source] = -1;

    while (front < rear) {
        int u = queue[front++];

        for (int v = 0; v < network->numVertices; v++) {
            // 방문하지 않았고 잔여 용량이 있는 경우
            if (!visited[v] &&
                network->capacity[u][v] - network->flow[u][v] > 0) {
                visited[v] = true;
                parent[v] = u;
                queue[rear++] = v;

                if (v == sink) {
                    free(visited);
                    free(queue);
                    return true;  // 싱크에 도달
                }
            }
        }
    }

    free(visited);
    free(queue);
    return false;  // 증가 경로 없음
}
```

**시간 복잡도**: O(E × f*), 여기서 f*는 최대 플로우 값

#### 최대 플로우 - 최소 컷 정리
**정리**: 네트워크에서 최대 플로우의 값은 최소 컷의 용량과 같습니다.

**증명 개요**:
1. 최대 플로우 ≤ 최소 컷 (임의의 컷은 플로우의 상한)
2. 포드-풀커슨 알고리즘 종료 시, 도달 가능한 정점들로 최소 컷 구성
3. 이 컷의 용량 = 최대 플로우

### 에드몬드-카프 알고리즘: BFS를 이용한 최적화

#### 에드몬드-카프 구현
```c
int edmondKarp(FlowNetwork* network, int source, int sink) {
    int totalFlow = 0;
    int* parent = (int*)malloc(network->numVertices * sizeof(int));

    // BFS로 최단 증가 경로 찾기
    while (bfsShortestPath(network, source, sink, parent)) {
        int pathFlow = INF;

        // 경로에서 최소 잔여 용량 찾기
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            int residual = network->capacity[u][v] - network->flow[u][v];
            pathFlow = min(pathFlow, residual);
        }

        // 플로우 업데이트
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            network->flow[u][v] += pathFlow;
            network->flow[v][u] -= pathFlow;
        }

        totalFlow += pathFlow;
    }

    free(parent);
    return totalFlow;
}
```

**시간 복잡도**: O(VE²) - BFS로 최단 경로 보장

### 이분 매칭: 네트워크 플로우의 응용

#### 이분 그래프 최대 매칭
```c
typedef struct BipartiteGraph {
    bool** adjMatrix;
    int leftSize;
    int rightSize;
} BipartiteGraph;

int maxBipartiteMatching(BipartiteGraph* graph) {
    int* match = (int*)malloc(graph->rightSize * sizeof(int));
    for (int i = 0; i < graph->rightSize; i++) {
        match[i] = -1;
    }

    int matchingSize = 0;

    // 각 왼쪽 정점에 대해 증가 경로 찾기
    for (int u = 0; u < graph->leftSize; u++) {
        bool* visited = (bool*)calloc(graph->rightSize, sizeof(bool));

        if (dfsMatching(graph, u, match, visited)) {
            matchingSize++;
        }

        free(visited);
    }

    free(match);
    return matchingSize;
}

bool dfsMatching(BipartiteGraph* graph, int u, int* match, bool* visited) {
    for (int v = 0; v < graph->rightSize; v++) {
        if (graph->adjMatrix[u][v] && !visited[v]) {
            visited[v] = true;

            // v가 매칭되지 않았거나, v의 매칭을 다른 곳으로 옮길 수 있으면
            if (match[v] == -1 ||
                dfsMatching(graph, match[v], match, visited)) {
                match[v] = u;
                return true;
            }
        }
    }

    return false;
}
```

**쾨니그의 정리**: 이분 그래프에서 최대 매칭의 크기 = 최소 정점 커버의 크기

## 위상 정렬: 순서의 수학

### 칸의 알고리즘: 진입 차수 기반

#### 위상 정렬 구현
```c
int* topologicalSort(GraphList* graph, bool* hasCycle) {
    int* inDegree = (int*)calloc(graph->numVertices, sizeof(int));
    int* result = (int*)malloc(graph->numVertices * sizeof(int));
    int* queue = (int*)malloc(graph->numVertices * sizeof(int));
    int front = 0, rear = 0;

    // 모든 정점의 진입 차수 계산
    for (int u = 0; u < graph->numVertices; u++) {
        EdgeNode* current = graph->adjList[u];
        while (current != NULL) {
            inDegree[current->destination]++;
            current = current->next;
        }
    }

    // 진입 차수가 0인 정점들을 큐에 추가
    for (int i = 0; i < graph->numVertices; i++) {
        if (inDegree[i] == 0) {
            queue[rear++] = i;
        }
    }

    int processedVertices = 0;

    while (front < rear) {
        int u = queue[front++];
        result[processedVertices++] = u;

        // u의 인접 정점들의 진입 차수 감소
        EdgeNode* current = graph->adjList[u];
        while (current != NULL) {
            int v = current->destination;
            inDegree[v]--;

            if (inDegree[v] == 0) {
                queue[rear++] = v;
            }
            current = current->next;
        }
    }

    *hasCycle = (processedVertices != graph->numVertices);

    free(inDegree);
    free(queue);
    return result;
}
```

**시간 복잡도**: O(V + E)

### DFS 기반 위상 정렬

#### DFS 위상 정렬 구현
```c
void topologicalSortDFS(GraphList* graph, int* result, int* index) {
    bool* visited = (bool*)calloc(graph->numVertices, sizeof(bool));
    bool* recursionStack = (bool*)calloc(graph->numVertices, sizeof(bool));

    *index = graph->numVertices - 1;

    for (int i = 0; i < graph->numVertices; i++) {
        if (!visited[i]) {
            if (!dfsTopological(graph, i, visited, recursionStack,
                               result, index)) {
                // 사이클 발견
                free(visited);
                free(recursionStack);
                return;
            }
        }
    }

    free(visited);
    free(recursionStack);
}

bool dfsTopological(GraphList* graph, int vertex, bool* visited,
                   bool* recursionStack, int* result, int* index) {
    visited[vertex] = true;
    recursionStack[vertex] = true;

    EdgeNode* current = graph->adjList[vertex];
    while (current != NULL) {
        int dest = current->destination;

        if (recursionStack[dest]) {
            return false;  // 사이클 발견
        }

        if (!visited[dest] &&
            !dfsTopological(graph, dest, visited, recursionStack,
                           result, index)) {
            return false;
        }

        current = current->next;
    }

    recursionStack[vertex] = false;
    result[(*index)--] = vertex;  // 완료 시간 역순으로 저장
    return true;
}
```

**핵심 아이디어**: DFS 완료 시간의 역순이 위상 순서

## 그래프 알고리즘의 응용

### 단절점과 단절선

#### 타잔의 알고리즘 (단절점)
```c
void findArticulationPoints(GraphList* graph) {
    bool* visited = (bool*)calloc(graph->numVertices, sizeof(bool));
    int* discovery = (int*)malloc(graph->numVertices * sizeof(int));
    int* low = (int*)malloc(graph->numVertices * sizeof(int));
    int* parent = (int*)malloc(graph->numVertices * sizeof(int));
    bool* articulationPoint = (bool*)calloc(graph->numVertices, sizeof(bool));

    for (int i = 0; i < graph->numVertices; i++) {
        parent[i] = -1;
    }

    int time = 0;

    for (int i = 0; i < graph->numVertices; i++) {
        if (!visited[i]) {
            articulationPointDFS(graph, i, visited, discovery, low,
                                parent, articulationPoint, &time);
        }
    }

    printf("단절점들: ");
    for (int i = 0; i < graph->numVertices; i++) {
        if (articulationPoint[i]) {
            printf("%d ", i);
        }
    }
    printf("\n");

    free(visited);
    free(discovery);
    free(low);
    free(parent);
    free(articulationPoint);
}

void articulationPointDFS(GraphList* graph, int u, bool* visited,
                         int* discovery, int* low, int* parent,
                         bool* articulationPoint, int* time) {
    int children = 0;
    visited[u] = true;

    discovery[u] = low[u] = ++(*time);

    EdgeNode* current = graph->adjList[u];
    while (current != NULL) {
        int v = current->destination;

        if (!visited[v]) {
            children++;
            parent[v] = u;

            articulationPointDFS(graph, v, visited, discovery, low,
                               parent, articulationPoint, time);

            low[u] = min(low[u], low[v]);

            // 단절점 조건 확인
            if (parent[u] == -1 && children > 1) {
                articulationPoint[u] = true;  // 루트이고 자식이 2개 이상
            }

            if (parent[u] != -1 && low[v] >= discovery[u]) {
                articulationPoint[u] = true;  // 일반 정점
            }
        } else if (v != parent[u]) {
            low[u] = min(low[u], discovery[v]);  // 후진 간선
        }

        current = current->next;
    }
}
```

**핵심 개념**:
- **discovery[u]**: 정점 u의 발견 시간
- **low[u]**: u에서 DFS 트리의 후진 간선으로 도달할 수 있는 가장 작은 발견 시간

### 강연결 요소의 응용

#### 2-SAT 문제 해결
```c
typedef struct TwoSAT {
    GraphList* implicationGraph;
    int numVariables;
} TwoSAT;

bool solveTwoSAT(TwoSAT* twoSAT, bool* assignment) {
    // 강연결 요소 찾기
    int* sccId = (int*)malloc(2 * twoSAT->numVariables * sizeof(int));
    int numSCC = findStronglyConnectedComponents(
        twoSAT->implicationGraph, sccId);

    // 각 변수 x와 ¬x가 같은 SCC에 있는지 확인
    for (int i = 0; i < twoSAT->numVariables; i++) {
        if (sccId[2*i] == sccId[2*i + 1]) {
            free(sccId);
            return false;  // 해가 없음
        }
    }

    // SCC 위상 순서에 따라 값 할당
    for (int i = 0; i < twoSAT->numVariables; i++) {
        assignment[i] = sccId[2*i] > sccId[2*i + 1];
    }

    free(sccId);
    return true;
}
```

## 마무리: 그래프 알고리즘의 철학적 의의

그래프 알고리즘은 **"관계와 구조"**를 다루는 컴퓨터 과학의 핵심입니다:

### 그래프의 수학적 아름다움
- **추상화의 힘**: 현실 세계의 복잡한 관계를 단순한 수학적 모델로 표현
- **위상학적 성질**: 연결성, 경로, 사이클 등의 구조적 특성
- **최적화 이론**: 최단 경로, 최대 플로우, 최소 신장 트리 등의 최적화 문제

### 그래프의 실용적 가치
- **네트워크 분석**: 소셜 네트워크, 통신 네트워크, 교통 네트워크
- **의존성 관리**: 작업 스케줄링, 컴파일 순서, 패키지 관리
- **자원 할당**: 매칭 문제, 플로우 네트워크, 최적화 문제

**핵심 통찰**: 그래프는 **"관계의 언어"**입니다. 개별 요소들 사이의 연결과 상호작용을 통해 전체 시스템의 특성이 결정됩니다.

**철학적 결론**: 그래프 알고리즘을 마스터하는 것은 **"복잡한 시스템을 구조적으로 이해하는 능력"**을 기르는 것입니다. 이는 단순히 알고리즘을 외우는 것이 아니라, **"연결성과 구조가 만들어내는 창발적 성질"**을 이해하는 깊이 있는 사고력을 개발하는 과정입니다.