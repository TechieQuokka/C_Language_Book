# 16.1 텍스트 처리 프로그램

## 개념 정리

### 텍스트 처리의 중요성

텍스트 처리는 **모든 프로그래밍 영역의 기초**가 되는 필수 기능입니다. 로그 파일 분석, 데이터 변환, 설정 파일 파싱, 문서 처리 등 실무에서 가장 빈번하게 접하는 작업 중 하나입니다.

#### 텍스트 처리 프로그램의 특징

**1. 입출력 중심**
- **스트림 기반 처리**: 큰 파일도 효율적으로 처리
- **파이프라인 구조**: Unix 철학에 따른 모듈화
- **표준 입출력 활용**: stdin, stdout, stderr 적극 활용

**2. 문자열 조작 집약적**
- **패턴 매칭**: 정규식 및 문자열 검색
- **데이터 변환**: 형식 변환 및 정규화
- **구조화**: 비정형 텍스트의 구조화

**3. 성능과 메모리 효율성**
- **대용량 데이터 처리**: 메모리 사용량 최적화
- **실시간 처리**: 스트리밍 처리 능력
- **확장성**: 다양한 크기의 입력 처리

### 텍스트 처리 핵심 개념

#### 1. 문자 인코딩과 처리

**ASCII vs UTF-8**
```c
// ASCII 문자 처리 (7비트)
int is_ascii_alpha(char c) {
    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
}

// UTF-8 멀티바이트 문자 고려
#include <locale.h>
#include <wchar.h>

int process_utf8_text(const char* text) {
    setlocale(LC_ALL, "");
    // UTF-8 텍스트 처리 로직
}
```

**개행 문자 처리**
```c
// 크로스 플랫폼 개행 처리
void normalize_line_endings(char* text) {
    char* src = text;
    char* dst = text;

    while (*src) {
        if (*src == '\r') {
            if (*(src + 1) == '\n') {
                // Windows CRLF -> LF
                *dst++ = '\n';
                src += 2;
            } else {
                // Mac CR -> LF
                *dst++ = '\n';
                src++;
            }
        } else {
            *dst++ = *src++;
        }
    }
    *dst = '\0';
}
```

#### 2. 버퍼 관리 전략

**고정 크기 vs 동적 크기**
```c
#define BUFFER_SIZE 4096

// 고정 크기 버퍼 (단순, 빠름)
typedef struct {
    char data[BUFFER_SIZE];
    size_t length;
    size_t capacity;
} FixedBuffer;

// 동적 크기 버퍼 (유연, 복잡)
typedef struct {
    char* data;
    size_t length;
    size_t capacity;
} DynamicBuffer;

int buffer_append(DynamicBuffer* buf, const char* text) {
    size_t text_len = strlen(text);

    // 용량 부족 시 확장
    if (buf->length + text_len >= buf->capacity) {
        size_t new_capacity = buf->capacity * 2;
        if (new_capacity < buf->length + text_len + 1) {
            new_capacity = buf->length + text_len + 1;
        }

        char* new_data = realloc(buf->data, new_capacity);
        if (!new_data) return -1;

        buf->data = new_data;
        buf->capacity = new_capacity;
    }

    strcpy(buf->data + buf->length, text);
    buf->length += text_len;
    return 0;
}
```

#### 3. 스트림 처리 패턴

**라인별 처리 (Line-by-Line)**
```c
int process_file_by_line(const char* filename,
                         int (*process_line)(const char*, int)) {
    FILE* file = fopen(filename, "r");
    if (!file) return -1;

    char line[MAX_LINE_LENGTH];
    int line_number = 1;

    while (fgets(line, sizeof(line), file)) {
        // 개행 문자 제거
        line[strcspn(line, "\n")] = '\0';

        if (process_line(line, line_number) != 0) {
            break;
        }
        line_number++;
    }

    fclose(file);
    return 0;
}
```

**청크별 처리 (Chunk-based)**
```c
int process_file_by_chunk(const char* filename, size_t chunk_size,
                          int (*process_chunk)(const char*, size_t)) {
    FILE* file = fopen(filename, "rb");
    if (!file) return -1;

    char* buffer = malloc(chunk_size);
    if (!buffer) {
        fclose(file);
        return -1;
    }

    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, chunk_size, file)) > 0) {
        if (process_chunk(buffer, bytes_read) != 0) {
            break;
        }
    }

    free(buffer);
    fclose(file);
    return 0;
}
```

## 주요 프로젝트 유형

### 1. 단어 카운터 (Word Counter)

**기능 요구사항**
- 단어, 줄, 문자 개수 세기
- 다양한 옵션 지원 (-w, -l, -c)
- 여러 파일 동시 처리
- 표준 입력 지원

**핵심 구현 개념**
```c
typedef struct {
    size_t lines;
    size_t words;
    size_t characters;
    size_t bytes;
} TextStats;

typedef struct {
    int count_lines;
    int count_words;
    int count_chars;
    int count_bytes;
} CountOptions;

TextStats analyze_text(const char* text, CountOptions opts) {
    TextStats stats = {0};
    const char* ptr = text;
    int in_word = 0;

    while (*ptr) {
        stats.bytes++;

        if (opts.count_chars) {
            stats.characters++;
        }

        if (*ptr == '\n' && opts.count_lines) {
            stats.lines++;
        }

        if (opts.count_words) {
            if (isspace(*ptr)) {
                in_word = 0;
            } else if (!in_word) {
                in_word = 1;
                stats.words++;
            }
        }

        ptr++;
    }

    return stats;
}
```

**고급 기능**
- **단어 정의 사용자 정의**: 구분자 설정 가능
- **멀티바이트 문자 지원**: UTF-8 문자 올바른 카운팅
- **성능 최적화**: 대용량 파일 처리

### 2. 로그 분석기 (Log Analyzer)

**기능 요구사항**
- 로그 레벨별 분류 (ERROR, WARN, INFO, DEBUG)
- 시간대별 통계
- 특정 패턴 검색
- 요약 리포트 생성

**핵심 데이터 구조**
```c
typedef enum {
    LOG_DEBUG = 0,
    LOG_INFO,
    LOG_WARN,
    LOG_ERROR,
    LOG_LEVEL_COUNT
} LogLevel;

typedef struct {
    char timestamp[32];
    LogLevel level;
    char message[512];
    char source[64];
} LogEntry;

typedef struct {
    size_t counts[LOG_LEVEL_COUNT];
    time_t first_timestamp;
    time_t last_timestamp;
    char most_common_source[64];
} LogSummary;
```

**패턴 매칭 구현**
```c
typedef struct {
    char* pattern;
    int case_sensitive;
    int use_regex;
} SearchPattern;

int match_pattern(const char* text, const SearchPattern* pattern) {
    if (pattern->use_regex) {
        // 정규식 매칭 (regex.h 사용)
        regex_t regex;
        int result;

        int flags = REG_EXTENDED;
        if (!pattern->case_sensitive) {
            flags |= REG_ICASE;
        }

        if (regcomp(&regex, pattern->pattern, flags) != 0) {
            return 0; // 컴파일 실패
        }

        result = regexec(&regex, text, 0, NULL, 0);
        regfree(&regex);

        return result == 0;
    } else {
        // 단순 문자열 검색
        if (pattern->case_sensitive) {
            return strstr(text, pattern->pattern) != NULL;
        } else {
            return strcasestr(text, pattern->pattern) != NULL;
        }
    }
}
```

**시간 파싱 및 분석**
```c
time_t parse_timestamp(const char* timestamp_str) {
    struct tm tm = {0};

    // ISO 8601 형식: 2024-01-15T10:30:45
    if (strptime(timestamp_str, "%Y-%m-%dT%H:%M:%S", &tm)) {
        return mktime(&tm);
    }

    // 다른 형식들도 지원
    if (strptime(timestamp_str, "%Y-%m-%d %H:%M:%S", &tm)) {
        return mktime(&tm);
    }

    return -1; // 파싱 실패
}

void analyze_time_distribution(LogEntry* entries, size_t count) {
    int hourly_counts[24] = {0};

    for (size_t i = 0; i < count; i++) {
        time_t timestamp = parse_timestamp(entries[i].timestamp);
        if (timestamp != -1) {
            struct tm* tm = localtime(&timestamp);
            hourly_counts[tm->tm_hour]++;
        }
    }

    // 시간대별 통계 출력
    for (int hour = 0; hour < 24; hour++) {
        printf("%02d:00-%02d:59: %d entries\n",
               hour, hour, hourly_counts[hour]);
    }
}
```

### 3. 설정 파일 파서 (Configuration Parser)

**기능 요구사항**
- INI, JSON, YAML 형식 지원
- 키-값 쌍 파싱
- 섹션 및 중첩 구조 지원
- 타입 안전 값 추출

**INI 파서 구현**
```c
typedef struct ConfigSection {
    char name[64];
    struct ConfigEntry* entries;
    struct ConfigSection* next;
} ConfigSection;

typedef struct ConfigEntry {
    char key[64];
    char value[256];
    struct ConfigEntry* next;
} ConfigEntry;

typedef struct {
    ConfigSection* sections;
} Config;

Config* parse_ini_file(const char* filename) {
    FILE* file = fopen(filename, "r");
    if (!file) return NULL;

    Config* config = calloc(1, sizeof(Config));
    ConfigSection* current_section = NULL;
    char line[512];

    while (fgets(line, sizeof(line), file)) {
        // 공백 및 주석 처리
        char* trimmed = trim_whitespace(line);
        if (*trimmed == '\0' || *trimmed == '#' || *trimmed == ';') {
            continue;
        }

        // 섹션 헤더 [section_name]
        if (*trimmed == '[') {
            char* end = strchr(trimmed, ']');
            if (end) {
                *end = '\0';
                current_section = add_section(config, trimmed + 1);
            }
        } else {
            // 키=값 쌍
            char* equals = strchr(trimmed, '=');
            if (equals && current_section) {
                *equals = '\0';
                char* key = trim_whitespace(trimmed);
                char* value = trim_whitespace(equals + 1);
                add_entry(current_section, key, value);
            }
        }
    }

    fclose(file);
    return config;
}

const char* config_get_string(Config* config, const char* section,
                             const char* key, const char* default_value) {
    ConfigSection* sec = find_section(config, section);
    if (!sec) return default_value;

    ConfigEntry* entry = find_entry(sec, key);
    return entry ? entry->value : default_value;
}

int config_get_int(Config* config, const char* section,
                   const char* key, int default_value) {
    const char* str_value = config_get_string(config, section, key, NULL);
    if (!str_value) return default_value;

    char* endptr;
    long value = strtol(str_value, &endptr, 10);

    if (*endptr != '\0' || value < INT_MIN || value > INT_MAX) {
        return default_value;
    }

    return (int)value;
}
```

### 4. 텍스트 변환기 (Text Transformer)

**기능 요구사항**
- 대소문자 변환
- 문자 인코딩 변환
- 줄바꿈 형식 변환
- 탭/스페이스 변환
- 문자 치환 및 제거

**변환 파이프라인 구조**
```c
typedef struct TextTransform {
    char name[32];
    int (*transform)(char* text, size_t size, void* params);
    void* params;
    struct TextTransform* next;
} TextTransform;

typedef struct {
    TextTransform* transforms;
} TransformPipeline;

// 대소문자 변환
int transform_case(char* text, size_t size, void* params) {
    int to_upper = *(int*)params;

    for (size_t i = 0; i < size && text[i]; i++) {
        if (to_upper) {
            text[i] = toupper(text[i]);
        } else {
            text[i] = tolower(text[i]);
        }
    }
    return 0;
}

// 문자 치환
typedef struct {
    char from;
    char to;
} CharReplacement;

int transform_replace_char(char* text, size_t size, void* params) {
    CharReplacement* repl = (CharReplacement*)params;

    for (size_t i = 0; i < size && text[i]; i++) {
        if (text[i] == repl->from) {
            text[i] = repl->to;
        }
    }
    return 0;
}

// 파이프라인 실행
int execute_pipeline(TransformPipeline* pipeline, char* text, size_t size) {
    TextTransform* current = pipeline->transforms;

    while (current) {
        if (current->transform(text, size, current->params) != 0) {
            return -1; // 변환 실패
        }
        current = current->next;
    }

    return 0;
}
```

### 5. 데이터 추출기 (Data Extractor)

**기능 요구사항**
- 구조화되지 않은 텍스트에서 데이터 추출
- 정규식 패턴 매칭
- CSV/TSV 형식 출력
- 필드 검증 및 정규화

**이메일 주소 추출 예시**
```c
typedef struct {
    char email[256];
    int valid;
} EmailInfo;

typedef struct {
    EmailInfo* emails;
    size_t count;
    size_t capacity;
} EmailList;

int extract_emails_from_text(const char* text, EmailList* list) {
    regex_t regex;
    regmatch_t matches[2];

    // 간단한 이메일 정규식
    const char* pattern = "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}";

    if (regcomp(&regex, pattern, REG_EXTENDED) != 0) {
        return -1;
    }

    const char* ptr = text;
    while (regexec(&regex, ptr, 2, matches, 0) == 0) {
        // 매치된 이메일 추출
        int length = matches[0].rm_eo - matches[0].rm_so;
        if (length < sizeof(list->emails[0].email) - 1) {
            // 리스트 확장 필요 시
            if (list->count >= list->capacity) {
                if (expand_email_list(list) != 0) break;
            }

            strncpy(list->emails[list->count].email,
                   ptr + matches[0].rm_so, length);
            list->emails[list->count].email[length] = '\0';
            list->emails[list->count].valid = validate_email(
                list->emails[list->count].email);
            list->count++;
        }

        ptr += matches[0].rm_eo;
    }

    regfree(&regex);
    return 0;
}

int validate_email(const char* email) {
    // 추가적인 검증 로직
    if (!email || strlen(email) == 0) return 0;

    // @ 기호가 정확히 하나 있는지 확인
    int at_count = 0;
    for (const char* p = email; *p; p++) {
        if (*p == '@') at_count++;
    }

    return at_count == 1;
}
```

## 실용적 설계 패턴

### 1. 플러그인 아키텍처

**모듈식 텍스트 처리기**
```c
typedef struct {
    char name[32];
    char description[128];
    int (*process)(const char* input, char** output, void* config);
    int (*init)(void** config);
    void (*cleanup)(void* config);
} TextProcessor;

typedef struct {
    TextProcessor* processors;
    size_t count;
    size_t capacity;
} ProcessorRegistry;

int register_processor(ProcessorRegistry* registry,
                      const TextProcessor* processor) {
    if (registry->count >= registry->capacity) {
        if (expand_registry(registry) != 0) return -1;
    }

    registry->processors[registry->count++] = *processor;
    return 0;
}

TextProcessor* find_processor(ProcessorRegistry* registry,
                             const char* name) {
    for (size_t i = 0; i < registry->count; i++) {
        if (strcmp(registry->processors[i].name, name) == 0) {
            return &registry->processors[i];
        }
    }
    return NULL;
}
```

### 2. 스트리밍 처리 패턴

**대용량 파일 처리**
```c
typedef struct {
    FILE* input;
    FILE* output;
    char* buffer;
    size_t buffer_size;
    size_t bytes_processed;
    int (*line_handler)(const char* line, void* context);
    void* context;
} StreamProcessor;

int process_stream(StreamProcessor* processor) {
    char* line = NULL;
    size_t line_cap = 0;
    ssize_t line_len;

    while ((line_len = getline(&line, &line_cap, processor->input)) > 0) {
        // 개행 문자 제거
        if (line[line_len - 1] == '\n') {
            line[line_len - 1] = '\0';
            line_len--;
        }

        // 라인 처리
        if (processor->line_handler(line, processor->context) != 0) {
            break;
        }

        processor->bytes_processed += line_len;
    }

    free(line);
    return 0;
}
```

### 3. 오류 처리 및 복구

**견고한 파싱**
```c
typedef enum {
    PARSE_SUCCESS = 0,
    PARSE_ERROR_FILE_NOT_FOUND,
    PARSE_ERROR_INVALID_FORMAT,
    PARSE_ERROR_MEMORY,
    PARSE_ERROR_ENCODING
} ParseResult;

typedef struct {
    ParseResult result;
    int line_number;
    int column_number;
    char error_message[256];
} ParseError;

ParseResult parse_with_recovery(const char* filename,
                               void** result,
                               ParseError* error) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        snprintf(error->error_message, sizeof(error->error_message),
                "Cannot open file: %s", filename);
        return PARSE_ERROR_FILE_NOT_FOUND;
    }

    char line[1024];
    int line_num = 1;

    while (fgets(line, sizeof(line), file)) {
        ParseResult line_result = parse_line(line, line_num, error);

        if (line_result != PARSE_SUCCESS) {
            if (line_result == PARSE_ERROR_INVALID_FORMAT) {
                // 포맷 오류는 경고하고 계속
                fprintf(stderr, "Warning: Invalid format at line %d\n", line_num);
                continue;
            } else {
                // 치명적 오류는 중단
                fclose(file);
                return line_result;
            }
        }

        line_num++;
    }

    fclose(file);
    return PARSE_SUCCESS;
}
```

## 성능 최적화 기법

### 1. 메모리 효율적 문자열 처리

**문자열 인터닝**
```c
typedef struct StringPool {
    char** strings;
    size_t count;
    size_t capacity;
} StringPool;

const char* intern_string(StringPool* pool, const char* str) {
    // 이미 존재하는 문자열인지 확인
    for (size_t i = 0; i < pool->count; i++) {
        if (strcmp(pool->strings[i], str) == 0) {
            return pool->strings[i];
        }
    }

    // 새 문자열 추가
    if (pool->count >= pool->capacity) {
        if (expand_string_pool(pool) != 0) return NULL;
    }

    pool->strings[pool->count] = strdup(str);
    return pool->strings[pool->count++];
}
```

### 2. 캐시 효율적 데이터 구조

**SoA (Structure of Arrays) 패턴**
```c
// AoS (Array of Structures) - 캐시 비친화적
typedef struct {
    char word[64];
    int count;
    double frequency;
} WordEntry_AoS;

// SoA (Structure of Arrays) - 캐시 친화적
typedef struct {
    char words[MAX_WORDS][64];  // 단어만 연속 배치
    int counts[MAX_WORDS];      // 카운트만 연속 배치
    double frequencies[MAX_WORDS]; // 빈도만 연속 배치
    size_t count;
} WordList_SoA;

// 단어 검색 시 words 배열만 캐시에 로드됨
int find_word_soa(WordList_SoA* list, const char* word) {
    for (size_t i = 0; i < list->count; i++) {
        if (strcmp(list->words[i], word) == 0) {
            return i;
        }
    }
    return -1;
}
```

### 3. 병렬 처리

**라인별 병렬 처리**
```c
#include <pthread.h>

typedef struct {
    char** lines;
    size_t start_index;
    size_t end_index;
    int (*processor)(const char* line);
    int* results;
} ThreadData;

void* process_lines_thread(void* arg) {
    ThreadData* data = (ThreadData*)arg;

    for (size_t i = data->start_index; i < data->end_index; i++) {
        data->results[i] = data->processor(data->lines[i]);
    }

    return NULL;
}

int process_lines_parallel(char** lines, size_t count,
                          int (*processor)(const char* line),
                          int num_threads) {
    pthread_t* threads = malloc(num_threads * sizeof(pthread_t));
    ThreadData* thread_data = malloc(num_threads * sizeof(ThreadData));
    int* results = malloc(count * sizeof(int));

    size_t lines_per_thread = count / num_threads;

    for (int i = 0; i < num_threads; i++) {
        thread_data[i].lines = lines;
        thread_data[i].start_index = i * lines_per_thread;
        thread_data[i].end_index = (i == num_threads - 1) ?
                                   count : (i + 1) * lines_per_thread;
        thread_data[i].processor = processor;
        thread_data[i].results = results;

        pthread_create(&threads[i], NULL, process_lines_thread,
                      &thread_data[i]);
    }

    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    free(threads);
    free(thread_data);
    free(results);

    return 0;
}
```

## 실전 활용 사례

### 1. 시스템 관리 도구

**로그 순환 도구**
- 크기 기반 로그 파일 분할
- 시간 기반 로그 아카이빙
- 압축 및 정리 자동화

**설정 관리 도구**
- 다중 환경 설정 병합
- 템플릿 기반 설정 생성
- 설정 검증 및 마이그레이션

### 2. 데이터 처리 파이프라인

**ETL (Extract, Transform, Load) 도구**
- 다양한 형식 데이터 추출
- 규칙 기반 데이터 변환
- 대상 시스템에 로드

**리포팅 시스템**
- 원시 데이터 집계
- 포맷된 리포트 생성
- 자동화된 배포

### 3. 개발 도구

**코드 생성기**
- 템플릿 기반 코드 생성
- 메타데이터 기반 자동 생성
- 사용자 정의 규칙 적용

**문서 변환기**
- 마크다운 ↔ HTML 변환
- API 문서 자동 생성
- 다국어 문서 관리

텍스트 처리 프로그램은 **실무에서 가장 빈번하게 개발하는 도구**이므로, 이러한 패턴과 기법들을 숙달하면 다양한 자동화 작업과 데이터 처리 업무에서 큰 도움이 됩니다.