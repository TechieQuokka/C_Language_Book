# 16.3 파일 관리 시스템

> **"파일 시스템은 데이터의 조직화와 접근 제어의 핵심이다. 효율적인 파일 관리는 시스템 성능과 사용자 경험을 좌우한다."**

## 개요

파일 관리 시스템은 **데이터의 저장, 조직화, 검색, 보안**을 담당하는 핵심 시스템입니다. C언어를 활용하여 효율적이고 안전한 파일 관리 시스템을 구축하는 방법을 체계적으로 학습합니다.

### 학습 목표

1. **파일 시스템 구조 이해**: 디렉토리 계층, 메타데이터, 접근 권한
2. **효율적인 데이터 구조**: 인덱싱, 해싱, 트리 구조 활용
3. **성능 최적화**: 캐싱, 버퍼링, 비동기 I/O
4. **보안과 무결성**: 접근 제어, 백업, 복구 시스템

## 파일 시스템 기본 개념

### 파일 시스템 계층 구조

```
┌─────────────────────────────────────┐
│     사용자 인터페이스 계층            │  ← 명령어, GUI
├─────────────────────────────────────┤
│     파일 관리 API 계층               │  ← 생성, 삭제, 이동
├─────────────────────────────────────┤
│     메타데이터 관리 계층             │  ← 권한, 속성, 인덱스
├─────────────────────────────────────┤
│     저장소 추상화 계층               │  ← 디렉토리, 파일 블록
├─────────────────────────────────────┤
│     물리적 저장소 계층               │  ← 디스크, SSD, 네트워크
└─────────────────────────────────────┘
```

### 핵심 컴포넌트

#### 1. 파일 메타데이터
```c
typedef struct FileMetadata {
    char name[256];              // 파일명
    size_t size;                 // 파일 크기
    time_t created_time;         // 생성 시간
    time_t modified_time;        // 수정 시간
    time_t accessed_time;        // 접근 시간
    mode_t permissions;          // 접근 권한
    uid_t owner_id;              // 소유자 ID
    gid_t group_id;              // 그룹 ID
    char checksum[32];           // 무결성 검증
} FileMetadata;
```

#### 2. 디렉토리 구조
```c
typedef struct DirectoryEntry {
    char name[256];              // 엔트리명
    bool is_directory;           // 디렉토리 여부
    FileMetadata* metadata;      // 메타데이터 포인터
    struct DirectoryEntry* parent;    // 부모 디렉토리
    struct DirectoryEntry* children;  // 자식 엔트리들
    struct DirectoryEntry* next;      // 형제 엔트리
} DirectoryEntry;
```

## 파일 관리 시스템 설계

### 시스템 아키텍처

```
              파일 관리 시스템
    ┌────────────────────────────────────┐
    │                                    │
    │  ┌─────────┐  ┌─────────────────┐ │
    │  │ Command │  │   File API      │ │
    │  │Interface│  │  (CRUD 연산)    │ │
    │  └─────────┘  └─────────────────┘ │
    │       │              │            │
    │  ┌─────────┐  ┌─────────────────┐ │
    │  │Directory│  │   Index         │ │
    │  │Manager  │  │  Management     │ │
    │  └─────────┘  └─────────────────┘ │
    │       │              │            │
    │  ┌─────────┐  ┌─────────────────┐ │
    │  │Security │  │   Storage       │ │
    │  │Manager  │  │  Management     │ │
    │  └─────────┘  └─────────────────┘ │
    │       │              │            │
    │  ┌─────────┐  ┌─────────────────┐ │
    │  │  Cache  │  │   Physical      │ │
    │  │ System  │  │   Storage       │ │
    │  └─────────┘  └─────────────────┘ │
    └────────────────────────────────────┘
```

### 주요 시스템 모듈

#### 1. 파일 작업 API
**기본 CRUD 연산**
- **Create**: 새 파일/디렉토리 생성
- **Read**: 파일 내용 읽기, 디렉토리 탐색
- **Update**: 파일 수정, 메타데이터 갱신
- **Delete**: 파일/디렉토리 삭제

**고급 연산**
- **Copy/Move**: 파일 복사 및 이동
- **Search**: 이름, 내용, 속성 기반 검색
- **Backup**: 자동 백업 및 버전 관리
- **Compress**: 압축 및 아카이브 기능

#### 2. 인덱싱 시스템
```c
// 해시 테이블 기반 빠른 검색
typedef struct FileIndex {
    char* filename;
    DirectoryEntry* entry;
    struct FileIndex* next;
} FileIndex;

// B-트리 기반 정렬된 검색
typedef struct BTreeNode {
    char keys[MAX_KEYS][256];
    DirectoryEntry* values[MAX_KEYS];
    struct BTreeNode* children[MAX_KEYS + 1];
    int num_keys;
    bool is_leaf;
} BTreeNode;
```

#### 3. 권한 관리 시스템
```
권한 비트 구조 (Unix 스타일)
┌─────┬─────┬─────┬─────────────────┐
│     │Owner│Group│    Others       │
│Type │ rwx │ rwx │      rwx        │
├─────┼─────┼─────┼─────────────────┤
│  d  │ 111 │ 101 │      100        │  → drwxr-xr--
└─────┴─────┴─────┴─────────────────┘
  │     │     │           │
파일│   읽기│  그룹│    기타 사용자
타입│   쓰기│  권한│        권한
    │   실행│      │
    소유자 권한
```

## 핵심 구현 개념

### 1. 효율적인 디렉토리 탐색

#### 계층적 네임스페이스
```c
// 경로 파싱 및 탐색
typedef struct PathComponent {
    char name[256];
    struct PathComponent* next;
} PathComponent;

// 경로를 컴포넌트로 분해
PathComponent* parse_path(const char* path) {
    // "/home/user/documents/file.txt"
    // → ["home", "user", "documents", "file.txt"]
}

// 경로 기반 파일 검색
DirectoryEntry* resolve_path(DirectoryEntry* root, const char* path) {
    PathComponent* components = parse_path(path);
    DirectoryEntry* current = root;

    // 각 경로 컴포넌트를 순차적으로 탐색
    while (components && current) {
        current = find_child(current, components->name);
        components = components->next;
    }

    return current;
}
```

#### 캐시 기반 빠른 접근
```c
typedef struct PathCache {
    char path[PATH_MAX];
    DirectoryEntry* entry;
    time_t cache_time;
    struct PathCache* next;
} PathCache;

// LRU 캐시로 자주 사용되는 경로 관리
PathCache* lru_cache = NULL;
const int CACHE_SIZE = 1000;
const int CACHE_EXPIRE_SECONDS = 300;  // 5분
```

### 2. 메타데이터 관리

#### 속성 기반 분류
```c
typedef enum FileType {
    FILE_TYPE_REGULAR,     // 일반 파일
    FILE_TYPE_DIRECTORY,   // 디렉토리
    FILE_TYPE_SYMLINK,     // 심볼릭 링크
    FILE_TYPE_SPECIAL      // 특수 파일 (장치 등)
} FileType;

typedef struct ExtendedAttributes {
    char mime_type[64];        // MIME 타입
    char encoding[32];         // 인코딩
    char description[512];     // 설명
    char tags[1024];          // 태그 (공백 구분)
    int priority;             // 우선순위
} ExtendedAttributes;
```

#### 무결성 검증
```c
// 체크섬 계산 (SHA-256)
void calculate_checksum(const char* filepath, char* checksum) {
    FILE* file = fopen(filepath, "rb");
    unsigned char hash[32];

    // SHA-256 해시 계산
    sha256_hash_file(file, hash);

    // 16진수 문자열로 변환
    for (int i = 0; i < 32; i++) {
        sprintf(checksum + (i * 2), "%02x", hash[i]);
    }

    fclose(file);
}

// 파일 무결성 검증
bool verify_file_integrity(const char* filepath, const char* expected_checksum) {
    char current_checksum[65];
    calculate_checksum(filepath, current_checksum);
    return strcmp(current_checksum, expected_checksum) == 0;
}
```

### 3. 검색 시스템

#### 다차원 검색
```c
typedef struct SearchCriteria {
    char* name_pattern;        // 파일명 패턴 (와일드카드)
    char* content_pattern;     // 내용 검색 (정규표현식)
    FileType file_type;        // 파일 타입
    size_t min_size, max_size; // 크기 범위
    time_t start_time, end_time; // 시간 범위
    char* tags;               // 태그 검색
} SearchCriteria;

// 인덱스 기반 빠른 검색
typedef struct SearchIndex {
    // 파일명 인덱스 (Trie)
    TrieNode* name_index;

    // 내용 인덱스 (역인덱스)
    InvertedIndex* content_index;

    // 태그 인덱스 (해시맵)
    HashMap* tag_index;

    // 시간 인덱스 (B-트리)
    BTreeNode* time_index;
} SearchIndex;
```

#### 전문 검색 (Full-Text Search)
```c
// 역인덱스 구조
typedef struct InvertedIndex {
    char word[64];                    // 검색어
    FileReference* file_list;         // 파일 목록
    struct InvertedIndex* next;
} InvertedIndex;

typedef struct FileReference {
    DirectoryEntry* file;
    int* positions;                   // 단어 위치들
    int position_count;
    double relevance_score;           // 관련성 점수
    struct FileReference* next;
} FileReference;

// TF-IDF 기반 관련성 점수 계산
double calculate_relevance(const char* query, FileReference* file_ref) {
    // Term Frequency × Inverse Document Frequency
    double tf = calculate_term_frequency(query, file_ref);
    double idf = calculate_inverse_document_frequency(query);
    return tf * idf;
}
```

### 4. 성능 최적화

#### 버퍼링 및 캐싱
```c
typedef struct BufferCache {
    char* data;               // 버퍼 데이터
    size_t size;             // 버퍼 크기
    char filepath[PATH_MAX]; // 파일 경로
    time_t last_access;      // 마지막 접근 시간
    bool dirty;              // 수정 여부
    struct BufferCache* next;
} BufferCache;

// 적응형 캐시 크기 조정
void adjust_cache_size() {
    double hit_ratio = cache_hits / (double)(cache_hits + cache_misses);

    if (hit_ratio < 0.7) {
        cache_size = min(cache_size * 1.2, MAX_CACHE_SIZE);
    } else if (hit_ratio > 0.9) {
        cache_size = max(cache_size * 0.9, MIN_CACHE_SIZE);
    }
}
```

#### 비동기 I/O
```c
typedef struct AsyncIORequest {
    int operation_type;       // READ, WRITE, DELETE
    char filepath[PATH_MAX];
    void* buffer;
    size_t size;
    off_t offset;
    void (*callback)(struct AsyncIORequest*, int result);
    void* user_data;
} AsyncIORequest;

// 비동기 작업 큐
typedef struct IOQueue {
    AsyncIORequest* requests;
    int head, tail, size;
    pthread_mutex_t mutex;
    pthread_cond_t not_empty;
    pthread_cond_t not_full;
} IOQueue;
```

### 5. 보안 및 백업

#### 접근 제어
```c
typedef struct AccessControlEntry {
    uid_t user_id;
    gid_t group_id;
    mode_t permissions;
    time_t granted_time;
    time_t expire_time;
} AccessControlEntry;

typedef struct AccessControlList {
    AccessControlEntry* entries;
    int entry_count;
    mode_t default_permissions;
} AccessControlList;

// 권한 검사
bool check_permission(DirectoryEntry* entry, uid_t user_id, int operation) {
    AccessControlList* acl = entry->metadata->acl;

    // 소유자 권한 확인
    if (entry->metadata->owner_id == user_id) {
        return (entry->metadata->permissions & operation) != 0;
    }

    // ACL 엔트리 확인
    for (int i = 0; i < acl->entry_count; i++) {
        if (acl->entries[i].user_id == user_id) {
            return (acl->entries[i].permissions & operation) != 0;
        }
    }

    return false;
}
```

#### 자동 백업 시스템
```c
typedef struct BackupPolicy {
    int backup_interval;      // 백업 주기 (초)
    int retention_days;       // 보관 기간 (일)
    char backup_directory[PATH_MAX];
    bool incremental_backup;  // 증분 백업 여부
    bool compress_backup;     // 압축 여부
} BackupPolicy;

typedef struct BackupScheduler {
    BackupPolicy* policies;
    int policy_count;
    pthread_t scheduler_thread;
    bool running;
} BackupScheduler;

// 증분 백업 구현
void perform_incremental_backup(const char* source_dir, const char* backup_dir) {
    DirectoryEntry* source = resolve_path(root, source_dir);
    time_t last_backup_time = get_last_backup_time(backup_dir);

    traverse_directory(source, [&](DirectoryEntry* entry) {
        if (entry->metadata->modified_time > last_backup_time) {
            backup_file(entry, backup_dir);
        }
    });
}
```

## 고급 기능

### 1. 가상 파일 시스템 (VFS)

#### 다중 스토리지 지원
```c
typedef struct StorageProvider {
    char name[64];
    int (*open)(const char* path, int flags);
    int (*read)(int fd, void* buffer, size_t size);
    int (*write)(int fd, const void* buffer, size_t size);
    int (*close)(int fd);
    void* private_data;
} StorageProvider;

// 로컬 디스크, 네트워크 드라이브, 클라우드 스토리지 통합
StorageProvider providers[] = {
    {"local", local_open, local_read, local_write, local_close, NULL},
    {"nfs", nfs_open, nfs_read, nfs_write, nfs_close, NULL},
    {"s3", s3_open, s3_read, s3_write, s3_close, NULL}
};
```

#### 마운트 포인트 관리
```c
typedef struct MountPoint {
    char path[PATH_MAX];
    StorageProvider* provider;
    void* mount_data;
    struct MountPoint* next;
} MountPoint;

// 경로를 적절한 스토리지 제공자로 라우팅
StorageProvider* resolve_storage_provider(const char* path) {
    MountPoint* mount = find_mount_point(path);
    return mount ? mount->provider : &providers[0];  // 기본값: 로컬
}
```

### 2. 실시간 모니터링

#### 파일 시스템 이벤트
```c
typedef enum FSEventType {
    FS_EVENT_FILE_CREATED,
    FS_EVENT_FILE_MODIFIED,
    FS_EVENT_FILE_DELETED,
    FS_EVENT_DIR_CREATED,
    FS_EVENT_DIR_DELETED,
    FS_EVENT_PERMISSION_CHANGED
} FSEventType;

typedef struct FSEvent {
    FSEventType type;
    char path[PATH_MAX];
    time_t timestamp;
    uid_t user_id;
    size_t file_size;
} FSEvent;

// 이벤트 리스너 등록
typedef struct EventListener {
    void (*callback)(FSEvent* event, void* user_data);
    void* user_data;
    char watch_path[PATH_MAX];
    struct EventListener* next;
} EventListener;
```

#### 시스템 상태 모니터링
```c
typedef struct SystemStats {
    size_t total_files;
    size_t total_directories;
    size_t total_storage_used;
    size_t total_storage_available;
    double average_file_size;
    int active_handles;
    double cache_hit_ratio;
    time_t last_update;
} SystemStats;

// 실시간 통계 업데이트
void update_system_stats() {
    SystemStats* stats = get_system_stats();

    stats->total_files = count_files(root);
    stats->total_storage_used = calculate_storage_usage(root);
    stats->cache_hit_ratio = cache_hits / (double)(cache_hits + cache_misses);
    stats->last_update = time(NULL);
}
```

### 3. 데이터 중복 제거

#### 해시 기반 중복 탐지
```c
typedef struct FileHash {
    char checksum[65];        // SHA-256 해시
    size_t file_size;
    DirectoryEntry** files;   // 동일한 해시를 가진 파일들
    int file_count;
    struct FileHash* next;
} FileHash;

// 중복 파일 탐지 및 관리
void detect_duplicates() {
    HashMap* hash_map = create_hashmap();

    traverse_directory(root, [&](DirectoryEntry* entry) {
        if (entry->metadata->size > MIN_DEDUP_SIZE) {
            char checksum[65];
            calculate_checksum(get_file_path(entry), checksum);

            FileHash* hash_entry = hashmap_get(hash_map, checksum);
            if (hash_entry) {
                add_duplicate_file(hash_entry, entry);
            } else {
                hash_entry = create_file_hash(checksum, entry);
                hashmap_put(hash_map, checksum, hash_entry);
            }
        }
    });
}
```

#### 참조 링크 시스템
```c
// 하드링크 기반 공간 절약
int create_hardlink(const char* original, const char* link_path) {
    DirectoryEntry* original_entry = resolve_path(root, original);
    if (!original_entry) return -1;

    // 참조 카운트 증가
    original_entry->metadata->link_count++;

    // 새로운 디렉토리 엔트리 생성 (같은 inode)
    DirectoryEntry* link_entry = create_directory_entry(link_path);
    link_entry->metadata = original_entry->metadata;  // 메타데이터 공유

    return 0;
}
```

## 성능 최적화 전략

### 1. 메모리 관리 최적화

#### 메모리 풀 사용
```c
typedef struct MemoryPool {
    void* memory_block;
    size_t block_size;
    size_t chunk_size;
    void* free_list;
    pthread_mutex_t mutex;
} MemoryPool;

// 자주 할당되는 구조체용 풀
MemoryPool* directory_entry_pool;
MemoryPool* file_metadata_pool;
MemoryPool* path_component_pool;

// O(1) 할당/해제
DirectoryEntry* alloc_directory_entry() {
    return (DirectoryEntry*)memory_pool_alloc(directory_entry_pool);
}

void free_directory_entry(DirectoryEntry* entry) {
    memory_pool_free(directory_entry_pool, entry);
}
```

#### 지연 로딩 (Lazy Loading)
```c
typedef struct LazyLoadedDirectory {
    DirectoryEntry* entry;
    bool children_loaded;
    pthread_mutex_t load_mutex;
} LazyLoadedDirectory;

// 필요할 때만 자식 디렉토리 로드
DirectoryEntry* get_children(LazyLoadedDirectory* lazy_dir) {
    if (!lazy_dir->children_loaded) {
        pthread_mutex_lock(&lazy_dir->load_mutex);

        if (!lazy_dir->children_loaded) {  // Double-checked locking
            load_directory_children(lazy_dir->entry);
            lazy_dir->children_loaded = true;
        }

        pthread_mutex_unlock(&lazy_dir->load_mutex);
    }

    return lazy_dir->entry->children;
}
```

### 2. 동시성 최적화

#### 읽기-쓰기 락
```c
typedef struct RWLock {
    pthread_rwlock_t lock;
    int readers;
    int writers;
} RWLock;

// 디렉토리별 세밀한 락킹
typedef struct DirectoryLock {
    char path[PATH_MAX];
    RWLock rwlock;
    struct DirectoryLock* next;
} DirectoryLock;

// 경로 기반 락 획득
void acquire_read_lock(const char* path) {
    DirectoryLock* lock = get_or_create_directory_lock(path);
    pthread_rwlock_rdlock(&lock->rwlock.lock);
}

void acquire_write_lock(const char* path) {
    DirectoryLock* lock = get_or_create_directory_lock(path);
    pthread_rwlock_wrlock(&lock->rwlock.lock);
}
```

#### 락-프리 자료구조
```c
// 원자적 연산을 이용한 락-프리 해시맵
typedef struct LockFreeHashMap {
    atomic_ptr_t* buckets;
    atomic_int size;
    int capacity;
} LockFreeHashMap;

bool hashmap_cas_insert(LockFreeHashMap* map, const char* key, void* value) {
    uint32_t hash = hash_function(key);
    int index = hash % map->capacity;

    HashNode* new_node = create_hash_node(key, value);
    HashNode* expected = atomic_load(&map->buckets[index]);

    do {
        new_node->next = expected;
    } while (!atomic_compare_exchange_weak(&map->buckets[index], &expected, new_node));

    return true;
}
```

## 실전 적용 사례

### 1. 개인용 파일 관리자

#### 기능 요구사항
- **직관적인 네비게이션**: 트리뷰, 브레드크럼, 즐겨찾기
- **강력한 검색**: 파일명, 내용, 메타데이터 통합 검색
- **배치 작업**: 다중 파일 복사/이동/삭제
- **미디어 미리보기**: 이미지, 동영상, 오디오 썸네일
- **태그 및 분류**: 사용자 정의 태그 시스템

#### 핵심 구현
```c
typedef struct PersonalFileManager {
    DirectoryEntry* root;
    SearchIndex* search_index;
    BookmarkManager* bookmarks;
    ThumbnailCache* thumbnail_cache;
    TagManager* tag_manager;
    HistoryManager* history;
} PersonalFileManager;

// 통합 검색 인터페이스
SearchResult* unified_search(PersonalFileManager* fm, const char* query) {
    SearchResult* results = create_search_result();

    // 파일명 검색
    append_results(results, search_by_name(fm->search_index, query));

    // 내용 검색
    append_results(results, search_by_content(fm->search_index, query));

    // 태그 검색
    append_results(results, search_by_tags(fm->tag_manager, query));

    // 관련성으로 정렬
    sort_by_relevance(results);

    return results;
}
```

### 2. 기업용 문서 관리 시스템

#### 엔터프라이즈 요구사항
- **버전 관리**: 문서 히스토리, 변경 추적
- **협업 기능**: 동시 편집, 잠금, 승인 워크플로우
- **보안 및 감사**: 접근 로그, 권한 관리, 암호화
- **대용량 처리**: 수십만 파일, 테라바이트급 저장소
- **고가용성**: 이중화, 백업, 재해 복구

#### 아키텍처 설계
```c
typedef struct EnterpriseDocumentSystem {
    // 분산 저장소
    DistributedStorage* storage_cluster;

    // 버전 관리
    VersionControl* version_manager;

    // 워크플로우 엔진
    WorkflowEngine* workflow_engine;

    // 보안 모듈
    SecurityManager* security_manager;

    // 감사 로그
    AuditLogger* audit_logger;

    // 전문 검색
    FullTextSearch* search_engine;
} EnterpriseDocumentSystem;

// 워크플로우 기반 문서 승인
int submit_for_approval(EnterpriseDocumentSystem* eds,
                       const char* document_path,
                       ApprovalWorkflow* workflow) {

    // 1. 권한 확인
    if (!check_permission(eds->security_manager, document_path, PERMISSION_SUBMIT)) {
        return ERROR_PERMISSION_DENIED;
    }

    // 2. 워크플로우 시작
    WorkflowInstance* instance = start_workflow(eds->workflow_engine, workflow);

    // 3. 문서 잠금
    lock_document(eds->version_manager, document_path, LOCK_READ_ONLY);

    // 4. 감사 로그 기록
    audit_log(eds->audit_logger, "DOCUMENT_SUBMITTED", document_path, get_current_user());

    return SUCCESS;
}
```

### 3. 클라우드 스토리지 시스템

#### 클라우드 특화 기능
- **자동 동기화**: 로컬-클라우드 양방향 동기화
- **오프라인 접근**: 로컬 캐시, 충돌 해결
- **공유 및 협업**: 링크 공유, 권한 설정
- **모바일 지원**: 압축, 스트리밍, 오프라인 모드
- **글로벌 배포**: CDN, 지역별 복제

#### 동기화 알고리즘
```c
typedef struct SyncState {
    char file_path[PATH_MAX];
    time_t local_modified;
    time_t remote_modified;
    char local_checksum[65];
    char remote_checksum[65];
    SyncAction required_action;
} SyncState;

typedef enum SyncAction {
    SYNC_UP_TO_DATE,
    SYNC_UPLOAD_LOCAL,
    SYNC_DOWNLOAD_REMOTE,
    SYNC_CONFLICT_RESOLUTION
} SyncAction;

// 3-way 동기화 상태 판단
SyncAction determine_sync_action(SyncState* state) {
    if (strcmp(state->local_checksum, state->remote_checksum) == 0) {
        return SYNC_UP_TO_DATE;
    }

    if (state->local_modified > state->remote_modified) {
        return SYNC_UPLOAD_LOCAL;
    } else if (state->remote_modified > state->local_modified) {
        return SYNC_DOWNLOAD_REMOTE;
    } else {
        // 같은 시간에 수정됨 → 충돌
        return SYNC_CONFLICT_RESOLUTION;
    }
}
```

## 모범 사례 및 주의사항

### 설계 원칙

1. **모듈화**: 각 기능을 독립적인 모듈로 분리
2. **확장성**: 플러그인 아키텍처로 기능 확장 지원
3. **성능**: 캐싱, 인덱싱, 비동기 처리 적극 활용
4. **안정성**: 예외 처리, 복구 메커니즘, 트랜잭션 지원
5. **보안**: 최소 권한 원칙, 암호화, 감사 추적

### 개발 가이드라인

#### 에러 처리
```c
typedef enum FSError {
    FS_SUCCESS = 0,
    FS_ERROR_NOT_FOUND,
    FS_ERROR_PERMISSION_DENIED,
    FS_ERROR_IO_ERROR,
    FS_ERROR_OUT_OF_SPACE,
    FS_ERROR_CORRUPTED_DATA
} FSError;

// 일관된 에러 처리
FSError safe_file_operation(const char* path, FileOperation op) {
    // 1. 입력 검증
    if (!path || strlen(path) == 0) {
        return FS_ERROR_INVALID_PATH;
    }

    // 2. 권한 확인
    if (!check_permission(path, op.required_permission)) {
        return FS_ERROR_PERMISSION_DENIED;
    }

    // 3. 작업 수행
    FSError result = perform_operation(path, &op);

    // 4. 후처리 (로깅, 정리 등)
    log_operation(path, op.type, result);

    return result;
}
```

#### 메모리 관리
```c
// RAII 패턴 적용
typedef struct FileHandle {
    FILE* file;
    char* buffer;
    bool auto_close;
} FileHandle;

FileHandle* create_file_handle(const char* path, const char* mode) {
    FileHandle* handle = malloc(sizeof(FileHandle));
    if (!handle) return NULL;

    handle->file = fopen(path, mode);
    if (!handle->file) {
        free(handle);
        return NULL;
    }

    handle->buffer = malloc(BUFFER_SIZE);
    handle->auto_close = true;

    return handle;
}

void destroy_file_handle(FileHandle** handle) {
    if (handle && *handle) {
        if ((*handle)->auto_close && (*handle)->file) {
            fclose((*handle)->file);
        }
        free((*handle)->buffer);
        free(*handle);
        *handle = NULL;
    }
}
```

#### 테스트 전략
```c
// 단위 테스트 프레임워크
typedef struct TestSuite {
    char name[128];
    TestCase* test_cases;
    int test_count;
    SetupFunc setup;
    TeardownFunc teardown;
} TestSuite;

// 파일 시스템 테스트용 Mock
typedef struct MockFileSystem {
    HashMap* file_contents;
    HashMap* file_metadata;
    bool simulate_io_errors;
    double error_probability;
} MockFileSystem;

void test_file_creation() {
    MockFileSystem* mock_fs = create_mock_filesystem();
    FileManager* fm = create_file_manager(mock_fs);

    // 정상 케이스
    FSError result = create_file(fm, "/test/file.txt", "Hello World");
    assert(result == FS_SUCCESS);
    assert(file_exists(mock_fs, "/test/file.txt"));

    // 에러 케이스
    mock_fs->simulate_io_errors = true;
    result = create_file(fm, "/test/file2.txt", "Data");
    assert(result == FS_ERROR_IO_ERROR);

    cleanup_file_manager(fm);
    cleanup_mock_filesystem(mock_fs);
}
```

## 마무리

파일 관리 시스템 개발을 통해 학습한 내용:

### 핵심 개념
- **계층적 구조**: 효율적인 디렉토리 관리와 네임스페이스
- **메타데이터 관리**: 파일 속성, 권한, 무결성 검증
- **검색과 인덱싱**: 빠른 파일 검색을 위한 자료구조
- **성능 최적화**: 캐싱, 버퍼링, 비동기 I/O

### 실무 역량
- **시스템 설계**: 확장 가능하고 유지보수 가능한 아키텍처
- **동시성 처리**: 멀티스레드 환경에서의 안전한 파일 접근
- **보안 구현**: 접근 제어, 암호화, 감사 추적
- **성능 튜닝**: 병목 지점 분석과 최적화 기법

이러한 지식을 바탕으로 실제 파일 관리 시스템을 구축하거나, 기존 시스템을 개선하는 데 활용할 수 있습니다.