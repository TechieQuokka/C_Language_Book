# 16.2 간단한 게임 제작

## 개념 정리

### 게임 프로그래밍의 기초

게임 개발은 **인터랙티브한 소프트웨어 설계**의 정수를 담고 있습니다. 실시간 상호작용, 상태 관리, 이벤트 처리, 그래픽 렌더링 등 프로그래밍의 핵심 개념들이 복합적으로 적용되는 영역입니다.

#### 게임 프로그래밍의 특징

**1. 실시간 처리 (Real-time Processing)**
- **게임 루프**: 지속적인 업데이트-렌더링 사이클
- **프레임률 관리**: 일정한 FPS(Frames Per Second) 유지
- **타이밍 제어**: 정확한 시간 기반 동작

**2. 상태 기반 설계 (State-driven Design)**
- **게임 상태**: 메뉴, 플레이, 일시정지, 게임오버 등
- **객체 상태**: 플레이어, 적, 아이템의 다양한 상태
- **상태 전이**: 조건에 따른 상태 변화 관리

**3. 이벤트 기반 프로그래밍 (Event-driven Programming)**
- **입력 처리**: 키보드, 마우스 이벤트 처리
- **충돌 감지**: 객체 간 상호작용 감지
- **게임 이벤트**: 점수 획득, 레벨 클리어 등

### 게임 아키텍처 기본 패턴

#### 1. 게임 루프 (Game Loop)

**기본 게임 루프 구조**
```c
typedef struct {
    int running;
    double last_time;
    double accumulator;
    const double dt; // 고정 타임스텝
} GameLoop;

void game_loop(GameLoop* loop) {
    double current_time = get_time();
    double frame_time = current_time - loop->last_time;
    loop->last_time = current_time;

    // 프레임 시간 제한 (스파이럴 오브 데스 방지)
    if (frame_time > 0.25) {
        frame_time = 0.25;
    }

    loop->accumulator += frame_time;

    // 고정 타임스텝 업데이트
    while (loop->accumulator >= loop->dt) {
        update_game(loop->dt);  // 물리/로직 업데이트
        loop->accumulator -= loop->dt;
    }

    // 보간된 렌더링
    render_game(loop->accumulator / loop->dt);
}
```

**타이밍 시스템**
```c
#include <time.h>

double get_time() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec + ts.tv_nsec / 1e9;
}

typedef struct {
    double start_time;
    double duration;
    int active;
} Timer;

int timer_elapsed(Timer* timer) {
    if (!timer->active) return 0;

    double current_time = get_time();
    return (current_time - timer->start_time) >= timer->duration;
}

void timer_start(Timer* timer, double duration) {
    timer->start_time = get_time();
    timer->duration = duration;
    timer->active = 1;
}
```

#### 2. 상태 기계 (State Machine)

**게임 상태 관리**
```c
typedef enum {
    GAME_STATE_MENU = 0,
    GAME_STATE_PLAYING,
    GAME_STATE_PAUSED,
    GAME_STATE_GAME_OVER,
    GAME_STATE_COUNT
} GameState;

typedef struct {
    void (*enter)(void);
    void (*update)(double dt);
    void (*render)(void);
    void (*exit)(void);
} StateHandler;

typedef struct {
    GameState current_state;
    GameState next_state;
    StateHandler handlers[GAME_STATE_COUNT];
    int state_change_requested;
} StateMachine;

void state_machine_update(StateMachine* sm, double dt) {
    // 상태 전이 처리
    if (sm->state_change_requested) {
        if (sm->handlers[sm->current_state].exit) {
            sm->handlers[sm->current_state].exit();
        }

        sm->current_state = sm->next_state;

        if (sm->handlers[sm->current_state].enter) {
            sm->handlers[sm->current_state].enter();
        }

        sm->state_change_requested = 0;
    }

    // 현재 상태 업데이트
    if (sm->handlers[sm->current_state].update) {
        sm->handlers[sm->current_state].update(dt);
    }
}

void change_state(StateMachine* sm, GameState new_state) {
    sm->next_state = new_state;
    sm->state_change_requested = 1;
}
```

#### 3. 엔티티-컴포넌트 시스템 (ECS 간소화 버전)

**기본 엔티티 시스템**
```c
#define MAX_ENTITIES 1000

typedef unsigned int EntityID;

typedef struct {
    float x, y;
    float dx, dy; // 속도
} Transform;

typedef struct {
    int health;
    int max_health;
} Health;

typedef struct {
    char sprite[32];
    int visible;
} Sprite;

typedef struct {
    Transform transforms[MAX_ENTITIES];
    Health healths[MAX_ENTITIES];
    Sprite sprites[MAX_ENTITIES];
    unsigned char component_masks[MAX_ENTITIES];
    EntityID next_entity_id;
} EntityManager;

// 컴포넌트 플래그
#define COMPONENT_TRANSFORM (1 << 0)
#define COMPONENT_HEALTH    (1 << 1)
#define COMPONENT_SPRITE    (1 << 2)

EntityID create_entity(EntityManager* em) {
    EntityID id = em->next_entity_id++;
    em->component_masks[id] = 0;
    return id;
}

void add_transform(EntityManager* em, EntityID id, float x, float y) {
    em->transforms[id].x = x;
    em->transforms[id].y = y;
    em->transforms[id].dx = 0;
    em->transforms[id].dy = 0;
    em->component_masks[id] |= COMPONENT_TRANSFORM;
}

int has_component(EntityManager* em, EntityID id, unsigned char component) {
    return (em->component_masks[id] & component) != 0;
}
```

## 주요 게임 장르별 구현

### 1. 텍스트 기반 어드벤처 게임

**핵심 개념**
- 명령어 파싱 시스템
- 룸 기반 월드 구조
- 인벤토리 및 아이템 시스템
- 대화 및 스토리 진행

**기본 구조**
```c
typedef struct Item {
    char name[32];
    char description[128];
    int usable;
    int takeable;
    struct Item* next;
} Item;

typedef struct Room {
    char name[64];
    char description[256];
    struct Room* north;
    struct Room* south;
    struct Room* east;
    struct Room* west;
    Item* items;
} Room;

typedef struct Player {
    Room* current_room;
    Item* inventory;
    int health;
    int score;
} Player;

typedef struct {
    char verb[16];
    char object[32];
    int valid;
} Command;

Command parse_command(const char* input) {
    Command cmd = {0};
    char* input_copy = strdup(input);
    char* token;

    // 소문자로 변환
    for (char* p = input_copy; *p; p++) {
        *p = tolower(*p);
    }

    // 첫 번째 단어 (동사)
    token = strtok(input_copy, " ");
    if (token) {
        strncpy(cmd.verb, token, sizeof(cmd.verb) - 1);

        // 두 번째 단어 (목적어)
        token = strtok(NULL, " ");
        if (token) {
            strncpy(cmd.object, token, sizeof(cmd.object) - 1);
        }
        cmd.valid = 1;
    }

    free(input_copy);
    return cmd;
}

void process_command(Player* player, const Command* cmd) {
    if (strcmp(cmd->verb, "go") == 0 || strcmp(cmd->verb, "move") == 0) {
        Room* next_room = NULL;

        if (strcmp(cmd->object, "north") == 0) {
            next_room = player->current_room->north;
        } else if (strcmp(cmd->object, "south") == 0) {
            next_room = player->current_room->south;
        } else if (strcmp(cmd->object, "east") == 0) {
            next_room = player->current_room->east;
        } else if (strcmp(cmd->object, "west") == 0) {
            next_room = player->current_room->west;
        }

        if (next_room) {
            player->current_room = next_room;
            printf("\n%s\n", next_room->description);
            describe_room(next_room);
        } else {
            printf("그 방향으로는 갈 수 없습니다.\n");
        }
    } else if (strcmp(cmd->verb, "look") == 0) {
        if (strlen(cmd->object) == 0) {
            // 룸 전체 관찰
            printf("%s\n", player->current_room->description);
            describe_room(player->current_room);
        } else {
            // 특정 아이템 관찰
            Item* item = find_item(player->current_room->items, cmd->object);
            if (item) {
                printf("%s\n", item->description);
            } else {
                printf("그런 것은 보이지 않습니다.\n");
            }
        }
    } else if (strcmp(cmd->verb, "take") == 0 || strcmp(cmd->verb, "get") == 0) {
        take_item(player, cmd->object);
    } else {
        printf("무슨 말인지 모르겠습니다.\n");
    }
}
```

### 2. 퍼즐 게임 (테트리스 스타일)

**핵심 개념**
- 격자 기반 게임판
- 블록 회전 및 이동
- 라인 클리어 로직
- 점수 및 레벨 시스템

**게임판 구조**
```c
#define BOARD_WIDTH 10
#define BOARD_HEIGHT 20
#define TETROMINO_SIZE 4

typedef enum {
    TETROMINO_I = 0,
    TETROMINO_O,
    TETROMINO_T,
    TETROMINO_S,
    TETROMINO_Z,
    TETROMINO_J,
    TETROMINO_L,
    TETROMINO_COUNT
} TetrominoType;

typedef struct {
    int blocks[TETROMINO_SIZE][TETROMINO_SIZE];
    int size;
    TetrominoType type;
} Tetromino;

typedef struct {
    int x, y;
    Tetromino shape;
    int rotation;
} FallingPiece;

typedef struct {
    int board[BOARD_HEIGHT][BOARD_WIDTH];
    FallingPiece current_piece;
    FallingPiece next_piece;
    int score;
    int level;
    int lines_cleared;
    double fall_timer;
    double fall_speed;
} TetrisGame;

// 테트로미노 정의 (I, O, T, S, Z, J, L)
const int tetromino_shapes[TETROMINO_COUNT][TETROMINO_SIZE][TETROMINO_SIZE] = {
    // I 블록
    {
        {0, 0, 0, 0},
        {1, 1, 1, 1},
        {0, 0, 0, 0},
        {0, 0, 0, 0}
    },
    // O 블록
    {
        {0, 0, 0, 0},
        {0, 1, 1, 0},
        {0, 1, 1, 0},
        {0, 0, 0, 0}
    },
    // T 블록
    {
        {0, 0, 0, 0},
        {0, 1, 0, 0},
        {1, 1, 1, 0},
        {0, 0, 0, 0}
    }
    // ... 나머지 블록들
};

int can_place_piece(TetrisGame* game, int x, int y, const Tetromino* piece) {
    for (int py = 0; py < TETROMINO_SIZE; py++) {
        for (int px = 0; px < TETROMINO_SIZE; px++) {
            if (piece->blocks[py][px]) {
                int board_x = x + px;
                int board_y = y + py;

                // 경계 검사
                if (board_x < 0 || board_x >= BOARD_WIDTH ||
                    board_y >= BOARD_HEIGHT) {
                    return 0;
                }

                // 충돌 검사 (y < 0은 게임판 위쪽이므로 허용)
                if (board_y >= 0 && game->board[board_y][board_x]) {
                    return 0;
                }
            }
        }
    }
    return 1;
}

void rotate_tetromino(Tetromino* piece) {
    int temp[TETROMINO_SIZE][TETROMINO_SIZE];

    // 90도 시계방향 회전
    for (int y = 0; y < TETROMINO_SIZE; y++) {
        for (int x = 0; x < TETROMINO_SIZE; x++) {
            temp[x][TETROMINO_SIZE - 1 - y] = piece->blocks[y][x];
        }
    }

    // 결과 복사
    memcpy(piece->blocks, temp, sizeof(temp));
}

int clear_full_lines(TetrisGame* game) {
    int lines_cleared = 0;

    for (int y = BOARD_HEIGHT - 1; y >= 0; y--) {
        int full_line = 1;

        // 라인이 가득 찼는지 확인
        for (int x = 0; x < BOARD_WIDTH; x++) {
            if (!game->board[y][x]) {
                full_line = 0;
                break;
            }
        }

        if (full_line) {
            // 라인 제거 및 위쪽 블록들 아래로 이동
            for (int move_y = y; move_y > 0; move_y--) {
                for (int x = 0; x < BOARD_WIDTH; x++) {
                    game->board[move_y][x] = game->board[move_y - 1][x];
                }
            }

            // 맨 위 라인 클리어
            for (int x = 0; x < BOARD_WIDTH; x++) {
                game->board[0][x] = 0;
            }

            lines_cleared++;
            y++; // 같은 위치 다시 검사
        }
    }

    return lines_cleared;
}
```

### 3. 아케이드 액션 게임 (스네이크)

**핵심 개념**
- 실시간 이동 제어
- 충돌 감지
- 점수 및 성장 시스템
- 게임 속도 조절

**스네이크 게임 구조**
```c
#define GRID_SIZE 20
#define MAX_SNAKE_LENGTH (GRID_SIZE * GRID_SIZE)

typedef enum {
    DIR_UP = 0,
    DIR_DOWN,
    DIR_LEFT,
    DIR_RIGHT
} Direction;

typedef struct {
    int x, y;
} Point;

typedef struct {
    Point segments[MAX_SNAKE_LENGTH];
    int length;
    Direction direction;
    Direction next_direction; // 입력 버퍼링
} Snake;

typedef struct {
    Point position;
    int active;
} Food;

typedef struct {
    Snake snake;
    Food food;
    int score;
    int game_over;
    double move_timer;
    double move_interval;
} SnakeGame;

void init_snake_game(SnakeGame* game) {
    // 뱀 초기화 (중앙에서 시작)
    game->snake.length = 3;
    game->snake.direction = DIR_RIGHT;
    game->snake.next_direction = DIR_RIGHT;

    for (int i = 0; i < game->snake.length; i++) {
        game->snake.segments[i].x = GRID_SIZE / 2 - i;
        game->snake.segments[i].y = GRID_SIZE / 2;
    }

    // 음식 생성
    spawn_food(game);

    game->score = 0;
    game->game_over = 0;
    game->move_timer = 0;
    game->move_interval = 0.2; // 초기 속도
}

void update_snake(SnakeGame* game, double dt) {
    if (game->game_over) return;

    game->move_timer += dt;

    if (game->move_timer >= game->move_interval) {
        game->move_timer = 0;

        // 방향 변경 (180도 회전 불가)
        if (!is_opposite_direction(game->snake.direction,
                                  game->snake.next_direction)) {
            game->snake.direction = game->snake.next_direction;
        }

        // 새로운 머리 위치 계산
        Point new_head = game->snake.segments[0];

        switch (game->snake.direction) {
            case DIR_UP:    new_head.y--; break;
            case DIR_DOWN:  new_head.y++; break;
            case DIR_LEFT:  new_head.x--; break;
            case DIR_RIGHT: new_head.x++; break;
        }

        // 벽 충돌 검사
        if (new_head.x < 0 || new_head.x >= GRID_SIZE ||
            new_head.y < 0 || new_head.y >= GRID_SIZE) {
            game->game_over = 1;
            return;
        }

        // 자기 몸과 충돌 검사
        for (int i = 0; i < game->snake.length; i++) {
            if (new_head.x == game->snake.segments[i].x &&
                new_head.y == game->snake.segments[i].y) {
                game->game_over = 1;
                return;
            }
        }

        // 음식 섭취 검사
        int ate_food = (new_head.x == game->food.position.x &&
                       new_head.y == game->food.position.y);

        // 뱀 이동
        if (!ate_food) {
            // 꼬리 제거 (길이 유지)
            for (int i = game->snake.length - 1; i > 0; i--) {
                game->snake.segments[i] = game->snake.segments[i - 1];
            }
        } else {
            // 뱀 길이 증가
            for (int i = game->snake.length; i > 0; i--) {
                game->snake.segments[i] = game->snake.segments[i - 1];
            }
            game->snake.length++;

            // 점수 및 속도 증가
            game->score += 10;
            if (game->move_interval > 0.05) {
                game->move_interval *= 0.95; // 5% 빨라짐
            }

            // 새 음식 생성
            spawn_food(game);
        }

        // 새 머리 위치 설정
        game->snake.segments[0] = new_head;
    }
}

void spawn_food(SnakeGame* game) {
    Point candidates[GRID_SIZE * GRID_SIZE];
    int candidate_count = 0;

    // 뱀이 없는 위치 찾기
    for (int y = 0; y < GRID_SIZE; y++) {
        for (int x = 0; x < GRID_SIZE; x++) {
            int occupied = 0;

            for (int i = 0; i < game->snake.length; i++) {
                if (game->snake.segments[i].x == x &&
                    game->snake.segments[i].y == y) {
                    occupied = 1;
                    break;
                }
            }

            if (!occupied) {
                candidates[candidate_count].x = x;
                candidates[candidate_count].y = y;
                candidate_count++;
            }
        }
    }

    if (candidate_count > 0) {
        int index = rand() % candidate_count;
        game->food.position = candidates[index];
        game->food.active = 1;
    }
}
```

### 4. 턴 기반 전략 게임 (틱택토 확장)

**핵심 개념**
- 턴 기반 게임플레이
- AI 상대 구현
- 게임 트리 탐색
- 승부 판정 로직

**미니맥스 알고리즘 구현**
```c
#define BOARD_SIZE 3
#define EMPTY 0
#define PLAYER_X 1
#define PLAYER_O 2

typedef struct {
    int board[BOARD_SIZE][BOARD_SIZE];
    int current_player;
    int game_over;
    int winner;
} TicTacToe;

int evaluate_board(TicTacToe* game) {
    // 행 검사
    for (int row = 0; row < BOARD_SIZE; row++) {
        if (game->board[row][0] == game->board[row][1] &&
            game->board[row][1] == game->board[row][2] &&
            game->board[row][0] != EMPTY) {
            return game->board[row][0] == PLAYER_X ? 10 : -10;
        }
    }

    // 열 검사
    for (int col = 0; col < BOARD_SIZE; col++) {
        if (game->board[0][col] == game->board[1][col] &&
            game->board[1][col] == game->board[2][col] &&
            game->board[0][col] != EMPTY) {
            return game->board[0][col] == PLAYER_X ? 10 : -10;
        }
    }

    // 대각선 검사
    if (game->board[0][0] == game->board[1][1] &&
        game->board[1][1] == game->board[2][2] &&
        game->board[0][0] != EMPTY) {
        return game->board[0][0] == PLAYER_X ? 10 : -10;
    }

    if (game->board[0][2] == game->board[1][1] &&
        game->board[1][1] == game->board[2][0] &&
        game->board[0][2] != EMPTY) {
        return game->board[0][2] == PLAYER_X ? 10 : -10;
    }

    return 0; // 무승부 또는 게임 진행 중
}

int is_board_full(TicTacToe* game) {
    for (int row = 0; row < BOARD_SIZE; row++) {
        for (int col = 0; col < BOARD_SIZE; col++) {
            if (game->board[row][col] == EMPTY) {
                return 0;
            }
        }
    }
    return 1;
}

int minimax(TicTacToe* game, int depth, int is_maximizing) {
    int score = evaluate_board(game);

    // 게임 종료 조건
    if (score != 0) return score;
    if (is_board_full(game)) return 0;

    if (is_maximizing) {
        int best_score = -1000;

        for (int row = 0; row < BOARD_SIZE; row++) {
            for (int col = 0; col < BOARD_SIZE; col++) {
                if (game->board[row][col] == EMPTY) {
                    game->board[row][col] = PLAYER_X;
                    int current_score = minimax(game, depth + 1, 0);
                    game->board[row][col] = EMPTY;

                    if (current_score > best_score) {
                        best_score = current_score;
                    }
                }
            }
        }
        return best_score;
    } else {
        int best_score = 1000;

        for (int row = 0; row < BOARD_SIZE; row++) {
            for (int col = 0; col < BOARD_SIZE; col++) {
                if (game->board[row][col] == EMPTY) {
                    game->board[row][col] = PLAYER_O;
                    int current_score = minimax(game, depth + 1, 1);
                    game->board[row][col] = EMPTY;

                    if (current_score < best_score) {
                        best_score = current_score;
                    }
                }
            }
        }
        return best_score;
    }
}

void ai_make_move(TicTacToe* game) {
    int best_score = -1000;
    int best_row = -1, best_col = -1;

    for (int row = 0; row < BOARD_SIZE; row++) {
        for (int col = 0; col < BOARD_SIZE; col++) {
            if (game->board[row][col] == EMPTY) {
                game->board[row][col] = PLAYER_X;
                int score = minimax(game, 0, 0);
                game->board[row][col] = EMPTY;

                if (score > best_score) {
                    best_score = score;
                    best_row = row;
                    best_col = col;
                }
            }
        }
    }

    if (best_row != -1 && best_col != -1) {
        game->board[best_row][best_col] = PLAYER_X;
    }
}
```

## 게임 시스템 설계 패턴

### 1. 이벤트 시스템

**게임 이벤트 관리**
```c
typedef enum {
    EVENT_PLAYER_DIED,
    EVENT_SCORE_CHANGED,
    EVENT_LEVEL_COMPLETED,
    EVENT_ITEM_COLLECTED,
    EVENT_COUNT
} EventType;

typedef struct {
    EventType type;
    void* data;
    size_t data_size;
} GameEvent;

typedef struct {
    void (*handler)(const GameEvent* event);
} EventListener;

typedef struct {
    EventListener listeners[EVENT_COUNT][10]; // 최대 10개 리스너
    int listener_counts[EVENT_COUNT];
} EventSystem;

void register_event_listener(EventSystem* es, EventType type,
                            void (*handler)(const GameEvent*)) {
    if (es->listener_counts[type] < 10) {
        es->listeners[type][es->listener_counts[type]].handler = handler;
        es->listener_counts[type]++;
    }
}

void trigger_event(EventSystem* es, EventType type, void* data, size_t size) {
    GameEvent event = {type, data, size};

    for (int i = 0; i < es->listener_counts[type]; i++) {
        if (es->listeners[type][i].handler) {
            es->listeners[type][i].handler(&event);
        }
    }
}

// 사용 예시
void on_score_changed(const GameEvent* event) {
    int* new_score = (int*)event->data;
    printf("Score: %d\n", *new_score);

    // UI 업데이트, 효과 재생 등
}
```

### 2. 리소스 관리 시스템

**게임 애셋 관리**
```c
typedef enum {
    RESOURCE_TEXTURE,
    RESOURCE_SOUND,
    RESOURCE_MUSIC,
    RESOURCE_FONT
} ResourceType;

typedef struct {
    char filename[256];
    ResourceType type;
    void* data;
    size_t size;
    int ref_count;
} Resource;

typedef struct {
    Resource resources[100];
    int resource_count;
} ResourceManager;

Resource* load_resource(ResourceManager* rm, const char* filename,
                       ResourceType type) {
    // 이미 로드된 리소스 검색
    for (int i = 0; i < rm->resource_count; i++) {
        if (strcmp(rm->resources[i].filename, filename) == 0) {
            rm->resources[i].ref_count++;
            return &rm->resources[i];
        }
    }

    // 새 리소스 로드
    if (rm->resource_count < 100) {
        Resource* res = &rm->resources[rm->resource_count];
        strncpy(res->filename, filename, sizeof(res->filename) - 1);
        res->type = type;
        res->ref_count = 1;

        // 타입에 따른 로딩
        switch (type) {
            case RESOURCE_TEXTURE:
                res->data = load_texture_file(filename);
                break;
            case RESOURCE_SOUND:
                res->data = load_sound_file(filename);
                break;
            // ... 다른 타입들
        }

        rm->resource_count++;
        return res;
    }

    return NULL;
}

void release_resource(ResourceManager* rm, Resource* resource) {
    resource->ref_count--;

    if (resource->ref_count <= 0) {
        // 리소스 해제
        free_resource_data(resource);

        // 배열에서 제거 (간단한 구현)
        int index = resource - rm->resources;
        for (int i = index; i < rm->resource_count - 1; i++) {
            rm->resources[i] = rm->resources[i + 1];
        }
        rm->resource_count--;
    }
}
```

### 3. 입력 처리 시스템

**키보드/마우스 입력 관리**
```c
#define MAX_KEYS 256

typedef struct {
    int current_state[MAX_KEYS];
    int previous_state[MAX_KEYS];
} InputState;

typedef struct {
    int x, y;
    int buttons; // 비트마스크
    int wheel_delta;
} MouseState;

typedef struct {
    InputState keyboard;
    MouseState mouse;
    MouseState prev_mouse;
} InputManager;

void update_input(InputManager* input) {
    // 이전 상태 저장
    memcpy(input->keyboard.previous_state,
           input->keyboard.current_state,
           sizeof(input->keyboard.current_state));

    input->prev_mouse = input->mouse;

    // 현재 상태 읽기 (플랫폼 의존적)
    read_keyboard_state(input->keyboard.current_state);
    read_mouse_state(&input->mouse);
}

int is_key_pressed(InputManager* input, int key) {
    return input->keyboard.current_state[key] &&
           !input->keyboard.previous_state[key];
}

int is_key_held(InputManager* input, int key) {
    return input->keyboard.current_state[key];
}

int is_key_released(InputManager* input, int key) {
    return !input->keyboard.current_state[key] &&
           input->keyboard.previous_state[key];
}
```

## 성능 최적화 및 고급 기법

### 1. 객체 풀링 (Object Pooling)

**총알, 파티클 등 대량 객체 관리**
```c
#define BULLET_POOL_SIZE 100

typedef struct {
    float x, y;
    float dx, dy;
    int active;
    double lifetime;
} Bullet;

typedef struct {
    Bullet bullets[BULLET_POOL_SIZE];
    int next_index;
} BulletPool;

Bullet* get_bullet(BulletPool* pool) {
    for (int i = 0; i < BULLET_POOL_SIZE; i++) {
        int index = (pool->next_index + i) % BULLET_POOL_SIZE;
        if (!pool->bullets[index].active) {
            pool->next_index = (index + 1) % BULLET_POOL_SIZE;
            return &pool->bullets[index];
        }
    }
    return NULL; // 풀이 가득 참
}

void return_bullet(BulletPool* pool, Bullet* bullet) {
    bullet->active = 0;
}

void update_bullets(BulletPool* pool, double dt) {
    for (int i = 0; i < BULLET_POOL_SIZE; i++) {
        Bullet* bullet = &pool->bullets[i];
        if (bullet->active) {
            bullet->x += bullet->dx * dt;
            bullet->y += bullet->dy * dt;
            bullet->lifetime -= dt;

            if (bullet->lifetime <= 0) {
                return_bullet(pool, bullet);
            }
        }
    }
}
```

### 2. 공간 분할 (Spatial Partitioning)

**효율적인 충돌 감지**
```c
#define GRID_SIZE 32
#define GRID_WIDTH 25
#define GRID_HEIGHT 25

typedef struct GridCell {
    EntityID entities[10];
    int count;
} GridCell;

typedef struct {
    GridCell cells[GRID_HEIGHT][GRID_WIDTH];
} SpatialGrid;

void add_to_grid(SpatialGrid* grid, EntityID entity, float x, float y) {
    int grid_x = (int)(x / GRID_SIZE);
    int grid_y = (int)(y / GRID_SIZE);

    if (grid_x >= 0 && grid_x < GRID_WIDTH &&
        grid_y >= 0 && grid_y < GRID_HEIGHT) {
        GridCell* cell = &grid->cells[grid_y][grid_x];
        if (cell->count < 10) {
            cell->entities[cell->count++] = entity;
        }
    }
}

void check_collisions_in_cell(SpatialGrid* grid, int grid_x, int grid_y,
                              EntityManager* em) {
    if (grid_x < 0 || grid_x >= GRID_WIDTH ||
        grid_y < 0 || grid_y >= GRID_HEIGHT) return;

    GridCell* cell = &grid->cells[grid_y][grid_x];

    for (int i = 0; i < cell->count; i++) {
        for (int j = i + 1; j < cell->count; j++) {
            EntityID a = cell->entities[i];
            EntityID b = cell->entities[j];

            if (check_collision(em, a, b)) {
                handle_collision(a, b);
            }
        }
    }
}
```

## 크로스 플랫폼 고려사항

### 1. 플랫폼 추상화 레이어

**그래픽 및 입력 추상화**
```c
typedef struct {
    void (*init)(int width, int height);
    void (*clear)(unsigned int color);
    void (*draw_pixel)(int x, int y, unsigned int color);
    void (*draw_text)(int x, int y, const char* text);
    void (*present)(void);
    void (*cleanup)(void);
} GraphicsAPI;

typedef struct {
    void (*init)(void);
    int (*get_key_state)(int key);
    void (*get_mouse_state)(int* x, int* y, int* buttons);
    void (*cleanup)(void);
} InputAPI;

// 플랫폼별 구현 선택
#ifdef _WIN32
    extern GraphicsAPI win32_graphics;
    extern InputAPI win32_input;
    #define GRAPHICS_API win32_graphics
    #define INPUT_API win32_input
#elif defined(__linux__)
    extern GraphicsAPI linux_graphics;
    extern InputAPI linux_input;
    #define GRAPHICS_API linux_graphics
    #define INPUT_API linux_input
#endif
```

### 2. 빌드 시스템 구성

**Makefile 예시**
```makefile
CC = gcc
CFLAGS = -std=c99 -Wall -Wextra -O2
LIBS =

# 플랫폼별 설정
ifeq ($(OS),Windows_NT)
    LIBS += -lgdi32 -luser32
    TARGET = game.exe
else
    UNAME_S := $(shell uname -s)
    ifeq ($(UNAME_S),Linux)
        LIBS += -lX11 -lm
    endif
    TARGET = game
endif

SRCDIR = src
OBJDIR = obj
SOURCES = $(wildcard $(SRCDIR)/*.c)
OBJECTS = $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o)

$(TARGET): $(OBJECTS)
	$(CC) $(OBJECTS) -o $@ $(LIBS)

$(OBJDIR)/%.o: $(SRCDIR)/%.c
	@mkdir -p $(OBJDIR)
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -rf $(OBJDIR) $(TARGET)

.PHONY: clean
```

게임 제작은 **창의성과 기술적 도전**이 결합된 흥미로운 프로젝트입니다. 작은 규모부터 시작하여 점진적으로 복잡한 시스템을 구축해나가면서 프로그래밍 실력을 체계적으로 향상시킬 수 있습니다.