# 11.2 포인터 배열 (Array of Pointers)

## 핵심 개념: 집합과 참조의 만남

포인터 배열은 **"참조들의 집합"**입니다. 이는 단순히 포인터를 배열로 나열한 것이 아니라, **서로 다른 메모리 위치에 있는 데이터들을 하나의 논리적 구조로 관리**하는 강력한 방법입니다.

### 철학적 관점: 통합과 분산의 조화

일반적인 배열은 **동질적이고 연속적**입니다. 모든 원소가 같은 타입이고, 메모리상에 연속으로 배치됩니다. 반면 포인터 배열은:

- **이질적 가능성**: 가리키는 데이터들이 서로 다른 크기, 다른 위치에 있을 수 있습니다
- **유연한 구조**: 런타임에 가리키는 대상을 변경할 수 있습니다
- **효율적 관리**: 큰 데이터를 복사하지 않고 참조로만 관리합니다

## 배열의 포인터 vs 포인터 배열: 의미의 차이

### 문법적 차이와 개념적 차이

```c
int *ptr_array[5];    // 포인터 배열: 5개의 포인터로 구성된 배열
int (*array_ptr)[5];  // 배열의 포인터: 5개 원소 배열을 가리키는 포인터
```

**핵심 통찰**:
- `int *ptr_array[5]`는 **"다섯 개의 방향을 가리키는 나침반들"**입니다
- `int (*array_ptr)[5]`는 **"하나의 큰 방향을 가리키는 나침반"**입니다

### 메모리 레이아웃의 철학

**포인터 배열**:
```
ptr_array[0] ──→ [데이터A] (어딘가)
ptr_array[1] ──→ [데이터B] (다른 곳)
ptr_array[2] ──→ [데이터C] (또 다른 곳)
```

**배열의 포인터**:
```
array_ptr ──→ [데이터1][데이터2][데이터3][데이터4][데이터5]
```

이는 **중앙집권 vs 연방제**의 차이와 같습니다.

## 문자열 관리에서의 혁명적 의미

### 전통적 2차원 배열의 한계

```c
char names[3][20] = {"Alice", "Bob", "Charlie"};
```

이 방식은:
- **공간 낭비**: "Bob"은 3글자이지만 20바이트를 차지합니다
- **크기 제한**: 20자보다 긴 이름은 저장할 수 없습니다
- **경직성**: 컴파일 시점에 모든 것이 결정됩니다

### 포인터 배열의 혁신

```c
char *names[] = {"Alice", "Bob", "Charlie"};
```

이는:
- **효율성**: 각 문자열이 필요한 만큼만 메모리를 사용합니다
- **유연성**: 다양한 길이의 문자열을 저장할 수 있습니다
- **동적성**: 런타임에 가리키는 문자열을 변경할 수 있습니다

**개념적 의미**: 문자열들의 **카탈로그**를 만드는 것입니다. 실제 책들은 도서관 곳곳에 있지만, 카탈로그를 통해 쉽게 찾을 수 있습니다.

## 함수 포인터 배열: 동작의 추상화

### 함수형 프로그래밍의 맛보기

```c
int (*operations[])(int, int) = {add, subtract, multiply, divide};
```

이는 C언어에서 **고차 함수**의 개념을 구현하는 방법입니다:

- **동작의 데이터화**: 함수를 데이터처럼 다룰 수 있습니다
- **전략 패턴**: 상황에 따라 다른 알고리즘을 선택할 수 있습니다
- **플러그인 아키텍처**: 기능을 모듈화하고 교체 가능하게 만듭니다

### 상태 기계(State Machine)의 구현

함수 포인터 배열은 상태 기계를 구현하는 우아한 방법을 제공합니다:

```c
typedef enum {STATE_IDLE, STATE_RUNNING, STATE_STOPPED} State;
void (*state_handlers[])(void) = {handle_idle, handle_running, handle_stopped};

State current_state = STATE_IDLE;
state_handlers[current_state]();  // 현재 상태에 맞는 핸들러 호출
```

**철학적 의미**: 이는 **"상태에 따른 행동의 변화"**를 코드로 표현하는 방법입니다.

## 메모리 관리의 새로운 패러다임

### 소유권과 생명주기

포인터 배열에서는 **소유권**이 중요합니다:

1. **참조만 하는 경우**: 포인터 배열은 다른 곳의 데이터를 가리킬 뿐입니다
2. **소유하는 경우**: 포인터 배열이 가리키는 메모리를 관리해야 합니다

```c
// 참조 모델
char *static_names[] = {"Alice", "Bob"};  // 문자열 리터럴 참조

// 소유 모델
char **dynamic_names = malloc(2 * sizeof(char*));
dynamic_names[0] = malloc(strlen("Alice") + 1);
strcpy(dynamic_names[0], "Alice");
```

### 계층적 메모리 해제

포인터 배열을 동적으로 사용할 때는 **계층적 해제**가 필요합니다:

1. 먼저 각 포인터가 가리키는 메모리를 해제
2. 그 다음 포인터 배열 자체를 해제

**개념적 이해**: 이는 **"참고문헌을 먼저 정리하고, 그 다음 목록을 정리하는"** 것과 같습니다.

## 추상화의 계층

### 데이터 추상화

포인터 배열은 **데이터 추상화**의 강력한 도구입니다:

```c
// 다양한 타입의 도형들을 관리
typedef struct {
    char *name;
    double (*area)(void *shape);
    void *data;
} Shape;

Shape shapes[] = {
    {"Circle", circle_area, &my_circle},
    {"Rectangle", rectangle_area, &my_rect}
};
```

### 인터페이스의 통일

서로 다른 구현들을 **동일한 인터페이스**로 접근할 수 있게 해줍니다:

```c
// 모든 도형의 면적을 같은 방식으로 계산
for (int i = 0; i < shape_count; i++) {
    printf("%s area: %.2f\n", shapes[i].name,
           shapes[i].area(shapes[i].data));
}
```

**철학적 의미**: 이는 **"다양성 속의 통일성"**을 구현하는 방법입니다.

## 성능과 메모리 효율성

### 캐시 친화성 vs 메모리 효율성

**포인터 배열의 특성**:
- ✅ **메모리 효율적**: 필요한 만큼만 할당
- ✅ **유연함**: 크기가 다른 데이터 처리 가능
- ❌ **캐시 비친화적**: 데이터가 메모리상에 분산됨

**일반 배열의 특성**:
- ✅ **캐시 친화적**: 데이터가 연속적으로 배치됨
- ❌ **메모리 낭비 가능**: 고정 크기로 인한 공간 낭비
- ❌ **경직성**: 크기 변경 어려움

### 선택의 기준

**포인터 배열을 선택해야 할 때**:
- 데이터 크기가 매우 다양할 때
- 런타임에 구조를 자주 변경해야 할 때
- 메모리 사용량이 중요할 때

**일반 배열을 선택해야 할 때**:
- 성능이 최우선일 때
- 데이터 크기가 비슷할 때
- 구조가 정적일 때

## 디자인 패턴과의 연관성

### 전략 패턴 (Strategy Pattern)

```c
typedef struct {
    char *name;
    int (*compress)(void *data, size_t size);
} CompressionStrategy;

CompressionStrategy strategies[] = {
    {"LZ77", lz77_compress},
    {"Huffman", huffman_compress},
    {"Run-Length", rle_compress}
};
```

### 팩토리 패턴 (Factory Pattern)

```c
typedef struct {
    char *type;
    void* (*create)(void);
} Factory;

Factory factories[] = {
    {"Button", create_button},
    {"Label", create_label},
    {"TextBox", create_textbox}
};
```

## 마무리: 포인터 배열의 철학

포인터 배열은 단순한 데이터 구조가 아닙니다. 그것은:

1. **유연성의 구현**: 고정된 구조에서 동적 구조로의 진화
2. **추상화의 도구**: 다양한 구현을 통일된 인터페이스로 관리
3. **효율성의 추구**: 메모리와 시간의 최적화
4. **설계의 기반**: 고급 디자인 패턴의 토대

**핵심 통찰**: 포인터 배열을 이해하는 것은 **"집합과 개별성", "통일성과 다양성", "효율성과 유연성"** 사이의 균형을 이해하는 것입니다.

이는 프로그래밍에서 **"어떻게 다양한 것들을 하나로 묶어서 관리할 것인가"**라는 근본적인 질문에 대한 C언어의 답변입니다.