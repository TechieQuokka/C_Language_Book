# 12.3 모듈화 프로그래밍

## 핵심 개념: 복잡성을 다루는 인간의 지혜

모듈화 프로그래밍은 단순히 **"코드를 여러 파일로 나누는 것"**이 아닙니다. 이는 **"복잡성을 인간이 이해할 수 있는 단위로 분해하는"** 소프트웨어 공학의 핵심 전략입니다. 이는 **"분할 정복(Divide and Conquer)"**의 소프트웨어적 구현이며, **"관심사의 분리(Separation of Concerns)"**라는 설계 원칙의 실현입니다.

### 인지적 한계와 추상화의 필요성

인간의 **작업 기억(Working Memory)**은 한계가 있습니다. 심리학 연구에 따르면 우리는 동시에 **7±2개**의 개념만 효과적으로 다룰 수 있습니다. 따라서:

- **모듈화 없는 프로그램**: 수천 줄의 코드를 동시에 이해해야 함
- **모듈화된 프로그램**: 각 모듈을 독립적으로 이해 가능

**철학적 의미**: 모듈화는 **"인간의 인지적 한계를 소프트웨어 구조로 극복하는 방법"**입니다.

## 모듈화의 기본 원칙

### 1. 높은 응집도 (High Cohesion)

**응집도**는 모듈 내부 요소들이 **얼마나 밀접하게 관련**되어 있는지를 나타냅니다.

```c
// 높은 응집도 - 모든 함수가 문자열 처리에 집중
// string_utils.h
int string_length(const char* str);
char* string_copy(const char* src);
int string_compare(const char* s1, const char* s2);
char* string_concatenate(const char* s1, const char* s2);
```

**좋은 응집도의 특징**:
- **기능적 응집**: 하나의 명확한 작업 수행
- **순차적 응집**: 데이터 흐름이 자연스러움
- **통신적 응집**: 같은 데이터를 조작

### 2. 낮은 결합도 (Low Coupling)

**결합도**는 모듈 간의 **상호 의존성 정도**를 나타냅니다.

```c
// 낮은 결합도 - 인터페이스를 통한 의존
// logger.h
typedef struct Logger Logger;

Logger* logger_create(const char* filename);
void logger_info(Logger* logger, const char* message);
void logger_error(Logger* logger, const char* message);
void logger_destroy(Logger* logger);

// main.c - 구현 세부사항을 모름
Logger* log = logger_create("app.log");
logger_info(log, "Application started");
```

**낮은 결합도의 이점**:
- **독립성**: 한 모듈 변경이 다른 모듈에 최소 영향
- **테스트 용이성**: 모듈별 독립 테스트 가능
- **재사용성**: 다른 프로젝트에서 쉽게 재사용

### 3. 정보 은닉 (Information Hiding)

**구현 세부사항**을 숨기고 **인터페이스**만 노출합니다.

```c
// stack.h - 공개 인터페이스
typedef struct Stack Stack;

Stack* stack_create(void);
int stack_push(Stack* s, int value);
int stack_pop(Stack* s, int* value);
bool stack_is_empty(Stack* s);
void stack_destroy(Stack* s);

// stack.c - 비공개 구현
struct Stack {
    int* data;
    int top;
    int capacity;
};
```

**정보 은닉의 가치**:
- **변경 유연성**: 내부 구현 변경이 외부에 영향 없음
- **복잡성 관리**: 사용자는 간단한 인터페이스만 이해
- **오류 방지**: 직접적인 내부 접근 차단

## 모듈 설계 패턴

### 1. 계층적 구조 (Layered Architecture)

```
┌─────────────────┐
│   Application   │  ← 비즈니스 로직
├─────────────────┤
│    Services     │  ← 도메인 서비스
├─────────────────┤
│  Data Access    │  ← 데이터 접근
├─────────────────┤
│   Utilities     │  ← 기본 유틸리티
└─────────────────┘
```

**특징**:
- **상위 계층**은 하위 계층에만 의존
- **순환 의존성** 방지
- **관심사의 명확한 분리**

### 2. MVC 패턴 (Model-View-Controller)

```c
// model.h - 데이터와 비즈니스 로직
typedef struct User {
    char name[50];
    int age;
    char email[100];
} User;

int user_save(User* user);
User* user_load(int user_id);

// view.h - 사용자 인터페이스
void display_user(const User* user);
void display_error(const char* message);

// controller.h - 제어 로직
void handle_user_registration(void);
void handle_user_login(void);
```

**관심사 분리**:
- **Model**: 데이터와 규칙
- **View**: 표현과 사용자 인터페이스
- **Controller**: 사용자 입력과 흐름 제어

### 3. 팩토리 패턴 (Factory Pattern)

```c
// shape.h - 추상 인터페이스
typedef struct Shape Shape;
typedef struct ShapeOps {
    double (*area)(const Shape* shape);
    void (*draw)(const Shape* shape);
    void (*destroy)(Shape* shape);
} ShapeOps;

// shape_factory.h - 팩토리
Shape* create_circle(double radius);
Shape* create_rectangle(double width, double height);
```

**장점**:
- **객체 생성 로직** 중앙화
- **타입별 특수화** 가능
- **확장성** 제공

## 모듈 간 통신 메커니즘

### 1. 직접 함수 호출

```c
// 가장 간단한 형태
#include "math_utils.h"

int result = calculate_distance(x1, y1, x2, y2);
```

**특징**: 간단하지만 **강한 결합** 발생

### 2. 콜백 함수

```c
// event_system.h
typedef void (*EventCallback)(int event_type, void* data);

void register_callback(int event_type, EventCallback callback);
void trigger_event(int event_type, void* data);

// 사용
void on_button_click(int event_type, void* data) {
    printf("Button clicked!\n");
}

register_callback(EVENT_BUTTON_CLICK, on_button_click);
```

**장점**: **느슨한 결합**, **역전된 제어**

### 3. 메시지 큐

```c
// message_queue.h
typedef struct Message {
    int type;
    void* data;
    size_t data_size;
} Message;

typedef struct MessageQueue MessageQueue;

MessageQueue* mq_create(void);
int mq_send(MessageQueue* mq, const Message* msg);
int mq_receive(MessageQueue* mq, Message* msg);
```

**장점**: **비동기 통신**, **버퍼링**, **디커플링**

## 오류 처리의 모듈화

### 일관된 오류 처리 전략

```c
// error_handling.h
typedef enum {
    ERROR_SUCCESS = 0,
    ERROR_INVALID_ARGUMENT = -1,
    ERROR_OUT_OF_MEMORY = -2,
    ERROR_FILE_NOT_FOUND = -3,
    ERROR_NETWORK_ERROR = -4
} ErrorCode;

typedef struct {
    ErrorCode code;
    char message[256];
    char function[64];
    int line;
} ErrorInfo;

// 글로벌 오류 상태
ErrorInfo* get_last_error(void);
void set_error(ErrorCode code, const char* message,
               const char* function, int line);

#define SET_ERROR(code, msg) \
    set_error(code, msg, __FUNCTION__, __LINE__)
```

### 모듈별 오류 도메인

```c
// file_module.h
#define FILE_ERROR_BASE 1000
typedef enum {
    FILE_ERROR_NOT_FOUND = FILE_ERROR_BASE + 1,
    FILE_ERROR_PERMISSION_DENIED = FILE_ERROR_BASE + 2,
    FILE_ERROR_DISK_FULL = FILE_ERROR_BASE + 3
} FileError;

// network_module.h
#define NETWORK_ERROR_BASE 2000
typedef enum {
    NETWORK_ERROR_CONNECTION_FAILED = NETWORK_ERROR_BASE + 1,
    NETWORK_ERROR_TIMEOUT = NETWORK_ERROR_BASE + 2,
    NETWORK_ERROR_PROTOCOL_ERROR = NETWORK_ERROR_BASE + 3
} NetworkError;
```

## 리소스 관리의 모듈화

### RAII 패턴의 C 구현

```c
// resource_manager.h
typedef struct Resource Resource;

Resource* resource_acquire(const char* name);
void resource_release(Resource* resource);

// 자동 정리를 위한 스코프 가드
#define WITH_RESOURCE(name, var) \
    for (Resource* var = resource_acquire(name); \
         var != NULL; \
         resource_release(var), var = NULL)

// 사용
WITH_RESOURCE("config_file", file) {
    // 파일 사용
    // 스코프를 벗어나면 자동으로 resource_release 호출
}
```

### 메모리 풀 모듈

```c
// memory_pool.h
typedef struct MemoryPool MemoryPool;

MemoryPool* pool_create(size_t block_size, size_t initial_blocks);
void* pool_allocate(MemoryPool* pool);
void pool_deallocate(MemoryPool* pool, void* ptr);
void pool_destroy(MemoryPool* pool);

// 특정 타입을 위한 매크로
#define DECLARE_POOL(type) \
    MemoryPool* type##_pool_create(size_t initial_blocks); \
    type* type##_allocate(void); \
    void type##_deallocate(type* obj);
```

## 설정과 초기화의 모듈화

### 설정 모듈

```c
// config.h
typedef struct Config Config;

Config* config_load(const char* filename);
const char* config_get_string(Config* cfg, const char* key, const char* default_val);
int config_get_int(Config* cfg, const char* key, int default_val);
double config_get_double(Config* cfg, const char* key, double default_val);
void config_destroy(Config* cfg);

// 전역 설정 관리
Config* get_global_config(void);
int init_global_config(const char* filename);
void cleanup_global_config(void);
```

### 초기화 시퀀스 관리

```c
// initialization.h
typedef int (*InitFunction)(void);
typedef void (*CleanupFunction)(void);

typedef struct InitModule {
    const char* name;
    InitFunction init;
    CleanupFunction cleanup;
    int priority;  // 낮을수록 먼저 초기화
} InitModule;

int register_init_module(const InitModule* module);
int initialize_all_modules(void);
void cleanup_all_modules(void);

// 사용 예
static int database_init(void) { /* ... */ return 0; }
static void database_cleanup(void) { /* ... */ }

InitModule db_module = {
    .name = "database",
    .init = database_init,
    .cleanup = database_cleanup,
    .priority = 1
};
```

## 테스트와 모듈화

### 테스트 가능한 모듈 설계

```c
// calculator.h
#ifdef TESTING
    // 테스트 시에만 내부 함수 노출
    int internal_validate_input(int value);
    double internal_complex_calculation(double x, double y);
#endif

// 의존성 주입을 위한 인터페이스
typedef struct CalculatorDeps {
    double (*sin_func)(double);
    double (*cos_func)(double);
    void (*log_func)(const char*);
} CalculatorDeps;

void calculator_set_dependencies(const CalculatorDeps* deps);
```

### 모킹 인터페이스

```c
// file_system.h - 추상 인터페이스
typedef struct FileSystemOps {
    int (*open)(const char* filename, const char* mode);
    int (*read)(int fd, void* buffer, size_t size);
    int (*write)(int fd, const void* buffer, size_t size);
    void (*close)(int fd);
} FileSystemOps;

void set_file_system_ops(const FileSystemOps* ops);

// 실제 구현
extern const FileSystemOps real_file_system;

// 테스트용 모킹
extern const FileSystemOps mock_file_system;
```

## 플러그인 아키텍처

### 동적 모듈 로딩

```c
// plugin_system.h
typedef struct Plugin {
    const char* name;
    const char* version;
    int (*init)(void);
    int (*execute)(const char* command, void* data);
    void (*cleanup)(void);
} Plugin;

typedef Plugin* (*GetPluginFunc)(void);

int plugin_load(const char* filename);
Plugin* plugin_get(const char* name);
int plugin_execute(const char* plugin_name, const char* command, void* data);
void plugin_unload_all(void);
```

### 확장 포인트

```c
// extension_points.h
typedef enum {
    EXT_POINT_STARTUP,
    EXT_POINT_SHUTDOWN,
    EXT_POINT_FILE_OPENED,
    EXT_POINT_USER_LOGIN
} ExtensionPoint;

typedef void (*ExtensionCallback)(ExtensionPoint point, void* data);

int register_extension(ExtensionPoint point, ExtensionCallback callback);
void trigger_extension_point(ExtensionPoint point, void* data);
```

## 성능과 모듈화의 균형

### 인라인과 모듈 경계

```c
// 성능이 중요한 함수는 헤더에서 인라인으로
// fast_math.h
static inline double fast_square(double x) {
    return x * x;
}

// 복잡한 로직은 별도 모듈로
double complex_calculation(double x, double y, double z);
```

### 컴파일 시간 최적화

```c
// forward_declarations.h - 순환 의존성 해결
typedef struct Database Database;
typedef struct User User;
typedef struct Session Session;

// 필요할 때만 전체 정의 포함
#ifndef LIGHTWEIGHT_INCLUDE
    #include "database_full.h"
    #include "user_full.h"
    #include "session_full.h"
#endif
```

## 문서화와 모듈 인터페이스

### 자기 문서화 모듈

```c
// json_parser.h
/**
 * JSON 파싱 모듈
 *
 * 이 모듈은 RFC 7159를 준수하는 JSON 문서를 파싱합니다.
 *
 * 기본 사용법:
 * ```c
 * JsonValue* root = json_parse(json_string);
 * const char* name = json_get_string(root, "name");
 * json_destroy(root);
 * ```
 *
 * 주의사항:
 * - 모든 json_* 함수는 스레드 안전하지 않습니다
 * - 메모리 해제는 호출자의 책임입니다
 * - UTF-8 인코딩만 지원합니다
 */

typedef struct JsonValue JsonValue;

JsonValue* json_parse(const char* json_string);
// ... 기타 함수들
```

## 마무리: 모듈화의 예술

모듈화 프로그래밍을 마스터하는 것은:

1. **추상화 사고**: 무엇을 숨기고 무엇을 드러낼지 결정하는 능력
2. **시스템 설계**: 전체 구조를 이해하고 부분들의 관계를 설계하는 능력
3. **변화 관리**: 미래의 변경사항을 예측하고 대비하는 능력
4. **복잡성 제어**: 인간이 이해할 수 있는 크기로 문제를 분해하는 능력

**핵심 통찰**: 모듈화는 **기술적 기법이 아니라 사고 방식**입니다. 이는 **"어떻게 복잡한 시스템을 인간이 관리할 수 있는 크기로 만들 것인가"**라는 근본적인 질문에 대한 답입니다.

**철학적 결론**: 좋은 모듈화는 **"각 부분이 독립적으로 이해될 수 있으면서도, 전체적으로는 조화롭게 동작하는"** 시스템을 만드는 것입니다. 이는 프로그래밍에서 **"부분과 전체의 관계"**에 대한 깊이 있는 사고를 요구하는 고도의 설계 활동입니다.

**실용적 지혜**: 모듈화는 **과도하게 해도, 부족하게 해도 문제**가 됩니다. 적절한 **"모듈화의 입도(Granularity)"**를 찾는 것이 핵심이며, 이는 경험과 도메인 이해를 통해서만 터득할 수 있습니다.