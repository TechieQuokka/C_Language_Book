# 12.2 사용자 정의 헤더 파일

## 핵심 개념: 인터페이스와 구현의 분리

사용자 정의 헤더 파일은 단순히 **"선언을 모아놓은 파일"**이 아닙니다. 이는 소프트웨어 공학에서 가장 중요한 원칙 중 하나인 **"인터페이스와 구현의 분리"**를 C언어에서 구현하는 핵심 메커니즘입니다.

### 추상화의 물리적 구현

헤더 파일은 **추상화를 물리적으로 구현**합니다:
- **`.h` 파일**: "무엇을" 제공하는지 (What)
- **`.c` 파일**: "어떻게" 구현하는지 (How)

**철학적 의미**: 이는 **"선언적 사고와 명령적 구현의 분리"**를 의미합니다.

## 헤더 파일의 존재 이유

### 1. 정보 은닉 (Information Hiding)

```c
// calculator.h - 공개 인터페이스
int add(int a, int b);
int multiply(int a, int b);

// calculator.c - 비공개 구현
static int validate_input(int value) {  // 외부에 노출되지 않음
    return value > INT_MIN && value < INT_MAX;
}

int add(int a, int b) {
    if (!validate_input(a) || !validate_input(b)) return 0;
    return a + b;
}
```

**핵심 통찰**: 사용자는 **"어떻게 더하는지"**를 알 필요 없이 **"더할 수 있다는 사실"**만 알면 됩니다.

### 2. 재사용성 (Reusability)

헤더 파일은 **"지적 자산의 패키징"**입니다:
- 한 번 작성하면 여러 곳에서 사용 가능
- 인터페이스가 변하지 않으면 구현 변경이 자유로움
- 팀 협업에서 **계약서** 역할

### 3. 컴파일 효율성

**분할 컴파일**의 핵심:
- 각 `.c` 파일을 독립적으로 컴파일
- 헤더만 변경되면 전체 재컴파일 불필요
- 대형 프로젝트에서 빌드 시간 대폭 단축

## 헤더 파일 설계의 철학

### Include Guard: 중복의 방지

```c
#ifndef CALCULATOR_H
#define CALCULATOR_H

// 헤더 내용...

#endif // CALCULATOR_H
```

**개념적 의미**: 이는 **"논리적 단일성"**을 보장합니다. 같은 선언이 여러 번 나타나는 것을 방지하여 **일관성**을 유지합니다.

**현대적 대안**:
```c
#pragma once  // 컴파일러 지원 시 더 간단
```

### 전방 선언 (Forward Declaration)

```c
// shapes.h
typedef struct Circle Circle;  // 전방 선언

Circle* create_circle(double radius);
double get_area(Circle* circle);

// 구조체 정의는 .c 파일에서
```

**철학적 의미**: **"필요한 것만 노출하라"**는 최소 권한 원칙의 구현입니다.

## 헤더 파일의 구조적 설계

### 계층적 구성

```c
// base.h - 기본 타입과 매크로
typedef unsigned int uint;
#define MAX_SIZE 1000

// math_utils.h - 수학 유틸리티
#include "base.h"
double calculate_distance(double x1, double y1, double x2, double y2);

// graphics.h - 그래픽 기능
#include "base.h"
#include "math_utils.h"
void draw_line(double x1, double y1, double x2, double y2);
```

**설계 원칙**: **"의존성의 방향성"**을 명확히 하여 순환 의존성을 방지합니다.

### 네임스페이스 시뮬레이션

C언어에는 네임스페이스가 없지만 **명명 규칙**으로 시뮬레이션할 수 있습니다:

```c
// json.h
typedef struct JSON_Object JSON_Object;

JSON_Object* json_create(void);
void json_destroy(JSON_Object* obj);
int json_set_string(JSON_Object* obj, const char* key, const char* value);
char* json_get_string(JSON_Object* obj, const char* key);
```

**네이밍 철학**: **접두사**를 통해 **논리적 그룹핑**을 구현합니다.

## 타입 정의와 추상화

### 불투명 포인터 (Opaque Pointer)

```c
// file_manager.h
typedef struct FileManager FileManager;

FileManager* fm_create(void);
int fm_open_file(FileManager* fm, const char* filename);
void fm_close_file(FileManager* fm, int file_id);
void fm_destroy(FileManager* fm);
```

**핵심 개념**: 사용자는 **구조체의 내부 구조를 알 필요 없이** 포인터를 통해서만 조작합니다.

**장점**:
- **캡슐화**: 내부 구현 완전 은닉
- **유연성**: 구현 변경이 인터페이스에 영향 없음
- **안정성**: 직접적인 메모리 접근 방지

### typedef를 통한 의미 부여

```c
// network.h
typedef int SocketHandle;
typedef unsigned char IPAddress[4];
typedef unsigned short Port;

SocketHandle net_create_socket(void);
int net_connect(SocketHandle socket, IPAddress ip, Port port);
void net_close(SocketHandle socket);
```

**의미론적 타이핑**: 같은 `int`라도 **역할에 따른 의미**를 부여합니다.

## 상수와 매크로 정의의 철학

### 매직 넘버의 제거

```c
// config.h
#define MAX_USERS 1000
#define DEFAULT_TIMEOUT_MS 5000
#define CONNECTION_RETRY_COUNT 3

// 사용
if (user_count >= MAX_USERS) {
    return ERROR_TOO_MANY_USERS;
}
```

**가독성의 혁명**: 숫자에 **의미를 부여**하여 코드를 **자기 문서화**합니다.

### 조건부 컴파일

```c
// debug.h
#ifdef DEBUG
    #define DBG_PRINT(fmt, ...) printf("DEBUG: " fmt, ##__VA_ARGS__)
#else
    #define DBG_PRINT(fmt, ...) ((void)0)
#endif

#ifdef PERFORMANCE_MODE
    #define INLINE inline
#else
    #define INLINE
#endif
```

**컴파일 시점 최적화**: 런타임이 아닌 **컴파일 시점**에 동작을 결정합니다.

## 함수형 인터페이스 설계

### 콜백과 함수 포인터

```c
// event_system.h
typedef void (*EventHandler)(int event_type, void* data);
typedef int (*EventFilter)(int event_type, void* data);

int event_register_handler(int event_type, EventHandler handler);
int event_set_filter(EventFilter filter);
void event_trigger(int event_type, void* data);
```

**함수형 사고**: 함수를 **일급 시민**으로 취급하여 유연한 설계를 가능하게 합니다.

### 초기화와 정리 패턴

```c
// resource_manager.h
typedef struct ResourceManager ResourceManager;

// 생성자 패턴
ResourceManager* rm_create(void);
int rm_init(ResourceManager* rm, const char* config_file);

// 소멸자 패턴
void rm_cleanup(ResourceManager* rm);
void rm_destroy(ResourceManager* rm);
```

**RAII 패턴의 C버전**: 명시적인 자원 관리를 통해 **메모리 누수를 방지**합니다.

## 오류 처리 인터페이스

### 일관된 오류 코드 체계

```c
// errors.h
typedef enum {
    ERR_SUCCESS = 0,
    ERR_INVALID_ARGUMENT = -1,
    ERR_OUT_OF_MEMORY = -2,
    ERR_FILE_NOT_FOUND = -3,
    ERR_PERMISSION_DENIED = -4,
    ERR_NETWORK_ERROR = -5
} ErrorCode;

const char* error_to_string(ErrorCode error);
```

**일관성의 가치**: 모든 함수가 **동일한 방식**으로 오류를 보고합니다.

### 다층적 오류 정보

```c
// advanced_errors.h
typedef struct {
    ErrorCode code;
    const char* message;
    const char* file;
    int line;
} ErrorInfo;

#define RETURN_ERROR(code, msg) \
    return (ErrorInfo){code, msg, __FILE__, __LINE__}

ErrorInfo database_connect(const char* connection_string);
```

## 플랫폼 추상화

### 조건부 정의

```c
// platform.h
#ifdef _WIN32
    #include <windows.h>
    typedef HANDLE ThreadHandle;
    #define SLEEP_MS(ms) Sleep(ms)
#else
    #include <pthread.h>
    #include <unistd.h>
    typedef pthread_t ThreadHandle;
    #define SLEEP_MS(ms) usleep((ms) * 1000)
#endif

ThreadHandle create_thread(void (*func)(void*), void* arg);
void join_thread(ThreadHandle handle);
```

**이식성의 구현**: 플랫폼 차이를 **헤더 레벨에서 해결**합니다.

## 헤더 파일 조직화 전략

### 모듈별 분리

```
project/
├── include/
│   ├── core/
│   │   ├── memory.h
│   │   ├── string_utils.h
│   │   └── collections.h
│   ├── io/
│   │   ├── file_io.h
│   │   └── network.h
│   └── ui/
│       ├── window.h
│       └── events.h
└── src/
    ├── core/
    ├── io/
    └── ui/
```

**구조적 사고**: **논리적 응집도**가 높은 기능들을 함께 배치합니다.

### 의존성 관리

```c
// dependency_graph.h
// Level 0: 기본 타입 (의존성 없음)
#include "types.h"

// Level 1: 기본 유틸리티 (types에만 의존)
#include "memory.h"
#include "string_utils.h"

// Level 2: 고급 기능 (Level 1에 의존)
#include "collections.h"
#include "file_system.h"
```

**의존성의 위계**: 순환 의존성을 방지하는 **계층적 구조**를 만듭니다.

## 문서화와 주석 전략

### 자기 문서화 코드

```c
// calculator.h
/**
 * 두 정수를 더합니다.
 *
 * @param a 첫 번째 피연산자
 * @param b 두 번째 피연산자
 * @return a와 b의 합. 오버플로우 시 정의되지 않은 동작
 * @note 이 함수는 스레드 안전합니다.
 * @since v1.0
 */
int add(int a, int b);

/**
 * 안전한 정수 덧셈을 수행합니다.
 *
 * @param a 첫 번째 피연산자
 * @param b 두 번째 피연산자
 * @param result 결과를 저장할 포인터 (NULL이 아님)
 * @return 성공 시 0, 오버플로우 시 -1
 * @pre result != NULL
 * @post 성공 시 *result = a + b
 */
int safe_add(int a, int b, int* result);
```

### 사용 예시 제공

```c
// usage_example.h
/*
 * Usage Example:
 *
 * ```c
 * #include "calculator.h"
 *
 * int main() {
 *     int result;
 *     if (safe_add(INT_MAX, 1, &result) != 0) {
 *         printf("Overflow detected!\n");
 *     }
 *     return 0;
 * }
 * ```
 */
```

## 헤더 파일의 진화와 버전 관리

### 버전 호환성

```c
// api_version.h
#define API_VERSION_MAJOR 2
#define API_VERSION_MINOR 1
#define API_VERSION_PATCH 0

#define API_VERSION_CHECK(major, minor) \
    ((API_VERSION_MAJOR > (major)) || \
     (API_VERSION_MAJOR == (major) && API_VERSION_MINOR >= (minor)))

#if API_VERSION_CHECK(2, 0)
    // 새로운 API
    int new_feature(void);
#endif
```

### 점진적 마이그레이션

```c
// deprecated.h
#define DEPRECATED __attribute__((deprecated))

// 구버전 함수 (사용 금지 예고)
DEPRECATED int old_function(int x);

// 신버전 함수 (권장)
int new_function(int x);
```

## 마무리: 헤더 파일 설계의 본질

사용자 정의 헤더 파일을 마스터하는 것은:

1. **추상화 능력**: 무엇을 숨기고 무엇을 드러낼지 결정
2. **인터페이스 설계**: 사용하기 쉽고 오용하기 어려운 API 만들기
3. **시스템 사고**: 모듈 간의 관계와 의존성 이해
4. **미래 예측**: 변화에 대응할 수 있는 유연한 설계

**핵심 통찰**: 헤더 파일은 **"소프트웨어 아키텍처의 청사진"**입니다. 잘 설계된 헤더 파일은 전체 시스템의 **구조와 철학**을 반영합니다.

**철학적 결론**: 헤더 파일 설계는 **"어떻게 복잡성을 관리할 것인가"**라는 소프트웨어 공학의 근본 문제에 대한 C언어의 답변입니다. 이는 단순히 선언을 분리하는 것이 아니라, **"좋은 소프트웨어란 무엇인가"**에 대한 깊이 있는 사고를 요구하는 설계 활동입니다.