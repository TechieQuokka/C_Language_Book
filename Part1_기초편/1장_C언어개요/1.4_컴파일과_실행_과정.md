# 1.4 컴파일과 실행 과정

C언어는 컴파일 언어입니다. 이는 우리가 작성한 소스 코드가 바로 실행되는 것이 아니라, 컴파일러를 통해 기계어로 변환된 후 실행된다는 의미입니다. 이번 장에서는 C언어의 컴파일과 실행 과정을 상세히 알아보겠습니다.

## 컴파일과 실행의 전체 과정

### 개요

```
소스코드(.c) → 전처리 → 컴파일 → 어셈블 → 링크 → 실행파일(.exe) → 실행
```

C언어 프로그램이 실행되기까지 총 4단계를 거칩니다:

1. **전처리 (Preprocessing)**
2. **컴파일 (Compilation)**
3. **어셈블 (Assembly)**
4. **링크 (Linking)**

## 1단계: 전처리 (Preprocessing)

### 전처리기의 역할

전처리기는 컴파일러가 작업하기 전에 소스 코드를 처리합니다.

**주요 작업:**
- `#include` 지시자 처리 (헤더 파일 포함)
- `#define` 지시자 처리 (매크로 치환)
- 조건부 컴파일 (`#ifdef`, `#ifndef` 등)
- 주석 제거

### 예시

**원본 소스 코드 (hello.c):**
```c
#include <stdio.h>
#define MESSAGE "Hello, World!"

int main() {
    // 인사말 출력
    printf(MESSAGE);
    return 0;
}
```

**전처리 후 결과:**
```c
// stdio.h의 내용이 여기에 삽입됨 (수백 줄)
// ... stdio.h 내용 ...

int main() {

    printf("Hello, World!");
    return 0;
}
```

### 전처리기 명령어로 결과 확인

```bash
# 전처리 결과만 보기
gcc -E hello.c -o hello.i

# 전처리 결과를 화면에 출력
gcc -E hello.c
```

## 2단계: 컴파일 (Compilation)

### 컴파일러의 역할

컴파일러는 전처리된 C 소스 코드를 어셈블리 언어로 변환합니다.

**주요 작업:**
- 문법 검사 (Syntax Analysis)
- 의미 분석 (Semantic Analysis)
- 최적화 (Optimization)
- 어셈블리 코드 생성

### 어셈블리 코드 예시

**C 코드:**
```c
int main() {
    int a = 5;
    int b = 10;
    int c = a + b;
    return 0;
}
```

**생성된 어셈블리 코드 (x86-64, 간략화):**
```assembly
main:
    pushq   %rbp
    movq    %rsp, %rbp
    movl    $5, -12(%rbp)    # a = 5
    movl    $10, -8(%rbp)    # b = 10
    movl    -12(%rbp), %eax  # eax = a
    addl    -8(%rbp), %eax   # eax = a + b
    movl    %eax, -4(%rbp)   # c = eax
    movl    $0, %eax         # return 0
    popq    %rbp
    ret
```

### 컴파일 명령어

```bash
# 어셈블리 코드 생성
gcc -S hello.c -o hello.s

# 최적화된 어셈블리 코드 생성
gcc -O2 -S hello.c -o hello_optimized.s
```

## 3단계: 어셈블 (Assembly)

### 어셈블러의 역할

어셈블러는 어셈블리 코드를 기계어(오브젝트 코드)로 변환합니다.

**주요 작업:**
- 어셈블리 명령어를 기계어로 변환
- 심볼 테이블 생성
- 재배치 가능한 오브젝트 파일 생성

### 오브젝트 파일의 구조

```
오브젝트 파일 (.o, .obj)
├── 헤더 정보
├── 텍스트 섹션 (코드)
├── 데이터 섹션 (초기화된 변수)
├── BSS 섹션 (초기화되지 않은 변수)
├── 심볼 테이블
└── 재배치 테이블
```

### 어셈블 명령어

```bash
# 오브젝트 파일 생성
gcc -c hello.c -o hello.o

# 여러 파일을 개별적으로 컴파일
gcc -c main.c -o main.o
gcc -c utils.c -o utils.o
```

## 4단계: 링크 (Linking)

### 링커의 역할

링커는 여러 오브젝트 파일과 라이브러리를 연결하여 실행 가능한 파일을 만듭니다.

**주요 작업:**
- 심볼 해석 (Symbol Resolution)
- 재배치 (Relocation)
- 실행 파일 생성

### 링킹 과정 예시

**프로젝트 구조:**
```
project/
├── main.c      (main 함수 포함)
├── math.c      (수학 함수들)
├── math.h      (math.c의 헤더)
└── utils.c     (유틸리티 함수들)
```

**main.c:**
```c
#include <stdio.h>
#include "math.h"

int main() {
    int result = add(10, 20);
    printf("Result: %d\n", result);
    return 0;
}
```

**math.h:**
```c
#ifndef MATH_H
#define MATH_H

int add(int a, int b);
int subtract(int a, int b);

#endif
```

**math.c:**
```c
#include "math.h"

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}
```

### 링킹 명령어

```bash
# 단계별 링킹
gcc -c main.c -o main.o
gcc -c math.c -o math.o
gcc main.o math.o -o program

# 한 번에 컴파일 및 링킹
gcc main.c math.c -o program
```

## 라이브러리와 링킹

### 정적 링킹 (Static Linking)

정적 라이브러리(.a, .lib)의 코드가 실행 파일에 포함됩니다.

**장점:**
- 실행 시 외부 의존성 없음
- 빠른 실행 속도

**단점:**
- 큰 실행 파일 크기
- 메모리 사용량 증가

```bash
# 정적 라이브러리 생성
ar rcs libmath.a math.o utils.o

# 정적 라이브러리 사용
gcc main.c -L. -lmath -o program
```

### 동적 링킹 (Dynamic Linking)

동적 라이브러리(.so, .dll)는 실행 시에 로드됩니다.

**장점:**
- 작은 실행 파일 크기
- 메모리 공유 가능
- 라이브러리 업데이트 용이

**단점:**
- 실행 시 라이브러리 필요
- 약간의 성능 오버헤드

```bash
# 동적 라이브러리 생성 (Linux)
gcc -shared -fPIC math.c -o libmath.so

# 동적 라이브러리 사용
gcc main.c -L. -lmath -o program
```

## 컴파일러 최적화

### 최적화 레벨

**-O0 (기본값):**
- 최적화 없음
- 빠른 컴파일
- 디버깅에 적합

**-O1:**
- 기본적인 최적화
- 컴파일 시간과 성능의 균형

**-O2 (권장):**
- 적극적인 최적화
- 대부분의 릴리즈 빌드에 사용

**-O3:**
- 최대 최적화
- 코드 크기 증가 가능

**-Os:**
- 크기 최적화
- 메모리 제한 환경에 적합

### 최적화 예시

**원본 코드:**
```c
int sum_array(int arr[], int size) {
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum;
}
```

**-O0 (최적화 없음):**
```assembly
sum_array:
    # 루프가 그대로 구현됨
    # 배열 인덱스 계산 반복
```

**-O2 (최적화):**
```assembly
sum_array:
    # 루프 언롤링
    # 레지스터 최적화
    # 불필요한 계산 제거
```

## 디버그 정보

### 디버그 옵션

```bash
# 디버그 정보 포함
gcc -g hello.c -o hello

# 최대 디버그 정보
gcc -g3 hello.c -o hello

# 디버그 정보와 최적화 함께 (권장하지 않음)
gcc -g -O2 hello.c -o hello
```

### 디버그 정보의 역할

- **변수 이름 보존**: 원본 변수명으로 디버깅
- **소스 코드 매핑**: 기계어와 소스 코드 연결
- **함수 정보**: 함수 호출 스택 추적

## 실행 과정

### 프로그램 로딩

실행 파일이 실행될 때 운영체제가 수행하는 작업:

1. **프로세스 생성**: 새로운 프로세스 공간 할당
2. **메모리 맵핑**: 실행 파일을 메모리에 로드
3. **동적 라이브러리 로딩**: 필요한 DLL/SO 파일 로드
4. **스택/힙 초기화**: 런타임 메모리 영역 설정
5. **main 함수 호출**: 프로그램 진입점 실행

### 메모리 레이아웃

```
높은 주소
┌─────────────┐
│   스택      │ ← 지역변수, 함수 매개변수
├─────────────┤
│     ↓       │
│             │
│     ↑       │
├─────────────┤
│    힙       │ ← 동적 할당 메모리
├─────────────┤
│ BSS 영역    │ ← 초기화되지 않은 전역변수
├─────────────┤
│ 데이터 영역  │ ← 초기화된 전역변수
├─────────────┤
│ 텍스트 영역  │ ← 프로그램 코드
└─────────────┘
낮은 주소
```

## 실습: 컴파일 과정 단계별 확인

### 예제 프로그램

**main.c:**
```c
#include <stdio.h>
#define PI 3.14159

int global_var = 100;

int add(int a, int b) {
    return a + b;
}

int main() {
    int local_var = 10;
    double area = PI * 5 * 5;

    printf("Global: %d\n", global_var);
    printf("Local: %d\n", local_var);
    printf("Area: %.2f\n", area);
    printf("Add: %d\n", add(3, 7));

    return 0;
}
```

### 단계별 실행

```bash
# 1. 전처리 결과 확인
gcc -E main.c -o main.i
head -20 main.i  # 처음 20줄 확인

# 2. 어셈블리 코드 생성
gcc -S main.c -o main.s
cat main.s

# 3. 오브젝트 파일 생성
gcc -c main.c -o main.o
file main.o  # 파일 타입 확인

# 4. 실행 파일 생성
gcc main.o -o main

# 5. 실행
./main
```

### 파일 크기 비교

```bash
ls -la main.*
# main.c    (수백 바이트)
# main.i    (수만 바이트 - stdio.h 포함)
# main.s    (수천 바이트)
# main.o    (수천 바이트)
# main      (수만 바이트 - 라이브러리 포함)
```

## 자주 발생하는 링킹 오류

### 1. Undefined Reference

**오류 상황:**
```c
// main.c
int main() {
    int result = add(5, 3);  // add 함수 정의 없음
    return 0;
}
```

**오류 메시지:**
```
undefined reference to 'add'
```

**해결방법:**
- 함수 정의 추가
- 해당 오브젝트 파일 링크

### 2. Multiple Definition

**오류 상황:**
```c
// file1.c
int global_var = 10;

// file2.c
int global_var = 20;  // 중복 정의
```

**오류 메시지:**
```
multiple definition of 'global_var'
```

**해결방법:**
- 한 파일에서만 정의
- 다른 파일에서는 extern 선언 사용

### 3. Library Not Found

**오류 메시지:**
```
cannot find -lmath
```

**해결방법:**
```bash
# 라이브러리 경로 지정
gcc main.c -L/usr/local/lib -lmath

# 표준 수학 라이브러리 링크
gcc main.c -lm
```

## Makefile을 이용한 빌드 자동화

### 기본 Makefile

```makefile
# 변수 정의
CC = gcc
CFLAGS = -Wall -Wextra -g -std=c99
TARGET = program
SOURCES = main.c math.c utils.c
OBJECTS = $(SOURCES:.c=.o)

# 기본 규칙
$(TARGET): $(OBJECTS)
	$(CC) $(OBJECTS) -o $(TARGET)

# 오브젝트 파일 생성 규칙
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# 정리 규칙
clean:
	rm -f $(OBJECTS) $(TARGET)

# 재빌드 규칙
rebuild: clean $(TARGET)

# 의존성 확인
depend:
	gcc -MM $(SOURCES) > .depend

# .PHONY 선언
.PHONY: clean rebuild depend
```

### Makefile 사용

```bash
make            # 빌드
make clean      # 정리
make rebuild    # 재빌드
make depend     # 의존성 생성
```

## 정리

이번 장에서 학습한 컴파일과 실행 과정:

1. **전처리**: 헤더 파일 포함, 매크로 치환
2. **컴파일**: C 코드를 어셈블리로 변환
3. **어셈블**: 어셈블리를 기계어로 변환
4. **링크**: 여러 오브젝트 파일을 연결하여 실행 파일 생성

**주요 개념:**
- 정적/동적 링킹의 차이
- 컴파일러 최적화 옵션
- 디버그 정보의 중요성
- 메모리 레이아웃 이해
- Makefile을 통한 빌드 자동화

C언어의 컴파일 과정을 이해하면 프로그램이 어떻게 동작하는지 깊이 있게 파악할 수 있으며, 오류 해결과 성능 최적화에도 큰 도움이 됩니다.