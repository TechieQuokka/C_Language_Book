# 4.3 지역변수와 전역변수

## 변수의 범위(Scope) 개념

### 범위(Scope)란?

프로그래밍에서 **범위(Scope)**는 변수가 접근 가능한 코드 영역을 의미합니다. C언어에서는 변수가 선언된 위치에 따라 접근 가능한 범위가 결정됩니다.

```c
#include <stdio.h>

int global_var = 100;  // 전역변수: 프로그램 전체에서 접근 가능

void function1() {
    int local_var = 10;  // 지역변수: function1 내부에서만 접근 가능
    printf("function1에서 global_var: %d\n", global_var);
    printf("function1에서 local_var: %d\n", local_var);
}

void function2() {
    int local_var = 20;  // 다른 함수의 지역변수 (독립적)
    printf("function2에서 global_var: %d\n", global_var);
    printf("function2에서 local_var: %d\n", local_var);
    // function1의 local_var에는 접근 불가
}

int main() {
    int local_var = 30;  // main 함수의 지역변수

    printf("main에서 global_var: %d\n", global_var);
    printf("main에서 local_var: %d\n", local_var);

    function1();
    function2();

    return 0;
}
```

## 지역변수(Local Variable)

### 지역변수의 특징

지역변수는 **특정 블록 내부**에서만 유효한 변수입니다.

#### 핵심 특징:
1. **블록 범위**: 선언된 블록(`{}`) 내에서만 접근 가능
2. **자동 생성/소멸**: 블록 진입 시 생성, 종료 시 소멸
3. **스택 메모리**: 프로그램 스택에 저장
4. **초기화 필요**: 자동으로 초기화되지 않음 (쓰레기값 가질 수 있음)

```c
#include <stdio.h>

void demonstrate_local_variables() {
    printf("=== 지역변수 생명주기 시연 ===\n");

    int outer_var = 100;
    printf("외부 블록 - outer_var: %d\n", outer_var);

    if (1) {  // 내부 블록 시작
        int inner_var = 200;
        outer_var = 150;  // 외부 변수 수정 가능

        printf("내부 블록 - outer_var: %d\n", outer_var);
        printf("내부 블록 - inner_var: %d\n", inner_var);
    }  // inner_var 소멸

    printf("외부 블록 - outer_var: %d\n", outer_var);
    // printf("외부 블록 - inner_var: %d\n", inner_var);  // 오류!
}

void show_loop_variables() {
    printf("\n=== 반복문에서의 지역변수 ===\n");

    for (int i = 0; i < 3; i++) {
        int loop_var = i * 10;
        printf("반복 %d: loop_var = %d\n", i, loop_var);
    }  // i와 loop_var 모두 소멸

    // printf("i = %d\n", i);  // 오류! i는 for문 범위를 벗어남
}

int main() {
    demonstrate_local_variables();
    show_loop_variables();
    return 0;
}
```

### 지역변수의 메모리 할당

```c
#include <stdio.h>

void analyze_local_memory() {
    int var1 = 10;
    int var2 = 20;
    int var3 = 30;

    printf("=== 지역변수 메모리 분석 ===\n");
    printf("var1 주소: %p, 값: %d\n", &var1, var1);
    printf("var2 주소: %p, 값: %d\n", &var2, var2);
    printf("var3 주소: %p, 값: %d\n", &var3, var3);

    // 스택에서의 주소 차이 계산
    printf("var1-var2 주소 차이: %ld bytes\n", (char*)&var1 - (char*)&var2);
    printf("var2-var3 주소 차이: %ld bytes\n", (char*)&var2 - (char*)&var3);
}

void recursive_function(int depth) {
    int local_var = depth * 100;

    printf("깊이 %d: local_var = %d, 주소: %p\n", depth, local_var, &local_var);

    if (depth > 0) {
        recursive_function(depth - 1);
    }
}

int main() {
    analyze_local_memory();

    printf("\n=== 재귀 호출에서의 지역변수 ===\n");
    recursive_function(3);

    return 0;
}
```

## 전역변수(Global Variable)

### 전역변수의 특징

전역변수는 **프로그램 전체**에서 접근 가능한 변수입니다.

#### 핵심 특징:
1. **전역 범위**: 모든 함수에서 접근 가능
2. **프로그램 생명주기**: 프로그램 시작부터 종료까지 존재
3. **데이터 세그먼트**: 프로그램의 데이터 영역에 저장
4. **자동 초기화**: 0으로 자동 초기화됨

```c
#include <stdio.h>

// 전역변수 선언
int counter = 0;              // 초기화된 전역변수
double total_sum;             // 초기화되지 않은 전역변수 (자동으로 0.0으로 초기화)
char global_message[100];     // 전역 배열 (모든 요소가 0으로 초기화)

void increment_counter() {
    counter++;  // 전역변수 수정
    printf("increment_counter(): counter = %d\n", counter);
}

void add_to_sum(double value) {
    total_sum += value;  // 전역변수 수정
    printf("add_to_sum(%.2f): total_sum = %.2f\n", value, total_sum);
}

void display_global_info() {
    printf("=== 전역변수 정보 ===\n");
    printf("counter: %d\n", counter);
    printf("total_sum: %.2f\n", total_sum);
    printf("global_message: \"%s\"\n", global_message);
}

int main() {
    printf("프로그램 시작 시 전역변수 상태:\n");
    display_global_info();

    increment_counter();
    increment_counter();
    add_to_sum(10.5);
    add_to_sum(20.3);

    // 전역 배열 사용
    sprintf(global_message, "Hello, Global World!");

    printf("\n수정 후 전역변수 상태:\n");
    display_global_info();

    return 0;
}
```

### 전역변수와 지역변수의 이름 충돌

```c
#include <stdio.h>

int value = 100;  // 전역변수

void test_name_conflict() {
    printf("함수 시작 - value: %d (전역변수)\n", value);

    {  // 새로운 블록
        int value = 200;  // 지역변수 (전역변수를 가림)
        printf("블록 내부 - value: %d (지역변수)\n", value);

        // 전역변수에 접근하려면 extern 키워드 사용하거나
        // 다른 방법으로 접근해야 함
    }

    printf("블록 종료 후 - value: %d (전역변수)\n", value);
}

void modify_global() {
    value = 300;  // 전역변수 수정
    printf("modify_global() - value: %d (전역변수 수정)\n", value);
}

int main() {
    int value = 50;  // main의 지역변수

    printf("main - value: %d (지역변수)\n", value);
    printf("main - ::value: %d (전역변수, 직접 접근)\n", ::value);  // C++에서만 가능

    test_name_conflict();
    modify_global();

    printf("main 종료 전 - value: %d (지역변수는 변경되지 않음)\n", value);

    return 0;
}
```

## 변수의 저장 클래스(Storage Class)

### auto 키워드 (지역변수의 기본)

```c
#include <stdio.h>

void demonstrate_auto() {
    auto int auto_var = 100;  // auto는 생략 가능 (기본값)
    int normal_var = 200;     // 실제로는 auto int와 동일

    printf("auto_var: %d\n", auto_var);
    printf("normal_var: %d\n", normal_var);
}

int main() {
    demonstrate_auto();
    return 0;
}
```

### static 지역변수

```c
#include <stdio.h>

void count_calls() {
    static int call_count = 0;  // static 지역변수: 함수 호출 간에 값 유지
    int normal_var = 0;         // 일반 지역변수: 매번 초기화

    call_count++;
    normal_var++;

    printf("함수 호출 횟수: %d, 일반 변수: %d\n", call_count, normal_var);
}

void demonstrate_static_initialization() {
    static int initialized_once = 100;

    printf("static 변수 (처음 한 번만 초기화): %d\n", initialized_once);
    initialized_once += 10;
}

int main() {
    printf("=== static 지역변수 시연 ===\n");

    for (int i = 0; i < 5; i++) {
        count_calls();
    }

    printf("\n=== static 초기화 시연 ===\n");
    for (int i = 0; i < 3; i++) {
        demonstrate_static_initialization();
    }

    return 0;
}
```

### extern 키워드 (외부 변수 참조)

```c
#include <stdio.h>

// 다른 파일에서 정의된 전역변수라고 가정
// extern int external_counter;  // 선언만 (정의는 다른 곳에)

int shared_data = 1000;  // 이 파일에서 정의된 전역변수

void display_shared_data() {
    printf("shared_data: %d\n", shared_data);
}

void modify_shared_data(int new_value) {
    shared_data = new_value;
}

int main() {
    printf("초기 shared_data: %d\n", shared_data);

    modify_shared_data(2000);
    display_shared_data();

    return 0;
}
```

## 메모리 영역별 변수 분류

### 메모리 구조와 변수 위치

```c
#include <stdio.h>
#include <stdlib.h>

// 전역변수들 (데이터 영역)
int initialized_global = 42;      // 초기화된 데이터 영역
int uninitialized_global;         // BSS 영역 (0으로 초기화)
static int static_global = 100;   // 데이터 영역 (파일 범위)

void analyze_memory_layout() {
    // 지역변수들 (스택 영역)
    int local_var = 10;
    static int static_local = 20;  // 데이터 영역

    // 동적 할당 (힙 영역)
    int *heap_var = malloc(sizeof(int));
    *heap_var = 30;

    printf("=== 메모리 영역별 변수 주소 분석 ===\n");
    printf("초기화된 전역변수 주소:     %p\n", &initialized_global);
    printf("초기화안된 전역변수 주소:   %p\n", &uninitialized_global);
    printf("static 전역변수 주소:      %p\n", &static_global);
    printf("지역변수 주소:            %p\n", &local_var);
    printf("static 지역변수 주소:     %p\n", &static_local);
    printf("힙 변수 주소:             %p\n", heap_var);
    printf("함수 주소:                %p\n", analyze_memory_layout);

    free(heap_var);
}

int main() {
    analyze_memory_layout();
    return 0;
}
```

## 변수 범위의 실전 활용

### 1. 카운터 구현

```c
#include <stdio.h>

// 전역 카운터 (모든 함수에서 공유)
int global_counter = 0;

void increment_global_counter() {
    global_counter++;
}

int get_global_counter() {
    return global_counter;
}

// 로컬 카운터 (함수별 독립적)
int get_local_counter() {
    static int local_counter = 0;
    return ++local_counter;
}

void reset_global_counter() {
    global_counter = 0;
}

int main() {
    printf("=== 카운터 시연 ===\n");

    // 전역 카운터 테스트
    printf("전역 카운터 초기값: %d\n", get_global_counter());

    for (int i = 0; i < 5; i++) {
        increment_global_counter();
        printf("전역 카운터: %d, 로컬 카운터: %d\n",
               get_global_counter(), get_local_counter());
    }

    reset_global_counter();
    printf("전역 카운터 리셋 후: %d\n", get_global_counter());
    printf("로컬 카운터 (리셋되지 않음): %d\n", get_local_counter());

    return 0;
}
```

### 2. 설정 관리 시스템

```c
#include <stdio.h>
#include <string.h>

// 전역 설정 변수들
typedef struct {
    int debug_mode;
    int max_connections;
    char server_name[50];
    double timeout_seconds;
} AppConfig;

AppConfig app_config = {0, 100, "localhost", 30.0};  // 기본 설정

// 설정 조회 함수들
int is_debug_mode() {
    return app_config.debug_mode;
}

void set_debug_mode(int enabled) {
    app_config.debug_mode = enabled;
    if (is_debug_mode()) {
        printf("[DEBUG] 디버그 모드가 활성화되었습니다.\n");
    }
}

void set_server_config(const char* name, int max_conn, double timeout) {
    strncpy(app_config.server_name, name, sizeof(app_config.server_name) - 1);
    app_config.max_connections = max_conn;
    app_config.timeout_seconds = timeout;
}

void print_config() {
    printf("=== 현재 설정 ===\n");
    printf("디버그 모드: %s\n", app_config.debug_mode ? "ON" : "OFF");
    printf("서버 이름: %s\n", app_config.server_name);
    printf("최대 연결: %d\n", app_config.max_connections);
    printf("타임아웃: %.1f초\n", app_config.timeout_seconds);
}

void simulate_connection() {
    static int connection_id = 0;
    connection_id++;

    if (is_debug_mode()) {
        printf("[DEBUG] 연결 #%d 시작 (%s:%d)\n",
               connection_id, app_config.server_name, app_config.max_connections);
    }

    printf("연결 #%d 처리 중...\n", connection_id);

    if (connection_id > app_config.max_connections) {
        printf("경고: 최대 연결 수 초과!\n");
    }
}

int main() {
    print_config();

    printf("\n=== 설정 변경 ===\n");
    set_debug_mode(1);
    set_server_config("production-server", 500, 60.0);
    print_config();

    printf("\n=== 연결 시뮬레이션 ===\n");
    for (int i = 0; i < 3; i++) {
        simulate_connection();
    }

    return 0;
}
```

### 3. 게임 상태 관리

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 전역 게임 상태
typedef struct {
    int score;
    int level;
    int lives;
    int high_score;
} GameState;

GameState game = {0, 1, 3, 0};

void init_game() {
    srand(time(NULL));
    game.score = 0;
    game.level = 1;
    game.lives = 3;
    printf("게임이 초기화되었습니다!\n");
}

void update_score(int points) {
    static int combo = 0;

    game.score += points;
    combo++;

    // 콤보 보너스
    if (combo > 5) {
        int bonus = combo * 10;
        game.score += bonus;
        printf("콤보 보너스! +%d점\n", bonus);
    }

    // 하이스코어 갱신
    if (game.score > game.high_score) {
        game.high_score = game.score;
        printf("새로운 하이스코어! %d점\n", game.high_score);
    }

    // 레벨업 체크
    if (game.score >= game.level * 1000) {
        game.level++;
        printf("레벨업! 현재 레벨: %d\n", game.level);
        combo = 0;  // 레벨업 시 콤보 리셋
    }
}

void lose_life() {
    static int invincible_time = 0;

    if (invincible_time > 0) {
        printf("무적 시간 중... 남은 시간: %d\n", invincible_time);
        invincible_time--;
        return;
    }

    game.lives--;
    invincible_time = 3;  // 3턴 무적

    printf("생명력 감소! 남은 생명: %d\n", game.lives);

    if (game.lives <= 0) {
        printf("게임 오버!\n");
        printf("최종 점수: %d점, 도달 레벨: %d\n", game.score, game.level);
    }
}

void print_game_status() {
    printf("=== 게임 상태 ===\n");
    printf("점수: %d점\n", game.score);
    printf("레벨: %d\n", game.level);
    printf("생명: %d\n", game.lives);
    printf("하이스코어: %d점\n", game.high_score);
}

void simulate_game_play() {
    int action;

    while (game.lives > 0) {
        printf("\n행동 선택 (1:점수획득, 2:데미지, 3:상태확인, 0:종료): ");
        scanf("%d", &action);

        switch (action) {
            case 1: {
                int points = (rand() % 100) + 50;
                printf("%d점 획득!\n", points);
                update_score(points);
                break;
            }
            case 2:
                printf("데미지를 받았습니다!\n");
                lose_life();
                break;
            case 3:
                print_game_status();
                break;
            case 0:
                printf("게임을 종료합니다.\n");
                return;
            default:
                printf("잘못된 입력입니다.\n");
        }
    }
}

int main() {
    printf("=== 간단한 게임 시뮬레이터 ===\n");

    init_game();
    print_game_status();

    simulate_game_play();

    printf("\n=== 최종 결과 ===\n");
    print_game_status();

    return 0;
}
```

## 범위와 생명주기의 관계

### 변수의 생명주기 비교

```c
#include <stdio.h>

int global_var = 1;  // 프로그램 전체 생명주기

void demonstrate_lifetimes() {
    static int call_count = 0;  // 프로그램 전체 생명주기 (함수 범위)
    int local_var = 100;        // 함수 호출 생명주기

    call_count++;
    local_var += call_count;

    printf("호출 #%d: local_var=%d, static call_count=%d, global_var=%d\n",
           call_count, local_var, call_count, global_var);

    {  // 블록 범위
        int block_var = 200;    // 블록 생명주기
        block_var += local_var;
        printf("  블록 내부: block_var=%d\n", block_var);
    }  // block_var 소멸

    global_var += 10;
}

int main() {
    printf("=== 변수 생명주기 비교 ===\n");

    for (int i = 0; i < 4; i++) {
        demonstrate_lifetimes();
    }

    printf("최종 global_var: %d\n", global_var);

    return 0;
}
```

## 모범 사례와 주의점

### 1. 전역변수 사용 최소화

```c
#include <stdio.h>

// 나쁜 예: 과도한 전역변수 사용
int user_age, user_score, user_level;
char user_name[50];

void bad_example_init(int age, int score, const char* name) {
    user_age = age;
    user_score = score;
    strcpy(user_name, name);
    user_level = 1;
}

// 좋은 예: 구조체와 매개변수 사용
typedef struct {
    int age;
    int score;
    int level;
    char name[50];
} User;

void good_example_init(User *user, int age, int score, const char* name) {
    user->age = age;
    user->score = score;
    user->level = 1;
    strcpy(user->name, name);
}

void good_example_print_user(const User *user) {
    printf("사용자: %s, 나이: %d, 점수: %d, 레벨: %d\n",
           user->name, user->age, user->score, user->level);
}

int main() {
    // 좋은 방식: 지역 구조체 사용
    User player;
    good_example_init(&player, 25, 1500, "김철수");
    good_example_print_user(&player);

    return 0;
}
```

### 2. 이름 충돌 방지

```c
#include <stdio.h>

int count = 0;  // 전역변수

// 이름 충돌을 피하는 좋은 방법들
void demonstrate_naming_conventions() {
    int local_count = 10;        // 명확한 접두사 사용
    int temp_count = count;      // 임시 변수로 전역변수 값 복사

    printf("전역 count: %d\n", count);
    printf("지역 local_count: %d\n", local_count);
    printf("임시 temp_count: %d\n", temp_count);
}

// 네임스페이스 시뮬레이션 (C에서는 구조체로)
typedef struct {
    int count;
    double average;
} Statistics;

void update_statistics(Statistics *stats, int value) {
    stats->count++;
    // stats->average 계산 로직...
}

int main() {
    Statistics game_stats = {0, 0.0};
    Statistics user_stats = {0, 0.0};

    demonstrate_naming_conventions();

    update_statistics(&game_stats, 100);
    update_statistics(&user_stats, 200);

    return 0;
}
```

## 핵심 개념 정리

### 1. 변수 범위의 종류
- **블록 범위**: 중괄호 `{}` 내에서만 유효
- **함수 범위**: 함수 전체에서 유효
- **파일 범위**: 파일 전체에서 유효 (전역변수)
- **프로그램 범위**: 여러 파일에서 공유 가능 (extern)

### 2. 메모리 영역별 특성
- **스택 영역**: 지역변수, 매개변수, 반환 주소
- **데이터 영역**: 초기화된 전역변수, static 변수
- **BSS 영역**: 초기화되지 않은 전역변수
- **힙 영역**: 동적 할당된 메모리

### 3. 설계 원칙
- **최소 권한 원칙**: 필요한 범위에서만 접근 가능하도록 설계
- **데이터 은닉**: 내부 구현을 외부에 노출하지 않음
- **명확한 인터페이스**: 함수 매개변수를 통한 명시적 데이터 전달
- **생명주기 관리**: 변수의 생성과 소멸 시점을 명확히 파악

### 4. 성능 고려사항
- **메모리 사용량**: 전역변수는 프로그램 종료까지 메모리 점유
- **접근 속도**: 지역변수는 스택에서 빠른 접근 가능
- **캐시 효율성**: 관련 데이터를 가까운 위치에 배치

이러한 개념들을 잘 이해하고 적절히 활용하면, 효율적이고 유지보수가 용이한 프로그램을 작성할 수 있습니다.