# 4.2 매개변수와 반환값

## 함수형 사고의 핵심: 입력과 출력의 철학

### 매개변수와 인수: 형식과 실체의 관계론

프로그래밍에서 **매개변수(Parameter)**와 **인수(Argument)**의 구분은 단순한 용어 문제가 아니라 **추상화와 구체화**의 철학적 차이를 반영합니다.

**매개변수**는 함수 정의에서 사용되는 **형식적 매개체(Formal Parameter)**로서, **추상적 개념**입니다. 이는 플라톤의 이데아론에서 말하는 **완전한 형태**와 유사하며, 함수가 **어떤 종류의 데이터를 받을 수 있는지**를 정의하는 **템플릿**입니다.

**인수**는 함수 호출 시 전달되는 **실제 매개체(Actual Parameter)**로서, **구체적 실체**입니다. 이는 현실 세계의 **구체적 객체**에 해당하며, 실제로 **메모리에 존재하는 데이터**입니다.

이러한 구분은 **컴퓨터 과학의 바인딩(Binding) 이론**과 직결됩니다. 매개변수는 **정적 바인딩(Static Binding)**을 통해 컴파일 시점에 타입이 결정되고, 인수는 **동적 바인딩(Dynamic Binding)**을 통해 런타임에 값이 바인딩됩니다.

```c
int add(int a, int b) {    // a, b: 형식적 매개변수 (추상)
    return a + b;          // 논리적 연산 정의
}
// add(x, y) 호출 시 x, y: 실제 인수 (구체)
```

### 값에 의한 호출: 불변성과 순수성의 원리

C언어의 **값에 의한 호출(Call by Value)** 방식은 **함수형 프로그래밍의 순수성(Purity) 원칙**과 **객체지향 프로그래밍의 불변성(Immutability) 원칙**을 동시에 반영하는 근본적 설계 철학입니다.

#### 불변성의 보장 메커니즘

값에 의한 호출은 **데이터의 불변성**을 자연스럽게 보장합니다. 함수가 매개변수를 수정하더라도 **원본 데이터는 절대 변경되지 않으며**, 이는 다음과 같은 **소프트웨어 공학적 이점**을 제공합니다:

1. **참조 투명성(Referential Transparency)**: 동일한 입력에 대해 항상 동일한 결과 보장
2. **부작용 없음(Side Effect Free)**: 함수 외부 상태에 영향을 주지 않음
3. **스레드 안전성(Thread Safety)**: 동시성 환경에서 안전한 실행
4. **테스트 용이성**: 예측 가능한 동작으로 테스트가 간단함

#### 메모리 격리의 안전 장치

**스택 프레임 기반의 메모리 격리**는 각 함수 호출이 **독립적인 메모리 공간**을 갖도록 보장합니다. 이는 **샌드박스(Sandbox) 개념**의 원시적 구현으로, 함수 간의 **의도하지 않은 간섭**을 원천적으로 차단합니다.

```c
// 값에 의한 전달 예제: 안전한 데이터 처리
void process_data(int value) {
    value *= 2;  // 복사본만 수정됨 - 원본 안전
}

int main() {
    int original = 10;
    process_data(original);
    printf("%d\n", original);  // 여전히 10 출력
    return 0;
}
// 원본 데이터는 불변성 보장
```

## 반환값: 함수의 존재 이유와 가치 창조

### 반환값의 존재론적 의미

함수의 **반환값(Return Value)**은 단순한 데이터 전달 메커니즘을 넘어서 **함수의 존재 이유**를 규정하는 핵심 요소입니다. 이는 **수학적 함수의 치역(Range) 개념**과 직결되며, **입력을 출력으로 변환하는 순수한 변환 관계**를 정의합니다.

#### 단일 반환값의 설계 철학

C언어에서 함수가 **단일 값만 반환**할 수 있다는 제약은 **복잡성 제어**와 **개념적 명확성**을 위한 의도적 설계입니다. 이는 다음과 같은 **소프트웨어 공학 원칙**을 반영합니다:

1. **단일 책임 원칙(Single Responsibility Principle)**: 하나의 함수는 하나의 명확한 결과를 생성
2. **인터페이스 단순성(Interface Simplicity)**: 복잡한 다중 반환값보다 명확한 단일 반환값
3. **합성 가능성(Composability)**: 함수의 반환값이 다른 함수의 입력으로 자연스럽게 연결
4. **타입 안전성(Type Safety)**: 컴파일 시점에서 반환 타입 검증 가능

#### 함수 종료와 제어 흐름

`return` 문은 **조건부 실행 흐름**을 자연스럽게 구현하는 **제어 구조**입니다. 이는 **조기 반환(Early Return) 패턴**을 통해 **중첩된 조건문의 복잡성**을 줄이고 **가독성**을 높입니다.

```c
// 조기 반환으로 복잡성 제거
int divide_safe(int a, int b) {
    if (b == 0) return 0;     // 예외 상황 즉시 처리
    return a / b;             // 정상 로직 실행
}
```

### void 타입: 행위의 순수성과 부작용의 명시

`void` 타입 함수는 **값 반환이 아닌 행위 수행**을 명시적으로 선언하는 **의도적 설계 선택**입니다. 이는 **함수형 프로그래밍과 명령형 프로그래밍**의 경계를 명확히 하는 **타입 시스템의 철학적 표현**입니다.

#### void 함수의 존재론적 역할

`void` 함수는 **부작용(Side Effect)**을 명시적으로 허용하고 **상태 변경**을 주목적으로 하는 함수입니다. 이는 다음과 같은 **설계 의도**를 반영합니다:

1. **명령형 패러다임**: 데이터 변환보다 상태 변경이 목적
2. **부작용 명시**: 함수가 외부 상태에 영향을 줄 수 있음을 타입으로 선언
3. **절차적 추상화**: 복잡한 절차를 하나의 의미 있는 단위로 추상화
4. **인터페이스 단순화**: 복잡한 상태 변경을 단순한 함수 호출로 캡슐화

#### 행위 중심 설계의 가치

`void` 함수는 **"무엇을 반환하느냐"**보다 **"무엇을 수행하느냐"**에 초점을 맞춘 설계 철학을 보여줍니다. 이는 **객체지향 프로그래밍의 메서드 개념**과 유사하며, **캡슐화된 동작**을 제공합니다.

```c
void initialize_system() {  // 시스템 초기화 - 행위에 집중
    // 복잡한 초기화 로직 수행
}  // 성공/실패보다 "초기화했다"는 사실이 중요
```

## 매개변수의 타입론과 의미론

### 기본 타입 매개변수: 값 의미론의 기초

**기본 데이터 타입**을 매개변수로 사용하는 것은 **값 의미론(Value Semantics)**의 가장 순수한 구현입니다. 각 타입은 고유한 **의미적 영역(Semantic Domain)**을 가지며, 함수는 이러한 **타입 안전성**을 통해 **논리적 오류**를 컴파일 시점에 방지합니다.

#### 타입별 의미적 특성

**정수 타입 매개변수**:
- **이산적 값 영역**: 셀 수 있는 정확한 수치 표현
- **무손실 연산**: 정수 연산의 정확성 보장
- **인덱싱과 카운팅**: 배열 인덱스, 반복 횟수 등에 사용

**실수 타입 매개변수**:
- **연속적 값 영역**: 실세계의 측정값 표현
- **근사적 특성**: 부동소수점의 한계 인식 필요
- **과학적 계산**: 물리량, 통계값 등에 활용

**문자 타입 매개변수**:
- **기호적 표현**: 추상적 기호 체계의 구현
- **인코딩 의존성**: ASCII, Unicode 등의 인코딩 방식
- **텍스트 처리**: 언어학적 분석의 기본 단위

```c
// 타입별 의미적 역할 명확화
int count_items(int quantity);        // 이산적 개수
double measure_distance(double km);   // 연속적 측정
char classify_grade(int score);       // 기호적 분류
```

### 배열 매개변수: 참조 의미론과 컬렉션 추상화

배열 매개변수는 C언어에서 **값 의미론의 예외**를 나타내며, **참조 의미론(Reference Semantics)**을 도입하는 **특별한 경우**입니다. 이는 **메모리 효율성과 성능 최적화**를 위한 **실용적 설계 결정**이면서 동시에 **컬렉션 추상화**의 기초를 제공합니다.

#### 배열 붕괴(Array Decay)의 철학

배열이 함수 매개변수로 전달될 때 발생하는 **배열 붕괴(Array Decay)**는 **구체적 타입에서 일반적 타입으로의 추상화**를 나타냅니다. 이는 다음과 같은 **개념적 변환**을 수반합니다:

1. **크기 정보의 소실**: 구체적 배열에서 일반적 포인터로
2. **경계 검사의 이양**: 컴파일러에서 프로그래머로 책임 전가
3. **유연성의 획득**: 다양한 크기의 배열을 동일한 함수로 처리
4. **성능의 최적화**: 복사 비용 없는 직접 접근

#### 컬렉션 연산의 추상화

배열 매개변수를 통한 함수는 **컬렉션 연산의 추상화**를 제공합니다. 이는 **고차원 함수(Higher-Order Functions)**의 원시적 형태로 볼 수 있으며, 다음과 같은 **함수적 패턴**을 구현합니다:

- **Map 연산**: 각 원소에 동일한 변환 적용
- **Reduce 연산**: 전체 배열을 단일 값으로 축약
- **Filter 연산**: 조건에 맞는 원소만 선택
- **Find 연산**: 특정 조건을 만족하는 원소 탐색

```c
// 컬렉션 연산의 추상화
int reduce_sum(int arr[], int size);     // Reduce: 합계
int find_max(int arr[], int size);       // Find: 최대값
void map_double(int arr[], int size);    // Map: 두배 변환
```

### 포인터 매개변수: 간접성과 가변성의 도구

포인터 매개변수는 **값 의미론의 한계를 극복**하고 **참조 의미론을 명시적으로 구현**하는 **고급 프로그래밍 기법**입니다. 이는 **간접성(Indirection)**이라는 컴퓨터 과학의 핵심 개념을 활용하여 **메모리 주소를 통한 원격 조작**을 가능하게 합니다.

#### 간접성의 철학적 의미

포인터는 **직접적 값 조작**에서 **간접적 주소 조작**으로의 **패러다임 전환**을 나타냅니다. 이는 다음과 같은 **개념적 추상화**를 제공합니다:

1. **위치 추상화**: 데이터의 물리적 위치와 논리적 접근의 분리
2. **소유권 모호성**: 누가 메모리를 관리하는가의 복잡성
3. **별명 문제(Aliasing)**: 하나의 메모리를 여러 이름으로 접근
4. **생명주기 독립성**: 포인터와 대상 객체의 서로 다른 생명주기

#### 다중 반환값의 시뮬레이션

포인터 매개변수의 가장 실용적인 활용은 **다중 반환값의 시뮬레이션**입니다. C언어의 **단일 반환값 제약**을 우회하여 **의미적으로 관련된 여러 결과**를 한 번에 반환할 수 있게 합니다.

이는 **함수형 프로그래밍의 튜플(Tuple) 개념**을 **명령형 언어에서 구현**하는 방법론이며, **구조적 분해(Destructuring)**의 원시적 형태로 볼 수 있습니다.

```c
// 다중 결과 반환의 시뮬레이션
void analyze_data(int data[], int size,
                 int *min, int *max, double *avg);
// 하나의 함수에서 최솟값, 최댓값, 평균을 모두 계산
```

#### 상태 변경의 명시적 의도

포인터 매개변수는 **함수가 외부 상태를 변경할 의도**를 **타입 시스템을 통해 명시적으로 표현**합니다. 이는 **부작용이 있는 함수**와 **부작용이 없는 함수**를 **인터페이스 레벨에서 구분**할 수 있게 해주는 **설계적 장치**입니다.

## 입출력 관계의 설계론: 변환과 소통의 모델

### 함수의 정보 이론적 모델

함수는 **정보 이론(Information Theory)**의 관점에서 **입력 신호를 출력 신호로 변환하는 변환기(Transformer)**로 이해할 수 있습니다. 이는 **클로드 섀넌(Claude Shannon)의 통신 모델**을 프로그래밍 영역에 적용한 것으로, 다음과 같은 **정보 처리 단계**를 거칩니다:

1. **인코딩(Encoding)**: 실세계 문제를 프로그램 매개변수로 변환
2. **처리(Processing)**: 알고리즘을 통한 정보 변환
3. **디코딩(Decoding)**: 프로그램 결과를 실세계 해답으로 해석
4. **피드백(Feedback)**: 반환값을 통한 결과 확인

#### 입력의 의미론: 문제 공간의 추상화

매개변수는 **문제 영역(Problem Domain)**에서 **해법 영역(Solution Domain)**으로의 **추상화 다리** 역할을 합니다. 이는 **도메인 모델링(Domain Modeling)**의 핵심으로, 복잡한 현실 문제를 **계산 가능한 형태**로 변환하는 과정입니다.

#### 출력의 가치론: 해답의 구체화

반환값은 **추상적 계산 결과**를 **실용적 해답**으로 변환하는 **구체화(Concretization) 과정**입니다. 이는 **값의 창조**로서, 입력보다 **더 높은 정보 가치**를 제공해야 합니다.

### 상태 기반 vs 함수형 설계 패턴

#### 상태 기반 설계 (포인터 매개변수)
```c
void process_inplace(Data *data);  // 데이터 변경
```
- **장점**: 메모리 효율성, 성능 최적화
- **단점**: 부작용, 디버깅 어려움, 동시성 문제

#### 함수형 설계 (값 반환)
```c
Data process_pure(Data input);     // 새 데이터 반환
```
- **장점**: 예측 가능성, 테스트 용이성, 합성 가능성
- **단점**: 메모리 비용, 복사 오버헤드

### 인터페이스 설계의 균형점

효과적인 함수 인터페이스는 **표현력(Expressiveness)**과 **효율성(Efficiency)** 사이의 **최적 균형점**을 찾아야 합니다:

- **단순 변환**: 값 매개변수 + 값 반환
- **복합 결과**: 포인터 매개변수를 통한 다중 출력
- **상태 관리**: 구조체 포인터를 통한 캡슐화된 상태 조작
- **오류 처리**: 반환값을 통한 성공/실패 상태 전달

## 함수 시그니처: 인터페이스의 계약론

### 시그니처의 존재론적 의미

**함수 시그니처(Function Signature)**는 **타입 이론(Type Theory)**에서 함수의 **본질적 정체성**을 규정하는 **형식적 계약**입니다. 이는 **법학의 계약서**와 유사하게, 함수가 **무엇을 받고 무엇을 줄 것인가**를 **컴파일 시점에서 보장**하는 **정적 계약**입니다.

#### 타입 안전성의 보장 체계

함수 시그니처는 **타입 안전성(Type Safety)**을 구현하는 **컴파일러의 검증 도구**입니다. 이는 다음과 같은 **오류 방지 메커니즘**을 제공합니다:

1. **인수 개수 검증**: 필요한 만큼의 데이터가 제공되는지 확인
2. **타입 호환성 검증**: 올바른 데이터 타입이 전달되는지 확인
3. **순서 일치성 검증**: 매개변수 순서에 따른 의미 일치성 확인
4. **반환 타입 검증**: 기대되는 결과 타입과의 일치성 확인

#### 매개변수 순서의 의미론

매개변수의 **순서**는 단순한 배치가 아니라 **의미적 우선순위**와 **논리적 구조**를 반영합니다. 이는 **언어학의 어순 연구**와 유사하게, **정보의 중요도**와 **처리 순서**를 나타냅니다:

```c
// 의미적 우선순위 반영
double calculate_bmi(double weight, double height);
//                   주체(체중)    기준(키)

void transfer_money(Account *from, Account *to, double amount);
//                  출발지       목적지       객체(금액)
```

### 오버로딩의 부재와 명명의 중요성

C언어는 **함수 오버로딩**을 지원하지 않아 **동일한 이름의 함수**가 **다른 시그니처**를 가질 수 없습니다. 이는 **명명의 중요성**을 강조하며, 함수명이 **의도와 기능을 명확히 표현**해야 함을 의미합니다.

이러한 제약은 **명명 규칙의 일관성**과 **인터페이스 설계의 신중함**을 요구하며, 결과적으로 **더 명확하고 예측 가능한 API**를 만들어냅니다.

## 메모리 모델과 호출 규약의 심층 이론

### 스택 프레임: 함수 호출의 물리적 구현

함수 호출은 **추상적 개념**이지만 **스택 프레임(Stack Frame)**이라는 **물리적 메모리 구조**를 통해 구현됩니다. 이는 **하드웨어와 소프트웨어의 만남**으로, **CPU의 스택 포인터**와 **컴파일러의 호출 규약**이 협력하여 만들어내는 **시스템 수준의 추상화**입니다.

#### 호출 규약(Calling Convention)의 철학

호출 규약은 **함수 간 소통의 프로토콜**입니다. 이는 **외교적 예의**처럼, 함수들이 **서로를 존중하며 정보를 교환**하는 방식을 정의합니다:

1. **매개변수 전달 순서**: 스택에 push하는 순서 (주로 오른쪽부터)
2. **스택 정리 책임**: 호출자 vs 피호출자 중 누가 스택을 정리하는가
3. **레지스터 사용 규칙**: 어떤 레지스터를 사용하고 보존해야 하는가
4. **반환값 전달 방법**: 레지스터 vs 메모리를 통한 반환

#### 메모리 주소의 의미론적 분석

매개변수와 인수의 **메모리 주소 차이**는 **값 의미론**의 **물리적 증거**입니다. 동일한 값이지만 **서로 다른 메모리 위치**에 존재한다는 사실은 **복사의 실증적 증명**이며, 이는 **함수 간 격리**와 **데이터 안전성**의 **하드웨어 수준 보장**을 의미합니다.

### 성능과 메모리의 트레이드오프

#### 값 복사의 비용 분석

값에 의한 호출의 **메모리 비용**은 **데이터 크기에 선형적으로 비례**합니다. 이는 다음과 같은 **성능 영향**을 미칩니다:

- **작은 데이터 타입** (int, char, float): 복사 비용 < 간접 접근 비용
- **중간 크기 구조체**: 컴파일러 최적화에 따라 결정
- **대형 데이터 구조**: 포인터 전달이 필수적

#### 캐시 지역성(Cache Locality)의 고려

스택 기반의 매개변수 전달은 **시간적 지역성(Temporal Locality)**과 **공간적 지역성(Spatial Locality)**을 모두 만족하여 **CPU 캐시 효율성**을 극대화합니다. 연속적인 함수 호출에서 **동일한 스택 영역**을 재사용함으로써 **메모리 계층구조**의 이점을 활용합니다.

## 시스템 설계의 실무적 적용

### 모듈화된 함수 설계의 원칙

실제 소프트웨어 개발에서 매개변수와 반환값의 설계는 **시스템 아키텍처**의 핵심을 이룹니다. 효과적인 함수 인터페이스는 다음과 같은 **설계 원칙**을 따라야 합니다:

#### 단일 책임 원칙 (Single Responsibility Principle)
각 함수는 **하나의 명확한 목적**만을 가져야 합니다. 이는 **매개변수의 의미적 응집성**과 **반환값의 일관성**으로 구현됩니다.

#### 인터페이스 분리 원칙 (Interface Segregation Principle)
함수는 **필요한 매개변수만** 받아야 하며, **불필요한 의존성**을 피해야 합니다. 이는 **매개변수 목록의 최소화**와 **의미 있는 그룹핑**으로 달성됩니다.

#### 의존성 역전 원칙 (Dependency Inversion Principle)
구체적인 데이터 타입보다 **추상적인 인터페이스**에 의존해야 합니다. C언어에서는 **함수 포인터**와 **일반적인 데이터 타입**을 통해 구현됩니다.

### 오류 처리와 견고성 설계

실무에서는 **정상적인 경우**뿐만 아니라 **예외적인 상황**도 고려해야 합니다:

#### 반환값을 통한 상태 전달
```c
typedef enum {
    SUCCESS = 0,
    ERROR_INVALID_INPUT = -1,
    ERROR_OUT_OF_MEMORY = -2,
    ERROR_FILE_NOT_FOUND = -3
} ResultCode;

ResultCode process_data(const Data *input, Data *output);
```

#### 매개변수 검증의 계층화
1. **타입 수준 검증**: 컴파일러에 의한 자동 검증
2. **값 범위 검증**: 런타임 검증과 조기 반환
3. **비즈니스 논리 검증**: 도메인 규칙에 따른 검증
4. **시스템 자원 검증**: 메모리, 파일 등 시스템 자원 확인

### 성능 최적화의 고려사항

#### 메모리 할당 전략
- **스택 할당**: 작은 데이터, 짧은 생명주기
- **정적 할당**: 글로벌 상태, 긴 생명주기
- **동적 할당**: 가변 크기, 유연한 생명주기

#### 캐시 친화적 설계
- **데이터 지역성**: 관련 데이터를 가까운 위치에 배치
- **접근 패턴**: 순차적 접근을 선호하는 알고리즘 설계
- **크기 최적화**: 캐시 라인에 맞는 데이터 구조 설계

## 매개변수와 반환값의 철학적 결론

### 소프트웨어 공학의 기본 원리로서의 의미

매개변수와 반환값은 단순한 **프로그래밍 메커니즘**을 넘어서 **소프트웨어 공학의 기본 원리**를 구현하는 도구입니다. 이들은 **모듈성**, **재사용성**, **테스트 가능성**, **유지보수성**이라는 **소프트웨어 품질의 네 기둥**을 지탱하는 **구조적 요소**입니다.

### 추상화와 캡슐화의 도구

함수의 매개변수와 반환값은 **정보 은닉**과 **인터페이스 추상화**의 핵심 메커니즘입니다. 이들은 **복잡한 내부 구현**을 숨기고 **단순하고 명확한 인터페이스**만을 노출함으로써 **인지적 부담을 줄이고** **시스템의 이해 가능성을 높입니다**.

### 계약적 프로그래밍의 기초

**함수 시그니처**는 **계약적 프로그래밍(Design by Contract)**의 기본 형태입니다. 매개변수는 **전제조건(Precondition)**을, 반환값은 **후속조건(Postcondition)**을 나타내며, 이를 통해 **함수의 행동을 예측 가능하게** 만듭니다.

### 함수형 사고의 출발점

값에 의한 호출과 순수한 반환값은 **함수형 프로그래밍의 핵심 개념**인 **참조 투명성**과 **부작용 없는 계산**의 기초를 제공합니다. 이는 **더 안전하고 예측 가능한 코드**를 작성하는 **사고방식의 전환점**이 됩니다.

### 성장하는 프로그래머를 위한 지침

#### 초급 단계: 문법적 이해
- 매개변수와 반환값의 **기본 문법** 습득
- **값에 의한 호출**의 안전성 체험
- **단순한 변환 함수** 작성 연습

#### 중급 단계: 설계적 사고
- **함수 시그니처**를 통한 **인터페이스 설계**
- **포인터 매개변수**를 통한 **효율적 데이터 처리**
- **오류 처리**와 **견고성** 고려

#### 고급 단계: 아키텍처적 관점
- **시스템 전체의 일관성** 있는 인터페이스 설계
- **성능과 가독성의 균형** 잡힌 선택
- **도메인 모델링**을 반영한 함수 설계

### 미래 지향적 프로그래밍

현대 프로그래밍 언어들이 도입한 **다양한 매개변수 전달 방식**과 **고급 타입 시스템**의 **이론적 기초**는 모두 C언어의 단순하지만 근본적인 매개변수와 반환값 개념에서 출발합니다.

**함수 오버로딩**, **기본 매개변수**, **가변 매개변수**, **명명된 매개변수** 등의 현대적 기능들을 이해하고 활용하기 위해서는 **C언어의 기본 원리**에 대한 **깊이 있는 이해**가 필수적입니다.

이러한 **근본적 개념의 체득**은 **어떤 프로그래밍 언어를 사용하든** **효과적이고 우아한 함수를 설계할 수 있는 능력**의 기반이 됩니다.

## 실용적 예제: 개념의 구현

### 매개변수 전달 방식 비교

```c
#include <stdio.h>

// 값에 의한 전달: 원본 보호
int square_value(int n) {
    n = n * n;  // 복사본만 변경
    return n;
}

// 포인터를 통한 다중 반환값
void calculate_stats(int arr[], int size, int *min, int *max, double *avg) {
    *min = *max = arr[0];
    int sum = 0;

    for (int i = 0; i < size; i++) {
        if (arr[i] < *min) *min = arr[i];
        if (arr[i] > *max) *max = arr[i];
        sum += arr[i];
    }
    *avg = (double)sum / size;
}

// 오류 처리가 포함된 함수
typedef enum { SUCCESS, ERROR_DIVIDE_BY_ZERO, ERROR_NEGATIVE } Result;

Result safe_sqrt(double input, double *result) {
    if (input < 0) return ERROR_NEGATIVE;

    *result = sqrt(input);
    return SUCCESS;
}

int main() {
    // 값에 의한 전달 예제
    int original = 5;
    int squared = square_value(original);
    printf("원본: %d, 제곱: %d\n", original, squared);

    // 다중 반환값 예제
    int data[] = {3, 7, 1, 9, 4};
    int min, max;
    double avg;
    calculate_stats(data, 5, &min, &max, &avg);
    printf("최솟값: %d, 최댓값: %d, 평균: %.2f\n", min, max, avg);

    // 오류 처리 예제
    double input = 16.0, output;
    Result status = safe_sqrt(input, &output);
    if (status == SUCCESS) {
        printf("√%.1f = %.2f\n", input, output);
    }

    return 0;
}
```

이 예제는 **매개변수와 반환값의 다양한 활용 방식**을 보여주며, **이론적 개념의 실제 구현**을 제시합니다.