# 4.2 매개변수와 반환값

## 개념의 이해

### 매개변수(Parameter)와 인수(Argument)의 구분

프로그래밍에서 종종 혼동되는 두 용어를 명확히 구분해야 합니다.

- **매개변수(Parameter)**: 함수를 정의할 때 선언하는 변수
- **인수(Argument)**: 함수를 호출할 때 실제로 전달하는 값

```c
// add 함수 정의
int add(int a, int b) {    // a, b는 매개변수(Parameter)
    return a + b;
}

int main() {
    int x = 5, y = 3;
    int result = add(x, y);  // x, y는 인수(Argument)
    return 0;
}
```

### 값에 의한 호출 (Call by Value)

C언어는 기본적으로 **값에 의한 호출** 방식을 사용합니다. 이는 함수 호출 시 인수의 **복사본**이 매개변수로 전달된다는 의미입니다.

#### 핵심 특징:
1. **원본 데이터 보호**: 함수 내에서 매개변수를 수정해도 원본 변수에는 영향이 없습니다.
2. **메모리 독립성**: 매개변수와 인수는 서로 다른 메모리 공간을 사용합니다.
3. **스택 기반 전달**: 각 매개변수는 함수의 스택 프레임에 복사됩니다.

```c
#include <stdio.h>

void modify_value(int x) {
    printf("함수 내부 - 수정 전: %d\n", x);
    x = 100;
    printf("함수 내부 - 수정 후: %d\n", x);
}

int main() {
    int num = 50;
    printf("함수 호출 전: %d\n", num);

    modify_value(num);  // num의 복사본이 전달됨

    printf("함수 호출 후: %d\n", num);  // num은 변경되지 않음
    return 0;
}
```

**출력 결과:**
```
함수 호출 전: 50
함수 내부 - 수정 전: 50
함수 내부 - 수정 후: 100
함수 호출 후: 50
```

## 반환값(Return Value)의 이해

### 반환값의 개념적 의미

함수의 반환값은 함수가 수행한 작업의 **결과물**입니다. 함수는 하나의 값만 반환할 수 있으며, 이 값은 함수 호출 표현식의 결과가 됩니다.

#### 반환값의 특징:
1. **단일 값**: 함수는 하나의 값만 반환 가능
2. **타입 일치**: 반환값의 타입은 함수의 반환 타입과 일치해야 함
3. **함수 종료**: return 문이 실행되면 함수가 즉시 종료됨

```c
#include <stdio.h>

// 원의 넓이를 계산하는 함수
double calculate_circle_area(double radius) {
    const double PI = 3.14159;
    double area = PI * radius * radius;
    return area;  // 계산된 넓이를 반환
}

// 두 수 중 최대값을 반환하는 함수
int max(int a, int b) {
    if (a > b) {
        return a;  // 조건에 따라 다른 값 반환
    } else {
        return b;
    }
}

int main() {
    double radius = 5.0;
    double area = calculate_circle_area(radius);
    printf("반지름 %.1f인 원의 넓이: %.2f\n", radius, area);

    int num1 = 15, num2 = 23;
    int maximum = max(num1, num2);
    printf("%d와 %d 중 최대값: %d\n", num1, num2, maximum);

    return 0;
}
```

### void 타입과 반환값

`void` 타입 함수는 값을 반환하지 않습니다. 이런 함수는 **작업 수행**이 주목적이며, 결과를 반환값으로 전달하지 않습니다.

```c
#include <stdio.h>

// 값을 반환하지 않는 함수
void print_greeting(char name[]) {
    printf("안녕하세요, %s님!\n", name);
    // return; 생략 가능 (자동으로 함수 끝에서 반환)
}

// 배열의 모든 원소를 출력하는 함수
void print_array(int arr[], int size) {
    printf("배열 원소: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    print_greeting("김철수");

    int numbers[] = {1, 2, 3, 4, 5};
    print_array(numbers, 5);

    return 0;
}
```

## 매개변수의 다양한 형태

### 1. 기본 데이터 타입 매개변수

```c
#include <stdio.h>

// 정수 타입 매개변수
int calculate_power(int base, int exponent) {
    int result = 1;
    for (int i = 0; i < exponent; i++) {
        result *= base;
    }
    return result;
}

// 실수 타입 매개변수
double calculate_average(double a, double b, double c) {
    return (a + b + c) / 3.0;
}

// 문자 타입 매개변수
int is_vowel(char ch) {
    char vowels[] = "aeiouAEIOU";
    for (int i = 0; vowels[i] != '\0'; i++) {
        if (ch == vowels[i]) {
            return 1;  // 참 (모음임)
        }
    }
    return 0;  // 거짓 (자음임)
}

int main() {
    printf("2^3 = %d\n", calculate_power(2, 3));
    printf("평균: %.2f\n", calculate_average(85.5, 92.0, 78.5));
    printf("'a'는 모음인가? %s\n", is_vowel('a') ? "예" : "아니오");

    return 0;
}
```

### 2. 배열 매개변수

배열을 매개변수로 전달할 때는 **배열의 주소**가 전달됩니다. 이는 값에 의한 호출과는 다른 **참조에 의한 호출**의 형태입니다.

```c
#include <stdio.h>

// 배열의 합을 계산하는 함수
int sum_array(int arr[], int size) {
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum;
}

// 배열의 모든 원소를 두 배로 만드는 함수
void double_array(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] *= 2;  // 원본 배열이 수정됨
    }
}

// 배열에서 최대값을 찾는 함수
int find_max(int arr[], int size) {
    int max = arr[0];
    for (int i = 1; i < size; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

int main() {
    int numbers[] = {10, 25, 30, 15, 40};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    printf("배열의 합: %d\n", sum_array(numbers, size));
    printf("최대값: %d\n", find_max(numbers, size));

    printf("두 배로 만들기 전: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");

    double_array(numbers, size);

    printf("두 배로 만든 후: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");

    return 0;
}
```

### 3. 포인터 매개변수

포인터를 사용하면 함수 내에서 원본 변수의 값을 **직접 수정**할 수 있습니다.

```c
#include <stdio.h>

// 두 변수의 값을 교환하는 함수
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 변수의 값을 증가시키는 함수
void increment(int *num) {
    (*num)++;
}

// 나눗셈의 몫과 나머지를 동시에 구하는 함수
void divide(int dividend, int divisor, int *quotient, int *remainder) {
    *quotient = dividend / divisor;
    *remainder = dividend % divisor;
}

int main() {
    int x = 10, y = 20;
    printf("교환 전: x = %d, y = %d\n", x, y);
    swap(&x, &y);
    printf("교환 후: x = %d, y = %d\n", x, y);

    int count = 0;
    printf("증가 전: %d\n", count);
    increment(&count);
    printf("증가 후: %d\n", count);

    int quotient, remainder;
    divide(17, 5, &quotient, &remainder);
    printf("17 ÷ 5 = %d ... %d\n", quotient, remainder);

    return 0;
}
```

## 매개변수와 반환값의 관계

### 입력-처리-출력 패턴

함수는 본질적으로 **입력-처리-출력** 패턴을 따릅니다:
- **입력**: 매개변수를 통해 데이터를 받음
- **처리**: 함수 내부에서 로직을 수행
- **출력**: 반환값으로 결과를 전달

```c
#include <stdio.h>
#include <math.h>

// 이차방정식의 판별식을 계산하는 함수
double discriminant(double a, double b, double c) {
    return b * b - 4 * a * c;
}

// 이차방정식의 해를 구하는 함수
int solve_quadratic(double a, double b, double c, double *root1, double *root2) {
    double disc = discriminant(a, b, c);

    if (disc < 0) {
        return 0;  // 실근 없음
    } else if (disc == 0) {
        *root1 = *root2 = -b / (2 * a);
        return 1;  // 중근
    } else {
        *root1 = (-b + sqrt(disc)) / (2 * a);
        *root2 = (-b - sqrt(disc)) / (2 * a);
        return 2;  // 서로 다른 두 실근
    }
}

int main() {
    double a = 1.0, b = -5.0, c = 6.0;  // x² - 5x + 6 = 0
    double root1, root2;

    int result = solve_quadratic(a, b, c, &root1, &root2);

    printf("이차방정식 %.1fx² + %.1fx + %.1f = 0\n", a, b, c);

    switch (result) {
        case 0:
            printf("실근이 존재하지 않습니다.\n");
            break;
        case 1:
            printf("중근: x = %.2f\n", root1);
            break;
        case 2:
            printf("두 실근: x₁ = %.2f, x₂ = %.2f\n", root1, root2);
            break;
    }

    return 0;
}
```

## 고급 개념: 함수 시그니처

### 함수 시그니처의 정의

함수 시그니처(Function Signature)는 함수를 고유하게 식별하는 요소들의 조합입니다:
1. **함수 이름**
2. **매개변수의 개수**
3. **각 매개변수의 타입**
4. **매개변수의 순서**

```c
#include <stdio.h>

// 같은 이름이지만 다른 시그니처를 가진 함수들
void print_info(int age) {
    printf("나이: %d세\n", age);
}

void print_info_detailed(int age, double height, double weight) {
    printf("나이: %d세, 키: %.1fcm, 몸무게: %.1fkg\n", age, height, weight);
}

// 매개변수 순서가 중요함을 보여주는 예
double calculate_bmi(double weight, double height) {
    return weight / (height * height);
}

int main() {
    print_info(25);
    print_info_detailed(25, 175.5, 70.2);

    double bmi = calculate_bmi(70.2, 1.755);  // 순서 주의: 몸무게, 키
    printf("BMI: %.1f\n", bmi);

    return 0;
}
```

## 매개변수 전달 방식의 메모리 관점

### 스택 프레임과 매개변수

함수 호출 시 메모리 스택에서 일어나는 과정을 이해하는 것이 중요합니다:

```c
#include <stdio.h>

void demonstrate_stack(int a, int b, int c) {
    int local_var = 100;

    printf("매개변수 a의 주소: %p\n", &a);
    printf("매개변수 b의 주소: %p\n", &b);
    printf("매개변수 c의 주소: %p\n", &c);
    printf("지역변수의 주소: %p\n", &local_var);
}

int main() {
    int x = 10, y = 20, z = 30;

    printf("main에서 x의 주소: %p\n", &x);
    printf("main에서 y의 주소: %p\n", &y);
    printf("main에서 z의 주소: %p\n", &z);
    printf("---함수 호출---\n");

    demonstrate_stack(x, y, z);

    return 0;
}
```

## 실전 예제: 학생 성적 관리 시스템

매개변수와 반환값의 개념을 종합적으로 활용한 예제입니다:

```c
#include <stdio.h>

#define MAX_STUDENTS 100

// 학생 수를 입력받는 함수
int get_student_count() {
    int count;
    do {
        printf("학생 수를 입력하세요 (1-%d): ", MAX_STUDENTS);
        scanf("%d", &count);
        if (count < 1 || count > MAX_STUDENTS) {
            printf("올바른 범위의 수를 입력해주세요.\n");
        }
    } while (count < 1 || count > MAX_STUDENTS);
    return count;
}

// 성적을 입력받는 함수
void input_scores(double scores[], int count) {
    printf("\n성적을 입력해주세요:\n");
    for (int i = 0; i < count; i++) {
        do {
            printf("학생 %d의 성적 (0-100): ", i + 1);
            scanf("%lf", &scores[i]);
            if (scores[i] < 0 || scores[i] > 100) {
                printf("성적은 0-100 사이여야 합니다.\n");
            }
        } while (scores[i] < 0 || scores[i] > 100);
    }
}

// 평균을 계산하는 함수
double calculate_average(double scores[], int count) {
    double sum = 0.0;
    for (int i = 0; i < count; i++) {
        sum += scores[i];
    }
    return sum / count;
}

// 최고점을 찾는 함수
double find_maximum(double scores[], int count) {
    double max = scores[0];
    for (int i = 1; i < count; i++) {
        if (scores[i] > max) {
            max = scores[i];
        }
    }
    return max;
}

// 최저점을 찾는 함수
double find_minimum(double scores[], int count) {
    double min = scores[0];
    for (int i = 1; i < count; i++) {
        if (scores[i] < min) {
            min = scores[i];
        }
    }
    return min;
}

// 통계를 출력하는 함수
void print_statistics(double scores[], int count) {
    double avg = calculate_average(scores, count);
    double max = find_maximum(scores, count);
    double min = find_minimum(scores, count);

    printf("\n=== 성적 통계 ===\n");
    printf("학생 수: %d명\n", count);
    printf("평균 점수: %.2f점\n", avg);
    printf("최고 점수: %.2f점\n", max);
    printf("최저 점수: %.2f점\n", min);
    printf("점수 범위: %.2f점\n", max - min);
}

// 등급을 계산하는 함수
char calculate_grade(double score) {
    if (score >= 90) return 'A';
    else if (score >= 80) return 'B';
    else if (score >= 70) return 'C';
    else if (score >= 60) return 'D';
    else return 'F';
}

// 각 학생의 등급을 출력하는 함수
void print_grades(double scores[], int count) {
    printf("\n=== 개별 성적 및 등급 ===\n");
    for (int i = 0; i < count; i++) {
        char grade = calculate_grade(scores[i]);
        printf("학생 %d: %.2f점 (%c등급)\n", i + 1, scores[i], grade);
    }
}

int main() {
    double scores[MAX_STUDENTS];

    printf("=== 학생 성적 관리 시스템 ===\n");

    // 1. 학생 수 입력
    int student_count = get_student_count();

    // 2. 성적 입력
    input_scores(scores, student_count);

    // 3. 통계 출력
    print_statistics(scores, student_count);

    // 4. 개별 등급 출력
    print_grades(scores, student_count);

    return 0;
}
```

## 핵심 개념 정리

### 1. 매개변수 전달 메커니즘
- **값에 의한 호출**: 기본 데이터 타입은 복사본이 전달됨
- **참조에 의한 호출**: 배열과 포인터는 주소가 전달됨

### 2. 반환값의 역할
- 함수의 계산 결과를 호출자에게 전달
- 함수의 성공/실패 상태를 나타내는 지표
- 하나의 값만 반환 가능 (여러 값은 포인터 매개변수 활용)

### 3. 함수 설계 원칙
- **단일 책임**: 하나의 함수는 하나의 작업만 수행
- **명확한 인터페이스**: 매개변수와 반환값의 의미가 명확해야 함
- **부작용 최소화**: 전역 변수 사용을 피하고 매개변수를 통해 데이터 전달

### 4. 메모리 효율성
- 큰 데이터 구조는 포인터로 전달하여 복사 비용 절약
- 불필요한 매개변수는 피하고 필요한 데이터만 전달
- 지역 변수의 생명주기를 이해하여 메모리 누수 방지

이러한 개념들을 확실히 이해하면, 효율적이고 유지보수가 용이한 C 프로그램을 작성할 수 있습니다.