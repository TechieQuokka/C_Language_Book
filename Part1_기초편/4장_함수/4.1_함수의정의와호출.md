# 4.1 함수의 정의와 호출 (Function Definition and Calling)

## 함수란 무엇인가?

함수(Function)는 **특정한 작업을 수행하는 독립적인 코드 블록**으로, 프로그래밍에서 가장 중요한 추상화 메커니즘 중 하나입니다. 이는 단순히 코드를 묶어놓은 것이 아니라, **문제를 작은 단위로 분해하고 해결하는 핵심 도구**입니다.

### 함수의 본질적 의미

함수는 수학의 함수 개념에서 유래했습니다:

**수학적 함수**: f(x) = 2x + 1
- 입력 x에 대해 명확한 출력을 생성
- 같은 입력에 대해 항상 같은 출력 (순수 함수)
- 복합 함수를 통한 복잡한 연산 구성

**프로그래밍 함수**: 이 개념을 확장하여
- **입력(매개변수)**: 함수가 작업할 데이터
- **처리(함수 본문)**: 수행할 작업의 구체적 내용
- **출력(반환값)**: 작업 결과 또는 상태 정보

### 함수가 해결하는 문제들

**1. 코드 중복 제거**
```c
// 함수 없이 (중복 코드)
int area1 = length1 * width1;
int area2 = length2 * width2;
int area3 = length3 * width3;

// 함수 사용
int calculate_area(int length, int width) {
    return length * width;
}

int area1 = calculate_area(length1, width1);
int area2 = calculate_area(length2, width2);
int area3 = calculate_area(length3, width3);
```

**2. 복잡성 관리**
```c
// 복잡한 작업을 작은 함수들로 분해
bool is_valid_email(const char *email) {
    return has_at_symbol(email) &&
           has_valid_domain(email) &&
           has_valid_local_part(email);
}
```

**3. 테스트 가능성**
- 각 함수를 독립적으로 테스트 가능
- 버그의 원인을 특정 함수로 격리
- 단위 테스트의 기본 단위

**4. 재사용성**
- 한 번 작성한 함수를 여러 곳에서 활용
- 라이브러리와 모듈의 기초
- 코드의 모듈화와 컴포넌트화

### 함수와 하드웨어의 관계

함수 호출은 CPU 레벨에서 **스택(Stack) 메커니즘**을 통해 구현됩니다:

**함수 호출 시:**
1. 현재 실행 위치(반환 주소) 저장
2. 매개변수를 스택에 푸시
3. 새로운 스택 프레임 생성
4. 함수 코드로 점프

**함수 반환 시:**
1. 반환값을 레지스터에 설정
2. 스택 프레임 제거
3. 저장된 반환 주소로 복귀

이러한 메커니즘으로 인해 함수 호출에는 약간의 오버헤드가 있지만, 현대 컴파일러는 **인라인 최적화**를 통해 이를 최소화합니다.

## 함수의 구조와 문법

### 함수의 기본 구조

C언어 함수는 다음과 같은 구조를 가집니다:

```c
반환타입 함수이름(매개변수목록) {
    // 함수 본문
    return 반환값;  // 선택적
}
```

**각 요소의 역할:**

**1. 반환타입 (Return Type)**
- 함수가 반환하는 값의 데이터 타입
- `void`: 반환값이 없음을 의미
- 모든 C 데이터 타입 사용 가능

**2. 함수이름 (Function Name)**
- 함수를 식별하는 고유한 이름
- C 언어 식별자 규칙을 따름
- 대소문자 구분

**3. 매개변수목록 (Parameter List)**
- 함수가 받을 입력의 타입과 이름
- 빈 괄호 `()` 또는 `(void)`: 매개변수 없음
- 여러 매개변수는 쉼표로 구분

**4. 함수 본문 (Function Body)**
- 중괄호로 둘러싸인 실행할 코드
- 지역 변수 선언과 실행문들
- `return` 문으로 값 반환 (선택적)

### 함수 정의의 다양한 형태

**1. 반환값이 있는 함수**
```c
#include <stdio.h>

// 두 정수의 합을 반환하는 함수
int add(int a, int b) {
    int sum = a + b;
    return sum;  // 계산 결과를 반환
}

// 더 간단한 형태
int multiply(int x, int y) {
    return x * y;  // 직접 반환
}

// 조건부 반환이 있는 함수
int absolute_value(int num) {
    if (num < 0) {
        return -num;  // 음수면 양수로 변환
    }
    return num;       // 양수면 그대로 반환
}
```

**2. 반환값이 없는 함수 (void 함수)**
```c
#include <stdio.h>

// 단순히 작업을 수행하고 반환값이 없는 함수
void print_greeting(const char *name) {
    printf("안녕하세요, %s님!\n", name);
    // return 문이 없어도 함수 끝에서 자동으로 반환
}

// 복잡한 출력 작업을 수행하는 함수
void print_multiplication_table(int num) {
    printf("%d단:\n", num);
    for (int i = 1; i <= 9; i++) {
        printf("%d × %d = %d\n", num, i, num * i);
    }
    printf("\n");
}

// 조건에 따라 조기 반환하는 void 함수
void print_positive_number(int num) {
    if (num <= 0) {
        printf("양수가 아닙니다.\n");
        return;  // 조기 반환 (값 없이)
    }
    printf("양수: %d\n", num);
}
```

**3. 매개변수가 없는 함수**
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 매개변수 없이 현재 시간을 반환
long get_current_timestamp(void) {
    return time(NULL);
}

// 랜덤 숫자를 생성하는 함수
int get_random_number(void) {
    return rand() % 100 + 1;  // 1-100 사이의 랜덤 수
}

// 사용자로부터 정수 입력을 받는 함수
int get_integer_input(void) {
    int value;
    printf("정수를 입력하세요: ");
    scanf("%d", &value);
    return value;
}
```

## 함수 호출과 실행 흐름

### 함수 호출의 기본 문법

```c
// 함수 호출의 일반적인 형태
반환값_변수 = 함수이름(인수1, 인수2, ...);

// 반환값이 없는 경우
함수이름(인수1, 인수2, ...);
```

### 함수 호출 예제

```c
#include <stdio.h>

// 함수 정의
int power(int base, int exponent) {
    int result = 1;
    for (int i = 0; i < exponent; i++) {
        result *= base;
    }
    return result;
}

void display_result(int value) {
    printf("결과: %d\n", value);
}

int main() {
    // 1. 반환값을 변수에 저장하는 호출
    int result1 = power(2, 3);        // 2^3 = 8
    int result2 = power(5, 2);        // 5^2 = 25

    // 2. 반환값을 직접 사용하는 호출
    printf("3^4 = %d\n", power(3, 4));

    // 3. 함수 호출 결과를 다른 함수의 인수로 사용
    display_result(power(2, 5));      // 2^5의 결과를 출력

    // 4. 복합 표현식에서의 함수 호출
    int sum = power(2, 2) + power(3, 2);  // 4 + 9 = 13

    return 0;
}
```

### 실행 흐름의 이해

```c
#include <stdio.h>

int calculate_square(int num) {
    printf("calculate_square 함수 시작: num = %d\n", num);
    int result = num * num;
    printf("calculate_square 함수 종료: result = %d\n", result);
    return result;
}

int main() {
    printf("main 함수 시작\n");

    printf("첫 번째 함수 호출 전\n");
    int square1 = calculate_square(5);
    printf("첫 번째 함수 호출 후: square1 = %d\n", square1);

    printf("두 번째 함수 호출 전\n");
    int square2 = calculate_square(7);
    printf("두 번째 함수 호출 후: square2 = %d\n", square2);

    printf("main 함수 종료\n");
    return 0;
}

/*
실행 결과:
main 함수 시작
첫 번째 함수 호출 전
calculate_square 함수 시작: num = 5
calculate_square 함수 종료: result = 25
첫 번째 함수 호출 후: square1 = 25
두 번째 함수 호출 전
calculate_square 함수 시작: num = 7
calculate_square 함수 종료: result = 49
두 번째 함수 호출 후: square2 = 49
main 함수 종료
*/
```

## 함수 선언과 정의의 분리

### 함수 선언 (Function Declaration / Prototype)

함수를 사용하기 전에 컴파일러에게 함수의 **시그니처(signature)**를 알려주는 것입니다:

```c
// 함수 선언 (함수 원형)
반환타입 함수이름(매개변수타입들);
```

### 함수 선언이 필요한 이유

**1. 컴파일러의 타입 검사**
```c
#include <stdio.h>

// 함수 선언 (prototype)
int add(int a, int b);
void print_result(int value);

int main() {
    int result = add(10, 20);     // 컴파일러가 add 함수의 시그니처를 알고 있음
    print_result(result);         // 타입 검사 가능
    return 0;
}

// 함수 정의 (implementation)
int add(int a, int b) {
    return a + b;
}

void print_result(int value) {
    printf("결과: %d\n", value);
}
```

**2. 함수 정의 순서의 자유**
```c
// 선언 없이는 정의 순서가 중요
int main() {
    int result = add(5, 3);       // 오류! add가 아직 정의되지 않음
    return 0;
}

int add(int a, int b) {
    return a + b;
}
```

### 함수 선언의 다양한 형태

**1. 기본 함수 선언**
```c
// 완전한 선언
int calculate_factorial(int n);
double calculate_average(double values[], int count);
void display_menu(void);

// 매개변수 이름 생략 가능 (타입만 명시)
int calculate_factorial(int);
double calculate_average(double[], int);
void display_menu(void);
```

**2. 헤더 파일에서의 선언**

**math_utils.h**
```c
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

// 수학 유틸리티 함수들의 선언
int gcd(int a, int b);                    // 최대공약수
int lcm(int a, int b);                    // 최소공배수
double power(double base, int exponent);  // 거듭제곱
bool is_prime(int number);                // 소수 판별

#endif
```

**math_utils.c**
```c
#include "math_utils.h"
#include <stdbool.h>

// 함수들의 실제 구현
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int lcm(int a, int b) {
    return (a * b) / gcd(a, b);
}

double power(double base, int exponent) {
    double result = 1.0;
    for (int i = 0; i < exponent; i++) {
        result *= base;
    }
    return result;
}

bool is_prime(int number) {
    if (number < 2) return false;
    if (number == 2) return true;
    if (number % 2 == 0) return false;

    for (int i = 3; i * i <= number; i += 2) {
        if (number % i == 0) return false;
    }
    return true;
}
```

**main.c**
```c
#include <stdio.h>
#include "math_utils.h"

int main() {
    int a = 48, b = 18;

    printf("GCD(%d, %d) = %d\n", a, b, gcd(a, b));
    printf("LCM(%d, %d) = %d\n", a, b, lcm(a, b));
    printf("2^10 = %.0f\n", power(2, 10));
    printf("17은 소수인가? %s\n", is_prime(17) ? "예" : "아니오");

    return 0;
}
```

## 매개변수와 인수

### 매개변수와 인수의 차이점

**매개변수 (Parameter)**: 함수 정의에서 선언된 변수
**인수 (Argument)**: 함수 호출 시 전달되는 실제 값

```c
// 매개변수: a, b
int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 5, y = 3;
    int result = add(x, y);    // 인수: x, y
    int result2 = add(10, 20); // 인수: 10, 20
    return 0;
}
```

### 값에 의한 전달 (Call by Value)

C언어는 기본적으로 **값에 의한 전달** 방식을 사용합니다:

```c
#include <stdio.h>

void modify_value(int num) {
    printf("함수 내부 - 수정 전: %d\n", num);
    num = 100;  // 매개변수 값 변경
    printf("함수 내부 - 수정 후: %d\n", num);
}

int main() {
    int original = 42;

    printf("호출 전 원본 값: %d\n", original);
    modify_value(original);
    printf("호출 후 원본 값: %d\n", original);  // 원본은 변하지 않음!

    return 0;
}

/*
출력:
호출 전 원본 값: 42
함수 내부 - 수정 전: 42
함수 내부 - 수정 후: 100
호출 후 원본 값: 42
*/
```

**값에 의한 전달의 특징:**
- 원본 데이터가 보호됨
- 함수 내부에서의 변경이 외부에 영향 없음
- 큰 구조체의 경우 복사 비용이 클 수 있음

### 다양한 매개변수 패턴

**1. 여러 매개변수**
```c
#include <stdio.h>

// 직사각형의 넓이와 둘레 계산
void calculate_rectangle(double length, double width,
                        double *area, double *perimeter) {
    *area = length * width;
    *perimeter = 2 * (length + width);
}

// 학생 정보 출력
void print_student_info(const char *name, int age, double gpa,
                       const char *major) {
    printf("=== 학생 정보 ===\n");
    printf("이름: %s\n", name);
    printf("나이: %d세\n", age);
    printf("GPA: %.2f\n", gpa);
    printf("전공: %s\n", major);
}

int main() {
    double area, perimeter;
    calculate_rectangle(5.0, 3.0, &area, &perimeter);
    printf("넓이: %.2f, 둘레: %.2f\n", area, perimeter);

    print_student_info("김철수", 20, 3.75, "컴퓨터공학");

    return 0;
}
```

**2. 배열 매개변수**
```c
#include <stdio.h>

// 배열의 합계 계산 (배열은 포인터로 전달됨)
int sum_array(int arr[], int size) {
    int total = 0;
    for (int i = 0; i < size; i++) {
        total += arr[i];
    }
    return total;
}

// 배열의 평균 계산
double average_array(int arr[], int size) {
    if (size == 0) return 0.0;
    return (double)sum_array(arr, size) / size;
}

// 배열 출력
void print_array(int arr[], int size, const char *label) {
    printf("%s: [", label);
    for (int i = 0; i < size; i++) {
        printf("%d", arr[i]);
        if (i < size - 1) printf(", ");
    }
    printf("]\n");
}

int main() {
    int numbers[] = {10, 20, 30, 40, 50};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    print_array(numbers, size, "배열");
    printf("합계: %d\n", sum_array(numbers, size));
    printf("평균: %.2f\n", average_array(numbers, size));

    return 0;
}
```

**3. 포인터 매개변수 (참조에 의한 전달 시뮬레이션)**
```c
#include <stdio.h>

// 두 값을 교환하는 함수
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 문자열의 길이와 단어 개수를 계산
void analyze_string(const char *str, int *length, int *word_count) {
    *length = 0;
    *word_count = 0;

    bool in_word = false;

    while (str[*length] != '\0') {
        char c = str[*length];

        if (c == ' ' || c == '\t' || c == '\n') {
            in_word = false;
        } else if (!in_word) {
            (*word_count)++;
            in_word = true;
        }

        (*length)++;
    }
}

int main() {
    int x = 10, y = 20;
    printf("교환 전: x = %d, y = %d\n", x, y);
    swap(&x, &y);
    printf("교환 후: x = %d, y = %d\n", x, y);

    const char *text = "Hello world from C programming";
    int length, words;
    analyze_string(text, &length, &words);
    printf("텍스트: \"%s\"\n", text);
    printf("길이: %d, 단어 수: %d\n", length, words);

    return 0;
}
```

## 반환값 (Return Values)

### return 문의 이해

`return` 문은 함수의 실행을 **즉시 종료**하고 **선택적으로 값을 반환**합니다:

```c
return;           // void 함수에서 값 없이 반환
return 표현식;    // 표현식의 값을 반환
```

### 다양한 반환 패턴

**1. 단일 값 반환**
```c
#include <stdio.h>

// 최댓값 반환
int max(int a, int b) {
    return (a > b) ? a : b;
}

// 팩토리얼 계산
long factorial(int n) {
    if (n <= 1) {
        return 1;  // 기저 조건
    }

    long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

// 제곱근의 정수 부분 반환
int integer_sqrt(int num) {
    if (num < 0) return -1;  // 오류 표시
    if (num == 0) return 0;

    int result = 1;
    while (result * result <= num) {
        result++;
    }
    return result - 1;
}
```

**2. 조건부 반환**
```c
#include <stdio.h>

// 나이 그룹 분류
const char* get_age_group(int age) {
    if (age < 0) return "Invalid";
    if (age < 13) return "Child";
    if (age < 20) return "Teenager";
    if (age < 65) return "Adult";
    return "Senior";
}

// 점수에 따른 등급 반환
char get_grade(double score) {
    if (score >= 90) return 'A';
    if (score >= 80) return 'B';
    if (score >= 70) return 'C';
    if (score >= 60) return 'D';
    return 'F';
}

// 안전한 나눗셈 (0으로 나누기 방지)
double safe_divide(double numerator, double denominator, bool *success) {
    if (denominator == 0.0) {
        *success = false;
        return 0.0;  // 의미 없는 값
    }

    *success = true;
    return numerator / denominator;
}
```

**3. 복합 구조체 반환**
```c
#include <stdio.h>
#include <math.h>

// 점의 좌표를 나타내는 구조체
typedef struct {
    double x;
    double y;
} Point;

// 두 점의 중점 계산
Point midpoint(Point p1, Point p2) {
    Point mid;
    mid.x = (p1.x + p2.x) / 2.0;
    mid.y = (p1.y + p2.y) / 2.0;
    return mid;  // 구조체 전체를 반환
}

// 두 점 사이의 거리 계산
double distance(Point p1, Point p2) {
    double dx = p2.x - p1.x;
    double dy = p2.y - p1.y;
    return sqrt(dx * dx + dy * dy);
}

// 원의 정보를 나타내는 구조체
typedef struct {
    Point center;
    double radius;
    double area;
    double circumference;
} Circle;

// 중심과 반지름으로부터 원 정보 생성
Circle create_circle(Point center, double radius) {
    Circle c;
    c.center = center;
    c.radius = radius;
    c.area = M_PI * radius * radius;
    c.circumference = 2 * M_PI * radius;
    return c;
}
```

### 반환값의 활용 패턴

**1. 오류 코드 반환**
```c
#include <stdio.h>
#include <stdlib.h>

typedef enum {
    SUCCESS = 0,
    ERROR_NULL_POINTER = -1,
    ERROR_INVALID_SIZE = -2,
    ERROR_MEMORY_ALLOCATION = -3
} ErrorCode;

// 배열 생성 함수 (오류 코드 반환)
ErrorCode create_array(int **array, int size) {
    if (array == NULL) {
        return ERROR_NULL_POINTER;
    }

    if (size <= 0) {
        return ERROR_INVALID_SIZE;
    }

    *array = malloc(sizeof(int) * size);
    if (*array == NULL) {
        return ERROR_MEMORY_ALLOCATION;
    }

    // 배열 초기화
    for (int i = 0; i < size; i++) {
        (*array)[i] = 0;
    }

    return SUCCESS;
}

// 오류 메시지 출력
void print_error(ErrorCode error) {
    switch (error) {
        case SUCCESS:
            printf("성공\n");
            break;
        case ERROR_NULL_POINTER:
            printf("오류: NULL 포인터\n");
            break;
        case ERROR_INVALID_SIZE:
            printf("오류: 잘못된 크기\n");
            break;
        case ERROR_MEMORY_ALLOCATION:
            printf("오류: 메모리 할당 실패\n");
            break;
        default:
            printf("알 수 없는 오류\n");
            break;
    }
}
```

**2. 성공/실패와 결과값 분리**
```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// 문자열을 정수로 변환 (성공/실패 정보 포함)
bool string_to_int(const char *str, int *result) {
    if (str == NULL || result == NULL) {
        return false;
    }

    // 빈 문자열 체크
    if (strlen(str) == 0) {
        return false;
    }

    // 숫자가 아닌 문자 체크
    int i = 0;
    if (str[0] == '-' || str[0] == '+') {
        i = 1;  // 부호 문자는 허용
    }

    for (; str[i] != '\0'; i++) {
        if (str[i] < '0' || str[i] > '9') {
            return false;  // 숫자가 아닌 문자 발견
        }
    }

    // 변환 수행
    *result = 0;
    int sign = 1;
    i = 0;

    if (str[0] == '-') {
        sign = -1;
        i = 1;
    } else if (str[0] == '+') {
        i = 1;
    }

    while (str[i] != '\0') {
        *result = *result * 10 + (str[i] - '0');
        i++;
    }

    *result *= sign;
    return true;
}

// 사용 예제
void test_string_conversion() {
    int value;
    const char *test_strings[] = {
        "123", "-456", "0", "abc", "12.34", "", "999999999999"
    };
    int num_tests = sizeof(test_strings) / sizeof(test_strings[0]);

    for (int i = 0; i < num_tests; i++) {
        if (string_to_int(test_strings[i], &value)) {
            printf("'%s' -> %d (성공)\n", test_strings[i], value);
        } else {
            printf("'%s' -> 변환 실패\n", test_strings[i]);
        }
    }
}
```

## 함수 활용 실습

### 실습 1: 수학 계산기 라이브러리

```c
#include <stdio.h>
#include <math.h>
#include <stdbool.h>

// ==================== 기본 연산 함수들 ====================

// 사칙연산
double add(double a, double b) {
    return a + b;
}

double subtract(double a, double b) {
    return a - b;
}

double multiply(double a, double b) {
    return a * b;
}

double divide(double a, double b) {
    if (b == 0.0) {
        printf("오류: 0으로 나눌 수 없습니다.\n");
        return NAN;  // Not a Number
    }
    return a / b;
}

// ==================== 고급 수학 함수들 ====================

// 거듭제곱 (정수 지수)
double power_int(double base, int exponent) {
    if (exponent == 0) return 1.0;

    double result = 1.0;
    int abs_exp = abs(exponent);

    for (int i = 0; i < abs_exp; i++) {
        result *= base;
    }

    return (exponent > 0) ? result : 1.0 / result;
}

// 팩토리얼
long long factorial(int n) {
    if (n < 0) return -1;  // 음수는 정의되지 않음
    if (n <= 1) return 1;

    long long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

// 조합 (nCr)
long long combination(int n, int r) {
    if (r > n || r < 0) return 0;
    if (r == 0 || r == n) return 1;

    // nCr = n! / (r! * (n-r)!)
    // 하지만 효율성을 위해 다른 방법 사용
    if (r > n - r) r = n - r;  // 대칭성 이용

    long long result = 1;
    for (int i = 0; i < r; i++) {
        result = result * (n - i) / (i + 1);
    }
    return result;
}

// 순열 (nPr)
long long permutation(int n, int r) {
    if (r > n || r < 0) return 0;
    if (r == 0) return 1;

    long long result = 1;
    for (int i = 0; i < r; i++) {
        result *= (n - i);
    }
    return result;
}

// ==================== 통계 함수들 ====================

// 배열의 합
double sum_array(double arr[], int size) {
    double sum = 0.0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum;
}

// 평균
double mean(double arr[], int size) {
    if (size == 0) return 0.0;
    return sum_array(arr, size) / size;
}

// 분산
double variance(double arr[], int size) {
    if (size <= 1) return 0.0;

    double avg = mean(arr, size);
    double sum_sq_diff = 0.0;

    for (int i = 0; i < size; i++) {
        double diff = arr[i] - avg;
        sum_sq_diff += diff * diff;
    }

    return sum_sq_diff / (size - 1);  // 표본 분산
}

// 표준편차
double standard_deviation(double arr[], int size) {
    return sqrt(variance(arr, size));
}

// 중앙값 (배열이 정렬되어 있다고 가정)
double median_sorted(double arr[], int size) {
    if (size == 0) return 0.0;

    if (size % 2 == 1) {
        return arr[size / 2];
    } else {
        return (arr[size / 2 - 1] + arr[size / 2]) / 2.0;
    }
}

// ==================== 수치 해석 함수들 ====================

// 뉴턴-랩슨 방법으로 제곱근 계산
double sqrt_newton(double x, double precision) {
    if (x < 0) return NAN;
    if (x == 0) return 0;

    double guess = x / 2.0;  // 초기 추정값

    while (fabs(guess * guess - x) > precision) {
        guess = (guess + x / guess) / 2.0;
    }

    return guess;
}

// 이분법으로 방정식의 근 찾기
double bisection_method(double (*func)(double), double a, double b,
                       double precision, int max_iterations) {
    // func(a)와 func(b)의 부호가 달라야 함
    if (func(a) * func(b) >= 0) {
        printf("오류: f(a)와 f(b)의 부호가 같습니다.\n");
        return NAN;
    }

    double c;
    for (int i = 0; i < max_iterations; i++) {
        c = (a + b) / 2.0;

        if (fabs(func(c)) < precision || fabs(b - a) < precision) {
            return c;
        }

        if (func(c) * func(a) < 0) {
            b = c;
        } else {
            a = c;
        }
    }

    return c;
}

// 테스트용 함수: f(x) = x^2 - 2 (근: √2)
double test_function(double x) {
    return x * x - 2.0;
}

// ==================== 유틸리티 함수들 ====================

// 배열 정렬 (버블 정렬)
void bubble_sort(double arr[], int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                double temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// 배열 출력
void print_array(double arr[], int size, const char *label) {
    printf("%s: [", label);
    for (int i = 0; i < size; i++) {
        printf("%.2f", arr[i]);
        if (i < size - 1) printf(", ");
    }
    printf("]\n");
}

// 함수 포인터를 이용한 연산 선택
double calculate(double a, double b, double (*operation)(double, double)) {
    return operation(a, b);
}

// ==================== 메인 프로그램 ====================

void demonstrate_basic_operations() {
    printf("=== 기본 연산 테스트 ===\n");
    double a = 15.5, b = 4.2;

    printf("%.2f + %.2f = %.2f\n", a, b, add(a, b));
    printf("%.2f - %.2f = %.2f\n", a, b, subtract(a, b));
    printf("%.2f × %.2f = %.2f\n", a, b, multiply(a, b));
    printf("%.2f ÷ %.2f = %.2f\n", a, b, divide(a, b));
    printf("%.2f ^ %d = %.2f\n", a, 3, power_int(a, 3));
    printf("\n");
}

void demonstrate_combinatorics() {
    printf("=== 조합론 테스트 ===\n");
    int n = 10, r = 3;

    printf("%d! = %lld\n", n, factorial(n));
    printf("C(%d, %d) = %lld\n", n, r, combination(n, r));
    printf("P(%d, %d) = %lld\n", n, r, permutation(n, r));
    printf("\n");
}

void demonstrate_statistics() {
    printf("=== 통계 함수 테스트 ===\n");
    double data[] = {85.5, 92.0, 78.5, 88.0, 95.5, 82.0, 90.0, 87.5};
    int size = sizeof(data) / sizeof(data[0]);

    print_array(data, size, "원본 데이터");

    printf("합계: %.2f\n", sum_array(data, size));
    printf("평균: %.2f\n", mean(data, size));
    printf("분산: %.2f\n", variance(data, size));
    printf("표준편차: %.2f\n", standard_deviation(data, size));

    // 중앙값 계산을 위해 정렬
    double sorted_data[8];
    for (int i = 0; i < size; i++) {
        sorted_data[i] = data[i];
    }
    bubble_sort(sorted_data, size);
    print_array(sorted_data, size, "정렬된 데이터");
    printf("중앙값: %.2f\n", median_sorted(sorted_data, size));
    printf("\n");
}

void demonstrate_numerical_methods() {
    printf("=== 수치 해석 테스트 ===\n");

    double x = 2.0;
    double sqrt_result = sqrt_newton(x, 1e-10);
    printf("√%.1f = %.10f (뉴턴-랩슨 방법)\n", x, sqrt_result);
    printf("√%.1f = %.10f (표준 라이브러리)\n", x, sqrt(x));
    printf("오차: %.2e\n", fabs(sqrt_result - sqrt(x)));

    // 방정식 x^2 - 2 = 0의 근 찾기 (√2)
    double root = bisection_method(test_function, 1.0, 2.0, 1e-10, 100);
    printf("x² - 2 = 0의 근: %.10f (이분법)\n", root);
    printf("실제 √2: %.10f\n", sqrt(2.0));
    printf("오차: %.2e\n", fabs(root - sqrt(2.0)));
    printf("\n");
}

void demonstrate_function_pointers() {
    printf("=== 함수 포인터 테스트 ===\n");
    double a = 10.0, b = 3.0;

    printf("%.1f + %.1f = %.1f\n", a, b, calculate(a, b, add));
    printf("%.1f - %.1f = %.1f\n", a, b, calculate(a, b, subtract));
    printf("%.1f × %.1f = %.1f\n", a, b, calculate(a, b, multiply));
    printf("%.1f ÷ %.1f = %.1f\n", a, b, calculate(a, b, divide));
    printf("\n");
}

int main() {
    printf("=== 수학 계산기 라이브러리 테스트 ===\n\n");

    demonstrate_basic_operations();
    demonstrate_combinatorics();
    demonstrate_statistics();
    demonstrate_numerical_methods();
    demonstrate_function_pointers();

    return 0;
}
```

### 실습 2: 문자열 처리 라이브러리

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

// ==================== 기본 문자열 함수들 ====================

// 문자열 길이 계산 (자체 구현)
int string_length(const char *str) {
    if (str == NULL) return -1;

    int length = 0;
    while (str[length] != '\0') {
        length++;
    }
    return length;
}

// 문자열 복사 (자체 구현)
char* string_copy(char *dest, const char *src, int dest_size) {
    if (dest == NULL || src == NULL || dest_size <= 0) {
        return NULL;
    }

    int i = 0;
    while (i < dest_size - 1 && src[i] != '\0') {
        dest[i] = src[i];
        i++;
    }
    dest[i] = '\0';

    return dest;
}

// 문자열 연결 (자체 구현)
char* string_concat(char *dest, const char *src, int dest_size) {
    if (dest == NULL || src == NULL || dest_size <= 0) {
        return NULL;
    }

    int dest_len = string_length(dest);
    int i = 0;

    while (dest_len + i < dest_size - 1 && src[i] != '\0') {
        dest[dest_len + i] = src[i];
        i++;
    }
    dest[dest_len + i] = '\0';

    return dest;
}

// 문자열 비교 (자체 구현)
int string_compare(const char *str1, const char *str2) {
    if (str1 == NULL && str2 == NULL) return 0;
    if (str1 == NULL) return -1;
    if (str2 == NULL) return 1;

    int i = 0;
    while (str1[i] != '\0' && str2[i] != '\0') {
        if (str1[i] < str2[i]) return -1;
        if (str1[i] > str2[i]) return 1;
        i++;
    }

    if (str1[i] == '\0' && str2[i] == '\0') return 0;
    if (str1[i] == '\0') return -1;
    return 1;
}

// ==================== 문자열 검색 함수들 ====================

// 문자 찾기
int find_char(const char *str, char target) {
    if (str == NULL) return -1;

    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] == target) {
            return i;  // 첫 번째 발견 위치 반환
        }
    }
    return -1;  // 찾지 못함
}

// 마지막 문자 찾기
int find_last_char(const char *str, char target) {
    if (str == NULL) return -1;

    int last_pos = -1;
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] == target) {
            last_pos = i;
        }
    }
    return last_pos;
}

// 부분 문자열 찾기
int find_substring(const char *str, const char *substr) {
    if (str == NULL || substr == NULL) return -1;

    int str_len = string_length(str);
    int substr_len = string_length(substr);

    if (substr_len == 0) return 0;  // 빈 문자열은 위치 0에서 발견
    if (substr_len > str_len) return -1;

    for (int i = 0; i <= str_len - substr_len; i++) {
        bool found = true;
        for (int j = 0; j < substr_len; j++) {
            if (str[i + j] != substr[j]) {
                found = false;
                break;
            }
        }
        if (found) return i;
    }

    return -1;
}

// 특정 문자 개수 세기
int count_char(const char *str, char target) {
    if (str == NULL) return 0;

    int count = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] == target) {
            count++;
        }
    }
    return count;
}

// ==================== 문자열 변환 함수들 ====================

// 대문자로 변환
char* to_uppercase(char *str) {
    if (str == NULL) return NULL;

    for (int i = 0; str[i] != '\0'; i++) {
        str[i] = toupper(str[i]);
    }
    return str;
}

// 소문자로 변환
char* to_lowercase(char *str) {
    if (str == NULL) return NULL;

    for (int i = 0; str[i] != '\0'; i++) {
        str[i] = tolower(str[i]);
    }
    return str;
}

// 문자열 뒤집기
char* reverse_string(char *str) {
    if (str == NULL) return NULL;

    int len = string_length(str);
    for (int i = 0; i < len / 2; i++) {
        char temp = str[i];
        str[i] = str[len - 1 - i];
        str[len - 1 - i] = temp;
    }
    return str;
}

// 앞뒤 공백 제거
char* trim_whitespace(char *str) {
    if (str == NULL) return NULL;

    // 앞쪽 공백 제거
    int start = 0;
    while (str[start] != '\0' && isspace(str[start])) {
        start++;
    }

    // 문자열이 모두 공백인 경우
    if (str[start] == '\0') {
        str[0] = '\0';
        return str;
    }

    // 뒤쪽 공백 제거
    int end = string_length(str) - 1;
    while (end >= start && isspace(str[end])) {
        end--;
    }

    // 문자열 이동
    int j = 0;
    for (int i = start; i <= end; i++) {
        str[j++] = str[i];
    }
    str[j] = '\0';

    return str;
}

// ==================== 문자열 분석 함수들 ====================

// 단어 개수 세기
int count_words(const char *str) {
    if (str == NULL) return 0;

    int count = 0;
    bool in_word = false;

    for (int i = 0; str[i] != '\0'; i++) {
        if (isspace(str[i])) {
            in_word = false;
        } else if (!in_word) {
            count++;
            in_word = true;
        }
    }

    return count;
}

// 문자열이 숫자인지 확인
bool is_numeric(const char *str) {
    if (str == NULL || str[0] == '\0') return false;

    int i = 0;

    // 부호 처리
    if (str[0] == '+' || str[0] == '-') {
        i = 1;
        if (str[1] == '\0') return false;  // 부호만 있는 경우
    }

    bool has_dot = false;

    for (; str[i] != '\0'; i++) {
        if (str[i] == '.') {
            if (has_dot) return false;  // 소수점이 두 개 이상
            has_dot = true;
        } else if (!isdigit(str[i])) {
            return false;  // 숫자가 아닌 문자
        }
    }

    return true;
}

// 회문(팰린드롬) 확인
bool is_palindrome(const char *str) {
    if (str == NULL) return false;

    int len = string_length(str);

    for (int i = 0; i < len / 2; i++) {
        if (tolower(str[i]) != tolower(str[len - 1 - i])) {
            return false;
        }
    }

    return true;
}

// 문자열이 다른 문자열로 시작하는지 확인
bool starts_with(const char *str, const char *prefix) {
    if (str == NULL || prefix == NULL) return false;

    int prefix_len = string_length(prefix);
    int str_len = string_length(str);

    if (prefix_len > str_len) return false;

    for (int i = 0; i < prefix_len; i++) {
        if (str[i] != prefix[i]) {
            return false;
        }
    }

    return true;
}

// 문자열이 다른 문자열로 끝나는지 확인
bool ends_with(const char *str, const char *suffix) {
    if (str == NULL || suffix == NULL) return false;

    int str_len = string_length(str);
    int suffix_len = string_length(suffix);

    if (suffix_len > str_len) return false;

    int start = str_len - suffix_len;
    for (int i = 0; i < suffix_len; i++) {
        if (str[start + i] != suffix[i]) {
            return false;
        }
    }

    return true;
}

// ==================== 고급 문자열 함수들 ====================

// 문자열을 구분자로 분리 (단순 버전)
int split_string(const char *str, char delimiter, char result[][256], int max_parts) {
    if (str == NULL || result == NULL || max_parts <= 0) return 0;

    int part_count = 0;
    int current_pos = 0;
    int start = 0;

    while (str[current_pos] != '\0' && part_count < max_parts) {
        if (str[current_pos] == delimiter) {
            // 현재 부분 복사
            int length = current_pos - start;
            if (length > 255) length = 255;  // 버퍼 크기 제한

            for (int i = 0; i < length; i++) {
                result[part_count][i] = str[start + i];
            }
            result[part_count][length] = '\0';

            part_count++;
            start = current_pos + 1;
        }
        current_pos++;
    }

    // 마지막 부분 처리
    if (part_count < max_parts && start <= current_pos) {
        int length = current_pos - start;
        if (length > 255) length = 255;

        for (int i = 0; i < length; i++) {
            result[part_count][i] = str[start + i];
        }
        result[part_count][length] = '\0';
        part_count++;
    }

    return part_count;
}

// 문자열에서 특정 문자를 다른 문자로 교체
char* replace_char(char *str, char old_char, char new_char) {
    if (str == NULL) return NULL;

    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] == old_char) {
            str[i] = new_char;
        }
    }

    return str;
}

// 문자열에서 특정 문자들 제거
char* remove_chars(char *str, const char *chars_to_remove) {
    if (str == NULL || chars_to_remove == NULL) return str;

    int write_pos = 0;

    for (int read_pos = 0; str[read_pos] != '\0'; read_pos++) {
        bool should_remove = false;

        // chars_to_remove에 현재 문자가 있는지 확인
        for (int i = 0; chars_to_remove[i] != '\0'; i++) {
            if (str[read_pos] == chars_to_remove[i]) {
                should_remove = true;
                break;
            }
        }

        if (!should_remove) {
            str[write_pos++] = str[read_pos];
        }
    }

    str[write_pos] = '\0';
    return str;
}

// ==================== 테스트 및 데모 함수들 ====================

void test_basic_functions() {
    printf("=== 기본 문자열 함수 테스트 ===\n");

    char str1[100] = "Hello";
    char str2[100] = " World";
    char str3[100];

    printf("원본: '%s', '%s'\n", str1, str2);
    printf("길이: %d, %d\n", string_length(str1), string_length(str2));

    string_copy(str3, str1, sizeof(str3));
    printf("복사: '%s'\n", str3);

    string_concat(str3, str2, sizeof(str3));
    printf("연결: '%s'\n", str3);

    printf("비교 결과: %d\n", string_compare(str1, str2));
    printf("\n");
}

void test_search_functions() {
    printf("=== 검색 함수 테스트 ===\n");

    const char *text = "Hello, World! Welcome to C programming.";
    printf("텍스트: '%s'\n", text);

    printf("'o' 첫 번째 위치: %d\n", find_char(text, 'o'));
    printf("'o' 마지막 위치: %d\n", find_last_char(text, 'o'));
    printf("'World' 위치: %d\n", find_substring(text, "World"));
    printf("'o' 개수: %d\n", count_char(text, 'o'));
    printf("\n");
}

void test_transformation_functions() {
    printf("=== 변환 함수 테스트 ===\n");

    char test_str[100];

    string_copy(test_str, "Hello World", sizeof(test_str));
    printf("원본: '%s'\n", test_str);

    to_uppercase(test_str);
    printf("대문자: '%s'\n", test_str);

    to_lowercase(test_str);
    printf("소문자: '%s'\n", test_str);

    reverse_string(test_str);
    printf("뒤집기: '%s'\n", test_str);

    string_copy(test_str, "  spaces around  ", sizeof(test_str));
    printf("공백 제거 전: '%s'\n", test_str);
    trim_whitespace(test_str);
    printf("공백 제거 후: '%s'\n", test_str);
    printf("\n");
}

void test_analysis_functions() {
    printf("=== 분석 함수 테스트 ===\n");

    const char *texts[] = {
        "Hello world from C programming",
        "12345",
        "-123.45",
        "abc123",
        "racecar",
        "hello",
        ""
    };

    int num_texts = sizeof(texts) / sizeof(texts[0]);

    for (int i = 0; i < num_texts; i++) {
        printf("'%s':\n", texts[i]);
        printf("  단어 수: %d\n", count_words(texts[i]));
        printf("  숫자인가: %s\n", is_numeric(texts[i]) ? "예" : "아니오");
        printf("  회문인가: %s\n", is_palindrome(texts[i]) ? "예" : "아니오");
        printf("  'hello'로 시작: %s\n", starts_with(texts[i], "hello") ? "예" : "아니오");
        printf("  'ing'로 끝남: %s\n", ends_with(texts[i], "ing") ? "예" : "아니오");
        printf("\n");
    }
}

void test_advanced_functions() {
    printf("=== 고급 함수 테스트 ===\n");

    // 문자열 분리 테스트
    const char *csv_data = "apple,banana,cherry,date";
    char parts[10][256];
    int count = split_string(csv_data, ',', parts, 10);

    printf("CSV 분리: '%s'\n", csv_data);
    for (int i = 0; i < count; i++) {
        printf("  부분 %d: '%s'\n", i + 1, parts[i]);
    }

    // 문자 교체 테스트
    char test_str[100];
    string_copy(test_str, "Hello World", sizeof(test_str));
    printf("교체 전: '%s'\n", test_str);
    replace_char(test_str, 'l', 'x');
    printf("'l' -> 'x': '%s'\n", test_str);

    // 문자 제거 테스트
    string_copy(test_str, "a1b2c3d4e5", sizeof(test_str));
    printf("제거 전: '%s'\n", test_str);
    remove_chars(test_str, "12345");
    printf("숫자 제거: '%s'\n", test_str);
    printf("\n");
}

int main() {
    printf("=== 문자열 처리 라이브러리 테스트 ===\n\n");

    test_basic_functions();
    test_search_functions();
    test_transformation_functions();
    test_analysis_functions();
    test_advanced_functions();

    return 0;
}
```

### 실습 3: 간단한 데이터베이스 시스템

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <time.h>

#define MAX_NAME_LENGTH 50
#define MAX_EMAIL_LENGTH 100
#define MAX_RECORDS 1000
#define MAX_QUERY_LENGTH 256

// ==================== 데이터 구조 정의 ====================

typedef struct {
    int id;
    char name[MAX_NAME_LENGTH];
    int age;
    char email[MAX_EMAIL_LENGTH];
    double salary;
    time_t created_at;
} Person;

typedef struct {
    Person records[MAX_RECORDS];
    int count;
    int next_id;
} Database;

typedef enum {
    QUERY_SUCCESS,
    QUERY_ERROR_NOT_FOUND,
    QUERY_ERROR_INVALID_ID,
    QUERY_ERROR_DUPLICATE_EMAIL,
    QUERY_ERROR_DATABASE_FULL
} QueryResult;

// ==================== 데이터베이스 기본 함수들 ====================

// 데이터베이스 초기화
void init_database(Database *db) {
    if (db == NULL) return;

    db->count = 0;
    db->next_id = 1;

    // 모든 레코드 초기화
    for (int i = 0; i < MAX_RECORDS; i++) {
        memset(&db->records[i], 0, sizeof(Person));
    }
}

// 이메일 중복 검사
bool is_email_duplicate(Database *db, const char *email, int exclude_id) {
    if (db == NULL || email == NULL) return false;

    for (int i = 0; i < db->count; i++) {
        if (db->records[i].id != exclude_id &&
            strcmp(db->records[i].email, email) == 0) {
            return true;
        }
    }
    return false;
}

// 입력 검증 함수
bool validate_person(Database *db, const Person *person, bool is_update) {
    if (person == NULL) return false;

    // 이름 검증
    if (strlen(person->name) == 0 || strlen(person->name) >= MAX_NAME_LENGTH) {
        printf("오류: 이름이 유효하지 않습니다.\n");
        return false;
    }

    // 나이 검증
    if (person->age < 0 || person->age > 150) {
        printf("오류: 나이가 유효하지 않습니다 (0-150).\n");
        return false;
    }

    // 이메일 검증
    if (strlen(person->email) == 0 || strlen(person->email) >= MAX_EMAIL_LENGTH) {
        printf("오류: 이메일이 유효하지 않습니다.\n");
        return false;
    }

    // 이메일 형식 간단 검증 (@ 포함 여부)
    if (strchr(person->email, '@') == NULL) {
        printf("오류: 이메일 형식이 올바르지 않습니다.\n");
        return false;
    }

    // 이메일 중복 검사
    int exclude_id = is_update ? person->id : -1;
    if (is_email_duplicate(db, person->email, exclude_id)) {
        printf("오류: 이메일이 이미 존재합니다.\n");
        return false;
    }

    // 급여 검증
    if (person->salary < 0) {
        printf("오류: 급여가 유효하지 않습니다.\n");
        return false;
    }

    return true;
}

// ==================== CRUD 함수들 ====================

// 레코드 추가 (Create)
QueryResult add_person(Database *db, const char *name, int age,
                      const char *email, double salary) {
    if (db == NULL || name == NULL || email == NULL) {
        return QUERY_ERROR_INVALID_ID;
    }

    if (db->count >= MAX_RECORDS) {
        return QUERY_ERROR_DATABASE_FULL;
    }

    // 새 Person 객체 생성
    Person new_person;
    new_person.id = db->next_id;
    strncpy(new_person.name, name, MAX_NAME_LENGTH - 1);
    new_person.name[MAX_NAME_LENGTH - 1] = '\0';
    new_person.age = age;
    strncpy(new_person.email, email, MAX_EMAIL_LENGTH - 1);
    new_person.email[MAX_EMAIL_LENGTH - 1] = '\0';
    new_person.salary = salary;
    new_person.created_at = time(NULL);

    // 검증
    if (!validate_person(db, &new_person, false)) {
        return QUERY_ERROR_INVALID_ID;
    }

    // 데이터베이스에 추가
    db->records[db->count] = new_person;
    db->count++;
    db->next_id++;

    printf("레코드 추가 완료: ID %d\n", new_person.id);
    return QUERY_SUCCESS;
}

// ID로 레코드 찾기
int find_person_by_id(Database *db, int id) {
    if (db == NULL) return -1;

    for (int i = 0; i < db->count; i++) {
        if (db->records[i].id == id) {
            return i;
        }
    }
    return -1;
}

// 레코드 조회 (Read)
QueryResult get_person(Database *db, int id, Person *result) {
    if (db == NULL || result == NULL) {
        return QUERY_ERROR_INVALID_ID;
    }

    int index = find_person_by_id(db, id);
    if (index == -1) {
        return QUERY_ERROR_NOT_FOUND;
    }

    *result = db->records[index];
    return QUERY_SUCCESS;
}

// 레코드 수정 (Update)
QueryResult update_person(Database *db, int id, const char *name,
                         int age, const char *email, double salary) {
    if (db == NULL) return QUERY_ERROR_INVALID_ID;

    int index = find_person_by_id(db, id);
    if (index == -1) {
        return QUERY_ERROR_NOT_FOUND;
    }

    // 임시 Person 객체로 검증
    Person temp_person = db->records[index];
    if (name != NULL) {
        strncpy(temp_person.name, name, MAX_NAME_LENGTH - 1);
        temp_person.name[MAX_NAME_LENGTH - 1] = '\0';
    }
    if (age >= 0) temp_person.age = age;
    if (email != NULL) {
        strncpy(temp_person.email, email, MAX_EMAIL_LENGTH - 1);
        temp_person.email[MAX_EMAIL_LENGTH - 1] = '\0';
    }
    if (salary >= 0) temp_person.salary = salary;

    if (!validate_person(db, &temp_person, true)) {
        return QUERY_ERROR_INVALID_ID;
    }

    // 실제 업데이트
    db->records[index] = temp_person;

    printf("레코드 수정 완료: ID %d\n", id);
    return QUERY_SUCCESS;
}

// 레코드 삭제 (Delete)
QueryResult delete_person(Database *db, int id) {
    if (db == NULL) return QUERY_ERROR_INVALID_ID;

    int index = find_person_by_id(db, id);
    if (index == -1) {
        return QUERY_ERROR_NOT_FOUND;
    }

    // 마지막 레코드를 삭제할 위치로 이동
    for (int i = index; i < db->count - 1; i++) {
        db->records[i] = db->records[i + 1];
    }

    db->count--;
    printf("레코드 삭제 완료: ID %d\n", id);
    return QUERY_SUCCESS;
}

// ==================== 검색 및 필터링 함수들 ====================

// 이름으로 검색
int search_by_name(Database *db, const char *name, int results[], int max_results) {
    if (db == NULL || name == NULL || results == NULL) return 0;

    int count = 0;
    for (int i = 0; i < db->count && count < max_results; i++) {
        if (strstr(db->records[i].name, name) != NULL) {
            results[count++] = db->records[i].id;
        }
    }
    return count;
}

// 나이 범위로 검색
int search_by_age_range(Database *db, int min_age, int max_age,
                       int results[], int max_results) {
    if (db == NULL || results == NULL) return 0;

    int count = 0;
    for (int i = 0; i < db->count && count < max_results; i++) {
        if (db->records[i].age >= min_age && db->records[i].age <= max_age) {
            results[count++] = db->records[i].id;
        }
    }
    return count;
}

// 급여 범위로 검색
int search_by_salary_range(Database *db, double min_salary, double max_salary,
                          int results[], int max_results) {
    if (db == NULL || results == NULL) return 0;

    int count = 0;
    for (int i = 0; i < db->count && count < max_results; i++) {
        if (db->records[i].salary >= min_salary &&
            db->records[i].salary <= max_salary) {
            results[count++] = db->records[i].id;
        }
    }
    return count;
}

// ==================== 정렬 함수들 ====================

// 이름으로 정렬을 위한 비교 함수
int compare_by_name(const void *a, const void *b) {
    const Person *person_a = (const Person *)a;
    const Person *person_b = (const Person *)b;
    return strcmp(person_a->name, person_b->name);
}

// 나이로 정렬을 위한 비교 함수
int compare_by_age(const void *a, const void *b) {
    const Person *person_a = (const Person *)a;
    const Person *person_b = (const Person *)b;
    return person_a->age - person_b->age;
}

// 급여로 정렬을 위한 비교 함수
int compare_by_salary(const void *a, const void *b) {
    const Person *person_a = (const Person *)a;
    const Person *person_b = (const Person *)b;
    if (person_a->salary < person_b->salary) return -1;
    if (person_a->salary > person_b->salary) return 1;
    return 0;
}

// 데이터베이스 정렬
void sort_database(Database *db, const char *field) {
    if (db == NULL || db->count == 0) return;

    if (strcmp(field, "name") == 0) {
        qsort(db->records, db->count, sizeof(Person), compare_by_name);
    } else if (strcmp(field, "age") == 0) {
        qsort(db->records, db->count, sizeof(Person), compare_by_age);
    } else if (strcmp(field, "salary") == 0) {
        qsort(db->records, db->count, sizeof(Person), compare_by_salary);
    }
}

// ==================== 출력 및 유틸리티 함수들 ====================

// 시간을 문자열로 변환
void format_time(time_t timestamp, char *buffer, size_t buffer_size) {
    struct tm *time_info = localtime(&timestamp);
    strftime(buffer, buffer_size, "%Y-%m-%d %H:%M:%S", time_info);
}

// 단일 레코드 출력
void print_person(const Person *person) {
    if (person == NULL) return;

    char time_str[64];
    format_time(person->created_at, time_str, sizeof(time_str));

    printf("ID: %d\n", person->id);
    printf("이름: %s\n", person->name);
    printf("나이: %d세\n", person->age);
    printf("이메일: %s\n", person->email);
    printf("급여: $%.2f\n", person->salary);
    printf("생성일: %s\n", time_str);
    printf("-" "----------------------------------------\n");
}

// 모든 레코드 출력
void print_all_records(Database *db) {
    if (db == NULL) return;

    printf("\n=== 전체 레코드 (%d개) ===\n", db->count);

    if (db->count == 0) {
        printf("레코드가 없습니다.\n");
        return;
    }

    for (int i = 0; i < db->count; i++) {
        print_person(&db->records[i]);
    }
}

// 검색 결과 출력
void print_search_results(Database *db, int results[], int count,
                         const char *query_description) {
    printf("\n=== 검색 결과: %s (%d개) ===\n", query_description, count);

    if (count == 0) {
        printf("검색 결과가 없습니다.\n");
        return;
    }

    for (int i = 0; i < count; i++) {
        Person person;
        if (get_person(db, results[i], &person) == QUERY_SUCCESS) {
            print_person(&person);
        }
    }
}

// 통계 정보 출력
void print_statistics(Database *db) {
    if (db == NULL || db->count == 0) {
        printf("통계를 계산할 레코드가 없습니다.\n");
        return;
    }

    double total_salary = 0;
    int total_age = 0;
    int min_age = db->records[0].age;
    int max_age = db->records[0].age;
    double min_salary = db->records[0].salary;
    double max_salary = db->records[0].salary;

    for (int i = 0; i < db->count; i++) {
        Person *p = &db->records[i];

        total_age += p->age;
        total_salary += p->salary;

        if (p->age < min_age) min_age = p->age;
        if (p->age > max_age) max_age = p->age;
        if (p->salary < min_salary) min_salary = p->salary;
        if (p->salary > max_salary) max_salary = p->salary;
    }

    printf("\n=== 통계 정보 ===\n");
    printf("총 레코드 수: %d\n", db->count);
    printf("평균 나이: %.1f세\n", (double)total_age / db->count);
    printf("나이 범위: %d - %d세\n", min_age, max_age);
    printf("평균 급여: $%.2f\n", total_salary / db->count);
    printf("급여 범위: $%.2f - $%.2f\n", min_salary, max_salary);
}

// ==================== 샘플 데이터 생성 ====================

void generate_sample_data(Database *db) {
    const char *names[] = {
        "김철수", "이영희", "박민수", "최지은", "정한호",
        "강미영", "윤도현", "임수진", "오준석", "한소희"
    };

    const char *domains[] = {
        "@gmail.com", "@naver.com", "@daum.net", "@hotmail.com", "@yahoo.com"
    };

    int num_names = sizeof(names) / sizeof(names[0]);
    int num_domains = sizeof(domains) / sizeof(domains[0]);

    for (int i = 0; i < num_names; i++) {
        char email[MAX_EMAIL_LENGTH];
        snprintf(email, sizeof(email), "%s%s", names[i], domains[i % num_domains]);

        int age = 20 + (rand() % 40);  // 20-59세
        double salary = 30000 + (rand() % 70000);  // $30,000-$100,000

        add_person(db, names[i], age, email, salary);
    }

    printf("샘플 데이터 %d개가 생성되었습니다.\n", num_names);
}

// ==================== 대화형 인터페이스 ====================

void interactive_database_system() {
    Database db;
    init_database(&db);

    printf("=== 간단한 데이터베이스 시스템 ===\n");

    while (true) {
        printf("\n--- 메뉴 ---\n");
        printf("1. 레코드 추가\n");
        printf("2. 레코드 조회\n");
        printf("3. 레코드 수정\n");
        printf("4. 레코드 삭제\n");
        printf("5. 전체 레코드 보기\n");
        printf("6. 이름으로 검색\n");
        printf("7. 나이 범위로 검색\n");
        printf("8. 급여 범위로 검색\n");
        printf("9. 정렬\n");
        printf("10. 통계 보기\n");
        printf("11. 샘플 데이터 생성\n");
        printf("0. 종료\n");
        printf("선택: ");

        int choice;
        if (scanf("%d", &choice) != 1) {
            printf("잘못된 입력입니다.\n");
            while (getchar() != '\n');
            continue;
        }

        switch (choice) {
            case 1: {
                char name[MAX_NAME_LENGTH], email[MAX_EMAIL_LENGTH];
                int age;
                double salary;

                printf("이름: ");
                scanf("%49s", name);
                printf("나이: ");
                scanf("%d", &age);
                printf("이메일: ");
                scanf("%99s", email);
                printf("급여: ");
                scanf("%lf", &salary);

                QueryResult result = add_person(&db, name, age, email, salary);
                if (result != QUERY_SUCCESS) {
                    printf("레코드 추가에 실패했습니다.\n");
                }
                break;
            }

            case 2: {
                printf("조회할 ID: ");
                int id;
                scanf("%d", &id);

                Person person;
                if (get_person(&db, id, &person) == QUERY_SUCCESS) {
                    printf("\n=== 레코드 조회 결과 ===\n");
                    print_person(&person);
                } else {
                    printf("해당 ID의 레코드를 찾을 수 없습니다.\n");
                }
                break;
            }

            case 3: {
                printf("수정할 ID: ");
                int id;
                scanf("%d", &id);

                Person current;
                if (get_person(&db, id, &current) != QUERY_SUCCESS) {
                    printf("해당 ID의 레코드를 찾을 수 없습니다.\n");
                    break;
                }

                printf("현재 정보:\n");
                print_person(&current);

                char name[MAX_NAME_LENGTH], email[MAX_EMAIL_LENGTH];
                int age;
                double salary;

                printf("새 이름 (현재: %s): ", current.name);
                scanf("%49s", name);
                printf("새 나이 (현재: %d): ", current.age);
                scanf("%d", &age);
                printf("새 이메일 (현재: %s): ", current.email);
                scanf("%99s", email);
                printf("새 급여 (현재: %.2f): ", current.salary);
                scanf("%lf", &salary);

                if (update_person(&db, id, name, age, email, salary) != QUERY_SUCCESS) {
                    printf("레코드 수정에 실패했습니다.\n");
                }
                break;
            }

            case 4: {
                printf("삭제할 ID: ");
                int id;
                scanf("%d", &id);

                if (delete_person(&db, id) != QUERY_SUCCESS) {
                    printf("레코드 삭제에 실패했습니다.\n");
                }
                break;
            }

            case 5:
                print_all_records(&db);
                break;

            case 6: {
                char name[MAX_NAME_LENGTH];
                printf("검색할 이름: ");
                scanf("%49s", name);

                int results[MAX_RECORDS];
                int count = search_by_name(&db, name, results, MAX_RECORDS);

                char query_desc[100];
                snprintf(query_desc, sizeof(query_desc), "이름 '%s' 검색", name);
                print_search_results(&db, results, count, query_desc);
                break;
            }

            case 7: {
                int min_age, max_age;
                printf("최소 나이: ");
                scanf("%d", &min_age);
                printf("최대 나이: ");
                scanf("%d", &max_age);

                int results[MAX_RECORDS];
                int count = search_by_age_range(&db, min_age, max_age, results, MAX_RECORDS);

                char query_desc[100];
                snprintf(query_desc, sizeof(query_desc), "나이 %d-%d 검색", min_age, max_age);
                print_search_results(&db, results, count, query_desc);
                break;
            }

            case 8: {
                double min_salary, max_salary;
                printf("최소 급여: ");
                scanf("%lf", &min_salary);
                printf("최대 급여: ");
                scanf("%lf", &max_salary);

                int results[MAX_RECORDS];
                int count = search_by_salary_range(&db, min_salary, max_salary, results, MAX_RECORDS);

                char query_desc[100];
                snprintf(query_desc, sizeof(query_desc), "급여 $%.0f-$%.0f 검색", min_salary, max_salary);
                print_search_results(&db, results, count, query_desc);
                break;
            }

            case 9: {
                printf("정렬 기준 (name/age/salary): ");
                char field[20];
                scanf("%19s", field);

                sort_database(&db, field);
                printf("'%s' 기준으로 정렬되었습니다.\n", field);
                break;
            }

            case 10:
                print_statistics(&db);
                break;

            case 11:
                generate_sample_data(&db);
                break;

            case 0:
                printf("프로그램을 종료합니다.\n");
                return;

            default:
                printf("잘못된 선택입니다.\n");
                break;
        }
    }
}

int main() {
    srand(time(NULL));
    interactive_database_system();
    return 0;
}
```

## 마무리

함수의 정의와 호출은 C언어에서 **코드를 구조화하고 재사용 가능하게 만드는 핵심 메커니즘**입니다. 함수를 효과적으로 활용하면 복잡한 문제를 작은 단위로 분해하여 해결할 수 있으며, 유지보수가 용이하고 테스트 가능한 프로그램을 작성할 수 있습니다.

**핵심 포인트:**

1. **함수의 구조 이해**: 반환타입, 함수명, 매개변수, 함수 본문의 역할과 관계
2. **함수 선언과 정의 분리**: 헤더 파일을 통한 모듈화와 재사용성 향상
3. **매개변수와 반환값**: 값에 의한 전달과 적절한 반환값 설계
4. **함수 설계 원칙**: 단일 책임, 명확한 인터페이스, 부작용 최소화
5. **실전 활용**: 라이브러리 구축, 코드 구조화, 복잡한 시스템 개발

**실용적 조언:**

- 함수는 하나의 명확한 작업만 수행하도록 설계하세요
- 함수 이름은 수행하는 작업을 명확히 나타내도록 짓세요
- 매개변수와 반환값의 타입을 신중히 선택하세요
- 오류 처리 방식을 일관되게 설계하세요
- 함수 선언을 헤더 파일에 분리하여 모듈화하세요

함수에 대한 깊은 이해는 객체지향 프로그래밍, 함수형 프로그래밍 등 고급 프로그래밍 패러다임의 기초가 되며, 대규모 소프트웨어 개발에서 필수적인 기술입니다.