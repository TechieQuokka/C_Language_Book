# 2.3 연산자 (Operators)

## 연산자란 무엇인가?

연산자(Operator)는 **데이터에 대해 특정한 연산을 수행하는 기호**입니다. 이는 단순한 산술 계산을 넘어서, 컴퓨터가 데이터를 조작하고 변환하는 모든 방법을 포괄하는 핵심 메커니즘입니다.

### 연산자의 본질적 역할

연산자는 세 가지 핵심 요소를 통해 동작합니다:

1. **피연산자(Operand)**: 연산의 대상이 되는 값이나 변수
2. **연산 기호**: 수행할 연산의 종류를 나타내는 기호
3. **결과값**: 연산 수행 후 생성되는 새로운 값

예를 들어, `a + b`에서:
- `a`와 `b`는 피연산자
- `+`는 덧셈 연산자
- 연산 결과는 `a`와 `b`의 합

### 연산자와 하드웨어의 관계

연산자는 프로그래밍 언어의 추상화된 표현이지만, 실제로는 **CPU의 명령어와 직접적으로 대응**됩니다:

- 산술 연산자 → ALU(Arithmetic Logic Unit) 명령어
- 비트 연산자 → 비트 단위 논리 연산 명령어
- 비교 연산자 → 조건 플래그 설정 명령어

이러한 직접적인 대응 관계로 인해 C언어의 연산자는 매우 효율적이며, 하드웨어의 성능을 최대한 활용할 수 있습니다.

## 연산자의 우선순위와 결합성

### 우선순위의 필요성

수학에서와 마찬가지로, 프로그래밍에서도 여러 연산자가 함께 사용될 때 **실행 순서**가 중요합니다:

```c
int result = 2 + 3 * 4;  // 14 (3*4=12, 2+12=14) 또는 20 (2+3=5, 5*4=20)?
```

C언어는 명확한 우선순위 규칙을 정의하여 이런 모호함을 해결합니다.

### C언어 연산자 우선순위 표

**우선순위가 높을수록 먼저 계산됩니다:**

| 우선순위 | 연산자 | 설명 | 결합성 |
|---------|--------|------|-------|
| 1 | `()` `[]` `->` `.` | 괄호, 배열, 포인터, 멤버 접근 | 좌→우 |
| 2 | `++` `--` `!` `~` `+` `-` `*` `&` `sizeof` `(type)` | 단항 연산자 | 우→좌 |
| 3 | `*` `/` `%` | 곱셈, 나눗셈, 나머지 | 좌→우 |
| 4 | `+` `-` | 덧셈, 뺄셈 | 좌→우 |
| 5 | `<<` `>>` | 비트 이동 | 좌→우 |
| 6 | `<` `<=` `>` `>=` | 관계 연산자 | 좌→우 |
| 7 | `==` `!=` | 동등 연산자 | 좌→우 |
| 8 | `&` | 비트 AND | 좌→우 |
| 9 | `^` | 비트 XOR | 좌→우 |
| 10 | `\|` | 비트 OR | 좌→우 |
| 11 | `&&` | 논리 AND | 좌→우 |
| 12 | `\|\|` | 논리 OR | 좌→우 |
| 13 | `?:` | 삼항 조건 연산자 | 우→좌 |
| 14 | `=` `+=` `-=` `*=` `/=` `%=` 등 | 대입 연산자 | 우→좌 |
| 15 | `,` | 쉼표 연산자 | 좌→우 |

### 결합성(Associativity)

같은 우선순위의 연산자들이 연속으로 나올 때의 계산 순서:

**좌결합(Left-to-Right):**
```c
10 - 5 - 2  →  (10 - 5) - 2  →  5 - 2  →  3
```

**우결합(Right-to-Left):**
```c
a = b = c = 10  →  a = (b = (c = 10))  →  모든 변수에 10 할당
```

### 우선순위 예제 분석

```c
int a = 5, b = 3, c = 2;
int result = a + b * c - 1;

// 계산 순서:
// 1. b * c = 3 * 2 = 6     (곱셈이 덧셈보다 우선)
// 2. a + 6 = 5 + 6 = 11    (덧셈이 뺄셈보다 좌결합)
// 3. 11 - 1 = 10           (최종 결과)
```

**복잡한 예제:**
```c
int x = 2, y = 3, z = 4;
int result = ++x * y + z-- > 10 ? x : y;

// 계산 순서:
// 1. ++x → x=3, 표현식 값은 3
// 2. z-- → 표현식 값은 4, 이후 z=3
// 3. 3 * 3 = 9
// 4. 9 + 4 = 13
// 5. 13 > 10 → true(1)
// 6. 삼항 연산자: true이므로 x 선택
// 7. result = 3
```

## 산술 연산자 (Arithmetic Operators)

### 기본 산술 연산자

산술 연산자는 수학적 계산을 수행하는 가장 기본적인 연산자들입니다.

**1. 덧셈 연산자 (+)**

```c
int a = 5, b = 3;
int sum = a + b;        // 8
float f = 3.14 + 2.86;  // 6.0
```

**특징:**
- 정수끼리 연산: 정수 결과
- 실수가 포함된 연산: 실수 결과
- 문자도 ASCII 값으로 계산 가능

**2. 뺄셈 연산자 (-)**

```c
int diff = 10 - 3;      // 7
unsigned int u = 3 - 5; // 주의: unsigned 언더플로우
```

**주의사항:**
- 부호 없는 정수의 언더플로우는 예상치 못한 큰 값을 만듭니다

**3. 곱셈 연산자 (*)**

```c
int product = 6 * 7;    // 42
long long big = 1000000 * 1000000;  // 오버플로우 위험
```

**오버플로우 예방:**
```c
long long safe = 1000000LL * 1000000LL;  // 안전한 방법
```

**4. 나눗셈 연산자 (/)**

나눗셈은 피연산자의 타입에 따라 동작이 달라집니다:

**정수 나눗셈:**
```c
int a = 7, b = 3;
int quotient = a / b;   // 2 (소수점 이하 절삭)
```

**실수 나눗셈:**
```c
double result = 7.0 / 3.0;  // 2.333333...
double mixed = 7 / 3.0;     // 2.333333... (자동 형변환)
```

**0으로 나누기:**
```c
int x = 5 / 0;          // 런타임 에러 (정수)
double y = 5.0 / 0.0;   // 무한대 (IEEE 754)
```

**5. 나머지 연산자 (%)**

나머지 연산자는 **정수에서만** 사용 가능합니다:

```c
int remainder = 17 % 5;  // 2
int negative = -17 % 5;  // -2 (첫 번째 피연산자의 부호를 따름)
```

**활용 예제:**
```c
// 홀수/짝수 판별
if (number % 2 == 0) {
    printf("짝수\n");
} else {
    printf("홀수\n");
}

// 순환 인덱스
int circular_index = (current_index + 1) % array_size;
```

### 산술 연산의 타입 변환

C언어는 산술 연산 시 자동으로 타입을 변환합니다:

**일반적인 산술 변환 규칙:**

1. **정수 승격(Integer Promotion)**: `char`, `short` → `int`
2. **타입 통일**: 두 피연산자를 같은 타입으로 변환
3. **변환 순서**: `int` → `long` → `long long` → `float` → `double` → `long double`

**예제:**
```c
char c = 100;
short s = 200;
int i = 300;
float f = 4.0f;
double d = 5.0;

// 각 연산의 결과 타입:
c + s;      // int (정수 승격)
i + f;      // float
f + d;      // double
c + d;      // double
```

### 산술 연산의 함정들

**1. 정수 오버플로우**

```c
int max_int = 2147483647;  // int의 최댓값
int overflow = max_int + 1; // -2147483648 (오버플로우)
```

**2. 나눗셈의 정밀도 손실**

```c
int a = 1, b = 3;
double wrong = a / b;       // 0.0 (정수 나눗셈 후 double 변환)
double correct = (double)a / b;  // 0.333333... (올바른 방법)
```

**3. 부동소수점 정밀도**

```c
float f1 = 0.1f + 0.2f;
if (f1 == 0.3f) {  // false일 수 있음!
    printf("같다\n");
}

// 올바른 비교 방법
#include <math.h>
if (fabs(f1 - 0.3f) < 1e-6) {
    printf("거의 같다\n");
}
```

## 증감 연산자 (Increment/Decrement Operators)

증감 연산자는 변수의 값을 1 증가시키거나 감소시키는 특별한 연산자입니다.

### 전위 연산자 (Prefix)

**전위 증가 (++variable):**
```c
int x = 5;
int y = ++x;  // x를 먼저 증가시키고, 그 값을 y에 할당
// x = 6, y = 6
```

**전위 감소 (--variable):**
```c
int a = 10;
int b = --a;  // a를 먼저 감소시키고, 그 값을 b에 할당
// a = 9, b = 9
```

### 후위 연산자 (Postfix)

**후위 증가 (variable++):**
```c
int x = 5;
int y = x++;  // x의 현재 값을 y에 할당한 후, x를 증가
// x = 6, y = 5
```

**후위 감소 (variable--):**
```c
int a = 10;
int b = a--;  // a의 현재 값을 b에 할당한 후, a를 감소
// a = 9, b = 10
```

### 증감 연산자의 내부 동작

**전위 연산자의 의사코드:**
```c
++x;  // 다음과 같이 동작:
// x = x + 1;
// return x;

--x;  // 다음과 같이 동작:
// x = x - 1;
// return x;
```

**후위 연산자의 의사코드:**
```c
x++;  // 다음과 같이 동작:
// temp = x;
// x = x + 1;
// return temp;

x--;  // 다음과 같이 동작:
// temp = x;
// x = x - 1;
// return temp;
```

### 복잡한 예제와 함정

**1. 반복문에서의 사용**

```c
// 올바른 사용법들
for (int i = 0; i < 10; i++) { /* ... */ }
for (int i = 0; i < 10; ++i) { /* ... */ }

// 배열 순회
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr;
while (ptr < arr + 5) {
    printf("%d ", *ptr++);  // 값 출력 후 포인터 이동
}
```

**2. 정의되지 않은 동작 (Undefined Behavior)**

```c
int i = 5;
int result = i++ + ++i;  // 정의되지 않은 동작!
// 컴파일러마다 다른 결과 가능
```

**올바른 방법:**
```c
int i = 5;
int temp1 = i++;  // temp1 = 5, i = 6
int temp2 = ++i;  // i = 7, temp2 = 7
int result = temp1 + temp2;  // 12
```

**3. 함수 인수에서의 주의점**

```c
int x = 5;
printf("%d %d %d\n", x, x++, ++x);  // 정의되지 않은 동작!
```

**안전한 방법:**
```c
int x = 5;
printf("%d ", x);    // 5
printf("%d ", x++);  // 5 (출력 후 x는 6이 됨)
printf("%d\n", ++x); // 7
```

### 성능 고려사항

**기본 타입에서는 차이 없음:**
```c
int i;
++i;  // 전위
i++;  // 후위
// 기본 타입에서는 성능 차이 없음
```

**복합 타입에서는 전위가 효율적:**
C++의 객체나 복잡한 자료구조에서는 전위 연산자가 더 효율적일 수 있습니다. C에서는 대부분 차이가 없지만, 일관성을 위해 전위를 선호하는 경우가 있습니다.

## 대입 연산자 (Assignment Operators)

### 기본 대입 연산자 (=)

기본 대입 연산자는 우변의 값을 좌변의 변수에 저장합니다:

```c
int x = 10;      // 초기화
x = 20;          // 재할당
```

**중요한 특징:**
- 대입 연산자는 **표현식**이며, 할당된 값을 반환합니다
- 우결합성을 가집니다

```c
int a, b, c;
a = b = c = 10;  // 모든 변수에 10 할당
// 실제로는: a = (b = (c = 10));
```

### 복합 대입 연산자 (Compound Assignment)

복합 대입 연산자는 산술 연산과 대입을 결합한 축약 표현입니다:

**1. 산술 복합 대입**

```c
int x = 10;

x += 5;    // x = x + 5;  → x = 15
x -= 3;    // x = x - 3;  → x = 12
x *= 2;    // x = x * 2;  → x = 24
x /= 4;    // x = x / 4;  → x = 6
x %= 5;    // x = x % 5;  → x = 1
```

**2. 비트 복합 대입**

```c
unsigned int flags = 0b11110000;

flags &= 0b11001100;  // flags = flags & 0b11001100
flags |= 0b00000011;  // flags = flags | 0b00000011
flags ^= 0b10101010;  // flags = flags ^ 0b10101010
flags <<= 2;          // flags = flags << 2
flags >>= 1;          // flags = flags >> 1
```

**3. 복합 대입의 장점**

- **간결성**: 코드가 짧아짐
- **안전성**: 변수 이름을 한 번만 쓰므로 실수 방지
- **성능**: 일부 경우에 컴파일러가 더 효율적인 코드 생성 가능

**예제: 배열 요소 증가**
```c
int array[100];
// 긴 인덱스 표현식의 경우
array[complex_function_call()] += 10;
// 다음보다 안전하고 효율적:
// array[complex_function_call()] = array[complex_function_call()] + 10;
```

### 대입 연산의 타입 변환

대입 시에도 자동 타입 변환이 발생합니다:

```c
int i = 3.14;        // double → int (소수점 이하 절삭)
float f = 100;       // int → float
char c = 300;        // int → char (상위 비트 절삭, 결과: 44)
```

**주의사항:**
```c
unsigned char uc = 256;  // 값 256은 8비트로 표현 불가
// 결과: 0 (256 % 256 = 0)

int big = 70000;
short s = big;           // 상위 비트 손실 가능
```

## 비교 연산자 (Relational Operators)

비교 연산자는 두 값의 관계를 비교하여 참(1) 또는 거짓(0)을 반환합니다.

### 관계 연산자

**1. 크기 비교**

```c
int a = 5, b = 3;

bool greater = a > b;        // true (1)
bool less = a < b;           // false (0)
bool greater_equal = a >= b; // true (1)
bool less_equal = a <= b;    // false (0)
```

**2. 동등 비교**

```c
int x = 10, y = 10, z = 20;

bool equal = x == y;         // true (1)
bool not_equal = x != z;     // true (1)
```

### 비교 연산의 타입 변환

비교 연산에서도 자동 타입 변환이 발생합니다:

```c
int i = 5;
double d = 5.0;
bool same = (i == d);        // true (int가 double로 변환)

char c = 'A';  // ASCII 65
bool compare = (c == 65);    // true
```

### 부동소수점 비교의 주의사항

부동소수점 수는 표현의 한계로 인해 정확한 비교가 어렵습니다:

**문제 예제:**
```c
double a = 0.1 + 0.2;
double b = 0.3;
if (a == b) {  // false일 수 있음!
    printf("같다\n");
} else {
    printf("다르다\n");  // 이것이 출력될 수 있음
}
```

**올바른 비교 방법:**
```c
#include <math.h>
#include <float.h>

double a = 0.1 + 0.2;
double b = 0.3;
double epsilon = DBL_EPSILON;  // 또는 1e-9

if (fabs(a - b) < epsilon) {
    printf("거의 같다\n");
}
```

### 문자열 비교의 함정

C언어에서 문자열은 포인터로 처리되므로, `==` 연산자는 주소를 비교합니다:

**잘못된 방법:**
```c
char str1[] = "hello";
char str2[] = "hello";
if (str1 == str2) {  // false! (주소 비교)
    printf("같다\n");
}
```

**올바른 방법:**
```c
#include <string.h>
char str1[] = "hello";
char str2[] = "hello";
if (strcmp(str1, str2) == 0) {  // true (내용 비교)
    printf("같다\n");
}
```

### Signed/Unsigned 비교의 함정

서로 다른 부호 타입을 비교할 때 예상치 못한 결과가 나올 수 있습니다:

```c
int signed_negative = -1;
unsigned int unsigned_value = 1;

if (signed_negative < unsigned_value) {
    printf("음수가 더 작다\n");
} else {
    printf("음수가 더 크다\n");  // 이것이 출력됨!
}
```

**이유:** `-1`이 `unsigned int`로 변환되면서 매우 큰 양수(4294967295)가 됩니다.

**해결 방법:**
```c
if (signed_negative < (int)unsigned_value) {
    printf("음수가 더 작다\n");  // 올바른 결과
}
```

## 논리 연산자 (Logical Operators)

논리 연산자는 논리값(참/거짓)을 다루는 연산자입니다.

### 논리 연산자의 종류

**1. 논리 AND (&&)**

두 조건이 모두 참일 때만 참:

```c
int age = 25;
int score = 85;

if (age >= 18 && score >= 80) {
    printf("합격\n");
}
```

**2. 논리 OR (||)**

두 조건 중 하나라도 참이면 참:

```c
int day = 0;  // 0: 일요일, 6: 토요일

if (day == 0 || day == 6) {
    printf("주말\n");
}
```

**3. 논리 NOT (!)**

조건의 참/거짓을 반전:

```c
int is_valid = 0;  // false

if (!is_valid) {
    printf("유효하지 않음\n");
}
```

### 단축 평가 (Short-Circuit Evaluation)

논리 연산자의 중요한 특징으로, 결과가 확정되면 나머지 조건을 평가하지 않습니다:

**AND 연산에서의 단축 평가:**
```c
int x = 0;
int y = 5;

if (x != 0 && y / x > 2) {  // x가 0이므로 y/x는 계산되지 않음
    printf("조건 만족\n");
}
// 0으로 나누기 오류 방지
```

**OR 연산에서의 단축 평가:**
```c
int found = 1;

if (found || expensive_function()) {  // found가 참이므로 함수 호출 안 함
    printf("찾았거나 조건 만족\n");
}
```

**실용적 활용:**
```c
char *str = get_string();  // NULL일 수 있는 문자열

// 안전한 문자열 검사
if (str != NULL && strlen(str) > 0) {
    printf("유효한 문자열: %s\n", str);
}
```

### 논리 연산자와 비트 연산자의 차이

**논리 연산자:**
- 결과: 0 또는 1
- 단축 평가 수행
- 피연산자를 논리값으로 평가

**비트 연산자:**
- 결과: 비트 단위 연산 결과
- 모든 피연산자 평가
- 비트 패턴 조작

```c
int a = 5;   // 101₂
int b = 3;   // 011₂

// 논리 연산
int logical_and = a && b;  // 1 (둘 다 0이 아니므로)
int logical_or = a || b;   // 1 (둘 다 0이 아니므로)

// 비트 연산
int bitwise_and = a & b;   // 1 (001₂)
int bitwise_or = a | b;    // 7 (111₂)
```

## 비트 연산자 (Bitwise Operators)

비트 연산자는 데이터를 비트 단위로 조작하는 연산자로, 시스템 프로그래밍과 최적화에서 중요한 역할을 합니다.

### 비트 논리 연산자

**1. 비트 AND (&)**

두 비트가 모두 1일 때만 1:

```c
unsigned char a = 0b11110000;  // 240
unsigned char b = 0b11001100;  // 204
unsigned char result = a & b;   // 0b11000000 = 192

// 특정 비트 마스킹에 사용
unsigned int flags = 0b11010110;
unsigned int mask = 0b11110000;   // 상위 4비트만 추출
unsigned int upper_bits = flags & mask;  // 0b11010000
```

**2. 비트 OR (|)**

두 비트 중 하나라도 1이면 1:

```c
unsigned char a = 0b11110000;  // 240
unsigned char b = 0b00001111;  // 15
unsigned char result = a | b;   // 0b11111111 = 255

// 플래그 설정에 사용
#define FLAG_READ    0b00000001
#define FLAG_WRITE   0b00000010
#define FLAG_EXECUTE 0b00000100

unsigned int permissions = 0;
permissions |= FLAG_READ;     // 읽기 권한 추가
permissions |= FLAG_WRITE;    // 쓰기 권한 추가
// permissions = 0b00000011
```

**3. 비트 XOR (^)**

두 비트가 다를 때만 1:

```c
unsigned char a = 0b11110000;  // 240
unsigned char b = 0b11001100;  // 204
unsigned char result = a ^ b;   // 0b00111100 = 60

// 간단한 암호화/복호화
char data = 'A';
char key = 0x5A;
char encrypted = data ^ key;   // 암호화
char decrypted = encrypted ^ key;  // 복호화 (원본 복구)
```

**4. 비트 NOT (~)**

모든 비트를 반전:

```c
unsigned char a = 0b11110000;  // 240
unsigned char result = ~a;      // 0b00001111 = 15

// 특정 비트 끄기
unsigned int flags = 0b11111111;
flags &= ~FLAG_WRITE;  // 쓰기 권한 제거
```

### 비트 이동 연산자

**1. 왼쪽 이동 (<<)**

비트를 왼쪽으로 이동시키고, 오른쪽에는 0을 채움:

```c
unsigned int value = 5;        // 0b00000101
unsigned int shifted = value << 2;  // 0b00010100 = 20

// 2의 거듭제곱 계산
int power_of_2 = 1 << 10;     // 2^10 = 1024

// 특정 비트 위치에 플래그 설정
#define MAKE_FLAG(pos) (1 << (pos))
int flag_at_position_3 = MAKE_FLAG(3);  // 0b00001000
```

**2. 오른쪽 이동 (>>)**

비트를 오른쪽으로 이동:

```c
unsigned int value = 20;       // 0b00010100
unsigned int shifted = value >> 2;  // 0b00000101 = 5

// 2의 거듭제곱으로 나누기
int divided = 100 >> 2;        // 100 / 4 = 25
```

**signed와 unsigned의 차이:**
```c
// unsigned: 논리적 이동 (왼쪽에 0 채움)
unsigned int u = 0x80000000;
unsigned int u_shifted = u >> 1;  // 0x40000000

// signed: 산술적 이동 (부호 비트 확장)
int s = 0x80000000;  // 음수
int s_shifted = s >> 1;  // 0xC0000000 (여전히 음수)
```

### 비트 연산의 실용적 활용

**1. 플래그 관리**

```c
// 파일 권한 시스템
#define PERM_READ    0x01
#define PERM_WRITE   0x02
#define PERM_EXECUTE 0x04
#define PERM_DELETE  0x08

unsigned int permissions = 0;

// 권한 추가
permissions |= PERM_READ | PERM_WRITE;

// 권한 확인
if (permissions & PERM_READ) {
    printf("읽기 권한 있음\n");
}

// 권한 제거
permissions &= ~PERM_WRITE;

// 권한 토글
permissions ^= PERM_EXECUTE;
```

**2. 효율적인 수학 연산**

```c
// 홀수/짝수 판별 (% 연산보다 빠름)
bool is_even(int n) {
    return (n & 1) == 0;
}

// 2의 거듭제곱 여부 확인
bool is_power_of_two(unsigned int n) {
    return n > 0 && (n & (n - 1)) == 0;
}

// 절댓값 (단, int 범위 내에서)
int abs_fast(int x) {
    int mask = x >> 31;  // 음수면 모든 비트 1, 양수면 0
    return (x + mask) ^ mask;
}
```

**3. 비트 필드와 패킹**

```c
// RGB 색상을 32비트 정수로 패킹
typedef union {
    unsigned int value;
    struct {
        unsigned char blue;
        unsigned char green;
        unsigned char red;
        unsigned char alpha;
    } components;
} Color;

Color color;
color.value = 0xFF00FF80;  // 직접 할당
printf("Red: %d, Green: %d, Blue: %d\n",
       color.components.red,
       color.components.green,
       color.components.blue);

// 비트 조작으로 색상 추출
unsigned int rgb = 0xFF00FF80;
unsigned char red   = (rgb >> 16) & 0xFF;
unsigned char green = (rgb >> 8) & 0xFF;
unsigned char blue  = rgb & 0xFF;
```

**4. 해시 함수와 체크섬**

```c
// 간단한 XOR 체크섬
unsigned char calculate_checksum(unsigned char *data, size_t length) {
    unsigned char checksum = 0;
    for (size_t i = 0; i < length; i++) {
        checksum ^= data[i];
    }
    return checksum;
}

// 간단한 해시 함수
unsigned int simple_hash(const char *str) {
    unsigned int hash = 0;
    while (*str) {
        hash = (hash << 5) + hash + *str++;  // hash * 33 + char
    }
    return hash;
}
```

## 삼항 조건 연산자 (Ternary Conditional Operator)

삼항 조건 연산자 `?:`는 조건에 따라 두 값 중 하나를 선택하는 간결한 방법입니다.

### 기본 문법

```c
condition ? value_if_true : value_if_false
```

**기본 예제:**
```c
int a = 10, b = 20;
int max = (a > b) ? a : b;  // max = 20

// if-else문과 동일한 동작:
int max;
if (a > b) {
    max = a;
} else {
    max = b;
}
```

### 삼항 연산자의 특징

**1. 표현식이므로 값을 반환**

```c
printf("더 큰 수: %d\n", (a > b) ? a : b);

// 배열 인덱스로 사용
int array[10];
int index = (condition) ? 5 : 3;
array[index] = 100;
```

**2. 타입 변환**

삼항 연산자의 결과 타입은 두 번째와 세 번째 피연산자의 공통 타입입니다:

```c
int i = 10;
double d = 3.14;
double result = (condition) ? i : d;  // int가 double로 변환
```

### 실용적 활용

**1. 기본값 설정**

```c
char *name = get_user_name();
printf("Hello, %s!\n", name ? name : "Guest");

// NULL 포인터 안전 처리
int length = (str != NULL) ? strlen(str) : 0;
```

**2. 최솟값/최댓값 매크로**

```c
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))

int max_value = MAX(x, y);
int clamped = MAX(0, MIN(value, 100));  // 0-100 범위로 제한
```

**3. 조건부 할당**

```c
// 점수에 따른 등급 결정
char grade = (score >= 90) ? 'A' :
             (score >= 80) ? 'B' :
             (score >= 70) ? 'C' : 'F';

// 절댓값 계산
int abs_value = (x >= 0) ? x : -x;
```

### 중첩 삼항 연산자

복잡한 조건 처리를 위해 중첩할 수 있지만, 가독성에 주의해야 합니다:

**적절한 중첩:**
```c
const char* get_day_type(int day) {
    return (day == 0 || day == 6) ? "Weekend" :
           (day >= 1 && day <= 5) ? "Weekday" : "Invalid";
}
```

**과도한 중첩 (피해야 할 예):**
```c
// 가독성이 떨어지는 코드
int result = (a > b) ? (c > d) ? (e > f) ? 1 : 2 : 3 : 4;

// if-else로 다시 작성하는 것이 좋음
int result;
if (a > b) {
    if (c > d) {
        result = (e > f) ? 1 : 2;
    } else {
        result = 3;
    }
} else {
    result = 4;
}
```

### 삼항 연산자 사용 지침

**사용하면 좋은 경우:**
- 간단한 조건부 할당
- 함수 인수나 return 문에서의 조건부 값
- 간단한 기본값 설정

**피해야 하는 경우:**
- 복잡한 조건식
- 부작용이 있는 함수 호출
- 과도한 중첩으로 가독성이 떨어지는 경우

## 쉼표 연산자 (Comma Operator)

쉼표 연산자는 여러 표현식을 순차적으로 실행하고, 마지막 표현식의 값을 반환합니다.

### 기본 동작

```c
int a, b, c;
int result = (a = 1, b = 2, c = 3);  // result = 3

// 다음과 동일:
a = 1;
b = 2;
c = 3;
result = c;
```

### 실용적 활용

**1. for문에서의 활용**

```c
// 여러 변수 초기화/증가
for (int i = 0, j = 10; i < j; i++, j--) {
    printf("i=%d, j=%d\n", i, j);
}

// 배열 두 개 동시 순회
for (int *p1 = arr1, *p2 = arr2; p1 < arr1 + size; p1++, p2++) {
    *p1 = *p2;
}
```

**2. 매크로에서의 활용**

```c
#define SWAP(a, b) do { \
    typeof(a) temp = a; \
    a = b; \
    b = temp; \
} while(0)

// 쉼표 연산자를 이용한 버전 (GCC 확장)
#define SWAP_COMMA(a, b) ( \
    (a) ^= (b), \
    (b) ^= (a), \
    (a) ^= (b) \
)
```

**3. 디버깅 매크로**

```c
#define DEBUG_PRINT(x) (printf("DEBUG: %s = %d\n", #x, x), x)

int value = 42;
int result = some_function(DEBUG_PRINT(value));
// 출력: DEBUG: value = 42
// some_function은 여전히 42를 받음
```

## 연산자 사용 시 주의사항과 최적화

### 일반적인 함정들

**1. 연산자 우선순위 혼동**

```c
// 잘못된 가정
if (x & 1 == 0) {  // (1 == 0)이 먼저 계산됨!
    printf("짝수\n");
}

// 올바른 방법
if ((x & 1) == 0) {
    printf("짝수\n");
}
```

**2. 부작용이 있는 표현식**

```c
int i = 5;
int arr[10] = {0};

// 정의되지 않은 동작
arr[i] = i++;

// 올바른 방법
arr[i] = i;
i++;
```

**3. 부동소수점 연산의 한계**

```c
// 문제가 될 수 있는 코드
double sum = 0.0;
for (int i = 0; i < 10; i++) {
    sum += 0.1;
}
if (sum == 1.0) {  // false일 수 있음!
    printf("1.0입니다\n");
}

// 안전한 비교
if (fabs(sum - 1.0) < 1e-9) {
    printf("거의 1.0입니다\n");
}
```

### 성능 최적화 팁

**1. 비트 연산 활용**

```c
// 느린 방법
if (x % 2 == 0) { /* 짝수 처리 */ }
int divided = x / 8;

// 빠른 방법 (2의 거듭제곱에 대해서만)
if ((x & 1) == 0) { /* 짝수 처리 */ }
int divided = x >> 3;  // x / 8
```

**2. 단축 평가 활용**

```c
// 비용이 많이 드는 함수를 나중에 배치
if (cheap_condition && expensive_function()) {
    // expensive_function은 cheap_condition이 true일 때만 호출
}
```

**3. 적절한 타입 선택**

```c
// 루프 카운터로는 size_t나 int 사용
for (size_t i = 0; i < array_size; i++) {  // 효율적
    // ...
}

// 불필요한 형변환 피하기
double result = 3.14 * radius * radius;  // good
double result = 3.14f * radius * radius; // float에서 double로 변환 발생
```

## 마무리

연산자는 C언어에서 데이터를 조작하고 처리하는 핵심 도구입니다. **하드웨어와 직접적으로 대응되는 C언어의 특성**상, 연산자를 깊이 이해하면 더 효율적이고 안전한 프로그램을 작성할 수 있습니다.

**핵심 포인트:**

1. **우선순위와 결합성**을 정확히 이해하여 의도한 대로 동작하는 코드 작성
2. **타입 변환** 규칙을 숙지하여 예상치 못한 결과 방지
3. **비트 연산자**를 활용한 효율적인 저수준 프로그래밍
4. **부동소수점 연산**의 한계를 이해하고 적절한 비교 방법 사용
5. **단축 평가**와 **삼항 연산자**를 활용한 효율적인 조건부 실행

**실용적 조언:**

- 복잡한 표현식보다는 명확하고 읽기 쉬운 코드를 우선시하세요
- 성능이 중요한 부분에서는 비트 연산과 적절한 최적화를 활용하세요
- 항상 컴파일러 경고를 주의 깊게 확인하세요
- 플랫폼별 차이를 고려한 이식 가능한 코드를 작성하세요

연산자에 대한 깊은 이해는 C언어의 강력함을 최대한 활용하는 열쇠이며, 시스템 프로그래밍과 고성능 애플리케이션 개발의 기초가 됩니다.