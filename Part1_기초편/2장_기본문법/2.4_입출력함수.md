# 2.4 입출력 함수 (Input/Output Functions)

## 입출력이란 무엇인가?

입출력(Input/Output, I/O)은 **프로그램과 외부 세계 간의 데이터 교환**을 의미합니다. 이는 단순히 화면에 텍스트를 출력하거나 키보드에서 입력을 받는 것을 넘어서, 컴퓨터가 인간 및 다른 시스템과 소통하는 근본적인 메커니즘입니다.

### 입출력의 본질적 의미

프로그램은 본질적으로 **데이터를 입력받아 처리하고 결과를 출력하는 과정**입니다:

1. **입력(Input)**: 외부에서 데이터를 프로그램으로 가져오는 과정
2. **처리(Processing)**: 입력된 데이터를 연산하고 변환하는 과정
3. **출력(Output)**: 처리된 결과를 외부로 보내는 과정

입출력 없이는 프로그램이 완전히 고립된 채로 실행되어, 사용자나 다른 시스템과 상호작용할 수 없습니다.

### C언어에서의 입출력 철학

C언어는 **간단하고 효율적인 입출력 모델**을 추구합니다:

- **스트림 기반**: 모든 입출력을 문자의 연속된 흐름으로 추상화
- **표준 라이브러리**: `stdio.h`를 통한 일관된 인터페이스 제공
- **플랫폼 독립성**: 운영체제에 관계없이 동일한 코드로 작동
- **버퍼링**: 효율성을 위한 자동 버퍼 관리

이러한 설계는 C언어가 시스템 프로그래밍부터 애플리케이션 개발까지 광범위하게 사용될 수 있게 하는 핵심 요소입니다.

## 스트림(Stream)의 개념

### 스트림이란?

스트림(Stream)은 **데이터가 흘러가는 추상적인 통로**입니다. 물이 파이프를 통해 흐르듯이, 데이터가 프로그램과 외부 장치 사이를 흐르는 개념적 경로입니다.

```
[프로그램] ← stdin  ← [키보드]
[프로그램] → stdout → [화면]
[프로그램] → stderr → [화면/로그파일]
```

### 스트림의 특징

**1. 순차적 접근**: 데이터를 순서대로 읽거나 쓸 수 있습니다
**2. 단방향성**: 입력 스트림은 읽기만, 출력 스트림은 쓰기만 가능합니다
**3. 추상화**: 물리적 장치의 차이를 숨기고 일관된 인터페이스 제공합니다

### C언어의 표준 스트림

C 프로그램이 시작될 때 자동으로 세 개의 표준 스트림이 열립니다:

**1. stdin (Standard Input)**
- **용도**: 표준 입력 (일반적으로 키보드)
- **방향**: 프로그램으로 들어오는 입력
- **버퍼링**: 라인 버퍼링 (Enter 키를 누를 때까지 대기)

**2. stdout (Standard Output)**
- **용도**: 표준 출력 (일반적으로 화면)
- **방향**: 프로그램에서 나가는 정상 출력
- **버퍼링**: 터미널에서는 라인 버퍼링, 파일로 리디렉션 시 풀 버퍼링

**3. stderr (Standard Error)**
- **용도**: 표준 오류 출력 (일반적으로 화면)
- **방향**: 프로그램에서 나가는 오류 메시지
- **버퍼링**: 무버퍼링 (즉시 출력)

### 스트림과 파일 포인터

C언어에서 스트림은 `FILE*` 타입의 파일 포인터로 표현됩니다:

```c
#include <stdio.h>

// 전역으로 정의된 표준 스트림들
extern FILE *stdin;   // 표준 입력
extern FILE *stderr;  // 표준 오류
extern FILE *stdout;  // 표준 출력
```

이러한 추상화 덕분에 파일 입출력과 표준 입출력을 동일한 함수들로 처리할 수 있습니다.

## 버퍼링(Buffering)의 이해

### 버퍼링이 필요한 이유

입출력은 상대적으로 느린 작업입니다. 하드디스크, 네트워크, 심지어 화면 출력도 CPU의 처리 속도에 비해 매우 느립니다. 버퍼링은 이러한 속도 차이를 해결하는 핵심 메커니즘입니다.

**버퍼링 없이 문자 하나씩 출력한다면:**
```c
// 매우 비효율적인 가상의 코드
for (int i = 0; i < 1000; i++) {
    직접_화면에_출력('A');  // 1000번의 시스템 호출!
}
```

**버퍼링을 사용하면:**
```c
// 실제 동작 방식
for (int i = 0; i < 1000; i++) {
    버퍼에_저장('A');  // 메모리 연산 (빠름)
}
한번에_화면에_출력(버퍼);  // 1번의 시스템 호출
```

### 버퍼링 종류

**1. 무버퍼링 (Unbuffered)**
- 즉시 출력/입력
- 일반적으로 `stderr`에 사용
- 오류 메시지는 즉시 보여야 하므로

**2. 라인 버퍼링 (Line Buffered)**
- 개행 문자(`\n`)를 만나면 버퍼를 비움
- 일반적으로 터미널의 `stdout`에 사용
- 한 줄씩 처리하는 대화형 프로그램에 적합

**3. 풀 버퍼링 (Fully Buffered)**
- 버퍼가 가득 차거나 명시적으로 플러시할 때까지 대기
- 일반적으로 파일 입출력에 사용
- 최대 효율성 제공

### 버퍼 제어 함수들

**1. fflush() - 버퍼 강제 비우기**

```c
#include <stdio.h>

printf("처리 중");
fflush(stdout);  // 즉시 출력
long_running_task();  // 시간이 오래 걸리는 작업
printf(" 완료!\n");
```

**2. setvbuf() - 버퍼링 모드 설정**

```c
// 버퍼링 모드 변경
setvbuf(stdout, NULL, _IONBF, 0);  // 무버퍼링
setvbuf(stdout, NULL, _IOLBF, 0);  // 라인 버퍼링
setvbuf(stdout, NULL, _IOFBF, 1024);  // 풀 버퍼링 (1024바이트)
```

## printf 함수군

### printf의 기본 개념

`printf`(print formatted)는 **형식화된 출력**을 담당하는 C언어의 핵심 함수입니다. 이 함수는 형식 문자열과 가변 개수의 인수를 받아, 지정된 형식에 따라 데이터를 문자열로 변환하여 출력합니다.

```c
#include <stdio.h>

int printf(const char *format, ...);
```

### printf의 내부 동작 원리

**1. 형식 문자열 파싱**: 형식 지정자(`%d`, `%s` 등)를 찾습니다
**2. 인수 타입 추론**: 형식 지정자에 따라 인수의 타입을 결정합니다
**3. 데이터 변환**: 이진 데이터를 문자열로 변환합니다
**4. 출력 수행**: 변환된 문자열을 출력 스트림에 씁니다

이 과정은 컴파일 타임과 런타임에 걸쳐 일어나며, C언어의 타입 시스템과 밀접하게 연관됩니다.

### 형식 지정자의 완전한 문법

형식 지정자는 다음과 같은 구조를 가집니다:

```
%[플래그][최소너비][.정밀도][길이수정자]변환지정자
```

**예제:**
```c
printf("%+-10.2lf", 3.14159);
//      ||||| |  ||
//      ||||+-+--++--- 변환지정자 (lf: long double)
//      |||+----------- 길이수정자 (l)
//      ||+------------ 정밀도 (.2)
//      |+------------- 최소너비 (10)
//      +-------------- 플래그 (+-)
```

### 기본 변환 지정자

**1. 정수 타입**

```c
int num = 42;
unsigned int unum = 42U;

printf("%d\n", num);      // 42 (부호 있는 십진수)
printf("%i\n", num);      // 42 (부호 있는 십진수, %d와 동일)
printf("%u\n", unum);     // 42 (부호 없는 십진수)
printf("%o\n", num);      // 52 (8진수)
printf("%x\n", num);      // 2a (16진수, 소문자)
printf("%X\n", num);      // 2A (16진수, 대문자)
```

**2. 문자 타입**

```c
char ch = 'A';
char str[] = "Hello";

printf("%c\n", ch);       // A (문자)
printf("%s\n", str);      // Hello (문자열)
```

**3. 부동소수점 타입**

```c
double pi = 3.14159265359;
double big = 1234567.89;
double small = 0.000123;

printf("%f\n", pi);       // 3.141593 (고정소수점)
printf("%e\n", big);      // 1.234568e+06 (과학적 표기법, 소문자)
printf("%E\n", big);      // 1.234568E+06 (과학적 표기법, 대문자)
printf("%g\n", small);    // 0.000123 (자동 선택, 소문자)
printf("%G\n", small);    // 0.000123 (자동 선택, 대문자)
```

**4. 포인터와 특수 타입**

```c
int value = 100;
int *ptr = &value;

printf("%p\n", ptr);      // 0x7fff5fbff6ac (포인터 주소)
printf("%%\n");           // % (% 기호 자체)
```

### 길이 수정자 (Length Modifiers)

길이 수정자는 인수의 크기를 명시적으로 지정합니다:

**정수용 길이 수정자:**

```c
short s = 100;
long l = 100000L;
long long ll = 100000000000LL;
size_t sz = 1000;

printf("%hd\n", s);       // short
printf("%ld\n", l);       // long
printf("%lld\n", ll);     // long long
printf("%zd\n", sz);      // size_t
```

**부동소수점용 길이 수정자:**

```c
float f = 3.14f;
double d = 3.14159;
long double ld = 3.14159265359L;

printf("%f\n", f);        // float (자동으로 double로 승격)
printf("%lf\n", d);       // double
printf("%Lf\n", ld);      // long double
```

### 플래그 (Flags)

플래그는 출력 형식을 세밀하게 조정합니다:

**1. `-` (왼쪽 정렬)**

```c
printf("|%-10s|\n", "Hello");    // |Hello     |
printf("|%10s|\n", "Hello");     // |     Hello|
```

**2. `+` (부호 항상 표시)**

```c
printf("%+d\n", 42);    // +42
printf("%+d\n", -42);   // -42
printf("%d\n", 42);     // 42
```

**3. ` ` (공백, 양수 앞에 공백)**

```c
printf("% d\n", 42);    //  42
printf("% d\n", -42);   // -42
```

**4. `#` (대체 형식)**

```c
printf("%#o\n", 42);    // 052 (8진수 접두사)
printf("%#x\n", 42);    // 0x2a (16진수 접두사)
printf("%#f\n", 42.0);  // 42.000000 (소수점 강제 표시)
```

**5. `0` (0으로 패딩)**

```c
printf("%08d\n", 42);   // 00000042
printf("%08.2f\n", 3.14); // 00003.14
```

### 너비와 정밀도

**1. 최소 너비**

```c
printf("%5d\n", 42);     //    42 (5자리, 오른쪽 정렬)
printf("%-5d\n", 42);    // 42    (5자리, 왼쪽 정렬)
printf("%*d\n", 8, 42);  //      42 (동적 너비)
```

**2. 정밀도**

```c
// 부동소수점: 소수점 이하 자릿수
printf("%.2f\n", 3.14159);   // 3.14
printf("%.0f\n", 3.14159);   // 3

// 문자열: 최대 출력 문자 수
printf("%.3s\n", "Hello");   // Hel

// 정수: 최소 출력 자릿수 (0으로 패딩)
printf("%.5d\n", 42);        // 00042
```

**3. 동적 너비와 정밀도**

```c
int width = 10;
int precision = 2;
double value = 3.14159;

printf("%*.*f\n", width, precision, value);  //       3.14
```

### printf 함수군의 변형들

**1. fprintf() - 파일로 출력**

```c
#include <stdio.h>

FILE *file = fopen("output.txt", "w");
fprintf(file, "숫자: %d\n", 42);
fprintf(stderr, "오류: %s\n", "파일을 찾을 수 없음");
fclose(file);
```

**2. sprintf() - 문자열로 출력**

```c
char buffer[100];
int len = sprintf(buffer, "이름: %s, 나이: %d", "홍길동", 25);
printf("생성된 문자열: %s (길이: %d)\n", buffer, len);
```

**3. snprintf() - 안전한 문자열 출력**

```c
char buffer[20];
int len = snprintf(buffer, sizeof(buffer), "긴 문자열입니다 %d", 12345);
if (len >= sizeof(buffer)) {
    printf("버퍼가 부족합니다. 필요한 크기: %d\n", len + 1);
}
```

### printf의 고급 활용

**1. 테이블 형식 출력**

```c
printf("%-10s %5s %8s\n", "이름", "나이", "점수");
printf("%-10s %5d %8.1f\n", "홍길동", 25, 85.5);
printf("%-10s %5d %8.1f\n", "김철수", 30, 92.3);
```

**2. 진행률 표시**

```c
for (int i = 0; i <= 100; i += 10) {
    printf("\r진행률: %3d%% [", i);
    for (int j = 0; j < i/5; j++) printf("=");
    for (int j = i/5; j < 20; j++) printf(" ");
    printf("]");
    fflush(stdout);
    usleep(200000);  // 0.2초 대기
}
printf("\n");
```

**3. 16진수 덤프**

```c
void hex_dump(const void *data, size_t size) {
    const unsigned char *bytes = (const unsigned char *)data;
    for (size_t i = 0; i < size; i += 16) {
        printf("%08zx: ", i);

        // 16진수 출력
        for (size_t j = 0; j < 16; j++) {
            if (i + j < size) {
                printf("%02x ", bytes[i + j]);
            } else {
                printf("   ");
            }
        }

        printf("| ");

        // ASCII 출력
        for (size_t j = 0; j < 16 && i + j < size; j++) {
            unsigned char c = bytes[i + j];
            printf("%c", (c >= 32 && c <= 126) ? c : '.');
        }
        printf("\n");
    }
}
```

## scanf 함수군

### scanf의 기본 개념

`scanf`(scan formatted)는 **형식화된 입력**을 담당하는 함수로, printf의 반대 역할을 수행합니다. 입력 스트림에서 데이터를 읽어 지정된 형식에 따라 파싱하고, 변수에 저장합니다.

```c
#include <stdio.h>

int scanf(const char *format, ...);
```

### scanf의 내부 동작 원리

**1. 입력 스트림 읽기**: 버퍼에서 문자들을 읽습니다
**2. 형식 문자열 매칭**: 형식 지정자에 따라 입력을 파싱합니다
**3. 데이터 변환**: 문자열을 해당 타입의 이진 데이터로 변환합니다
**4. 메모리 저장**: 변환된 데이터를 주어진 주소에 저장합니다

이 과정에서 **주소 전달**이 핵심입니다. scanf는 변수의 값이 아닌 주소를 받아야 데이터를 저장할 수 있습니다.

### 기본 입력 형식 지정자

**1. 정수 입력**

```c
int num;
unsigned int unum;
short s;
long l;

scanf("%d", &num);       // 10진 정수
scanf("%i", &num);       // 자동 진법 판별 (010=8진, 0x10=16진)
scanf("%u", &unum);      // 부호 없는 정수
scanf("%o", &num);       // 8진 정수
scanf("%x", &num);       // 16진 정수
scanf("%hd", &s);        // short
scanf("%ld", &l);        // long
```

**2. 문자 및 문자열 입력**

```c
char ch;
char str[100];

scanf("%c", &ch);        // 문자 하나 (공백 포함)
scanf("%s", str);        // 문자열 (공백까지, 주소 연산자 & 불필요)
```

**3. 부동소수점 입력**

```c
float f;
double d;
long double ld;

scanf("%f", &f);         // float
scanf("%lf", &d);        // double
scanf("%Lf", &ld);       // long double
```

### scanf 사용 시 주의사항

**1. 주소 연산자 (&) 필수**

```c
int num;
scanf("%d", num);        // 잘못됨! 컴파일 경고
scanf("%d", &num);       // 올바름
```

**문자열은 예외:**
```c
char str[100];
scanf("%s", str);        // 올바름 (배열 이름은 이미 주소)
scanf("%s", &str);       // 잘못됨! &str은 다른 타입
```

**2. 버퍼 오버플로우 위험**

```c
char name[10];
scanf("%s", name);       // 위험! 9자 이상 입력 시 오버플로우

// 안전한 방법
scanf("%9s", name);      // 최대 9문자만 읽기 (널 문자 고려)
```

**3. 형식 불일치**

```c
int num;
scanf("%d", &num);       // 사용자가 "abc" 입력 시 실패
if (scanf("%d", &num) != 1) {
    printf("잘못된 입력입니다.\n");
}
```

### scanf의 반환값과 오류 처리

scanf는 **성공적으로 변환된 항목의 개수**를 반환합니다:

```c
int num1, num2;
int result = scanf("%d %d", &num1, &num2);

if (result == 2) {
    printf("두 정수 모두 입력 성공: %d, %d\n", num1, num2);
} else if (result == 1) {
    printf("첫 번째 정수만 입력 성공: %d\n", num1);
} else {
    printf("입력 실패\n");
}
```

**EOF 처리:**
```c
int num;
while (scanf("%d", &num) == 1) {  // EOF(-1) 시 종료
    printf("입력된 수: %d\n", num);
}
```

### 입력 버퍼 문제와 해결

**문제 상황:**
```c
int age;
char name[50];

printf("나이: ");
scanf("%d", &age);           // "25\n" 입력, 버퍼에 '\n' 남음
printf("이름: ");
scanf("%s", name);           // '\n'을 건너뛰어 정상 동작

// 하지만 getchar()와 혼용 시 문제
getchar();                   // '\n'을 읽어버림
```

**해결 방법들:**

**1. 형식 문자열에 공백 추가**
```c
scanf("%d", &age);
scanf(" %s", name);          // 앞의 공백이 화이트스페이스 무시
```

**2. 버퍼 비우기**
```c
void clear_input_buffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

scanf("%d", &age);
clear_input_buffer();
scanf("%s", name);
```

**3. fgets와 sscanf 조합 사용**
```c
char line[100];
int age;
char name[50];

printf("나이: ");
fgets(line, sizeof(line), stdin);
sscanf(line, "%d", &age);

printf("이름: ");
fgets(line, sizeof(line), stdin);
sscanf(line, "%s", name);
```

### scanf 함수군의 변형들

**1. fscanf() - 파일에서 입력**

```c
FILE *file = fopen("input.txt", "r");
int num;
char str[100];

if (file != NULL) {
    fscanf(file, "%d %s", &num, str);
    fclose(file);
}
```

**2. sscanf() - 문자열에서 입력**

```c
char data[] = "홍길동 25 85.5";
char name[20];
int age;
double score;

int items = sscanf(data, "%s %d %lf", name, &age, &score);
if (items == 3) {
    printf("파싱 성공: %s, %d세, %.1f점\n", name, age, score);
}
```

### 고급 scanf 활용

**1. 문자 집합 지정 (`[...]`)**

```c
char vowels[100];
char consonants[100];

// 모음만 읽기
scanf("%[aeiouAEIOU]", vowels);

// 자음만 읽기 (모음이 아닌 문자들)
scanf("%[^aeiouAEIOU]", consonants);

// 숫자와 공백만 읽기
scanf("%[0-9 ]", buffer);
```

**2. 필드 폭 지정**

```c
char code[5];
char name[11];

// 정확히 4문자의 코드와 10문자의 이름
scanf("%4s %10s", code, name);
```

**3. 항목 무시 (`*`)**

```c
int day, year;
// "2023-12-25" 형식에서 월은 무시하고 일과 년도만 읽기
scanf("%d-%*d-%d", &day, &year);
```

### scanf의 대안들

scanf는 강력하지만 위험할 수 있습니다. 더 안전한 대안들:

**1. fgets + sscanf 조합**

```c
char line[256];
int num;

printf("숫자 입력: ");
if (fgets(line, sizeof(line), stdin) != NULL) {
    if (sscanf(line, "%d", &num) == 1) {
        printf("입력받은 숫자: %d\n", num);
    } else {
        printf("잘못된 형식입니다.\n");
    }
}
```

**2. strtol, strtod 등 사용**

```c
#include <stdlib.h>

char *input = "123abc";
char *endptr;
long num = strtol(input, &endptr, 10);

if (endptr != input && *endptr == '\0') {
    printf("완전한 숫자: %ld\n", num);
} else {
    printf("숫자 변환 실패 또는 불완전한 숫자\n");
}
```

## 문자 입출력 함수들

### 문자 단위 입출력의 필요성

때로는 문자 하나씩 섬세하게 제어해야 하는 상황이 있습니다:

- 사용자 입력의 실시간 처리
- 파일의 바이트 단위 분석
- 특수 문자나 제어 문자 처리
- 버퍼 제어와 성능 최적화

### getchar()와 putchar()

**getchar() - 문자 하나 읽기**

```c
#include <stdio.h>

int getchar(void);  // stdin에서 한 문자 읽기, EOF 시 -1 반환
```

**putchar() - 문자 하나 출력**

```c
#include <stdio.h>

int putchar(int c);  // stdout에 한 문자 출력, 성공 시 문자값, 실패 시 EOF 반환
```

**기본 사용 예제:**

```c
#include <stdio.h>

int main() {
    int ch;

    printf("문자를 입력하세요 (EOF로 종료): ");
    while ((ch = getchar()) != EOF) {
        putchar(ch);  // 입력받은 문자 그대로 출력
    }

    return 0;
}
```

### 파일 기반 문자 입출력

**getc()와 putc() - 파일 포인터 지정**

```c
int getc(FILE *stream);
int putc(int c, FILE *stream);

// 사용 예제
FILE *input = fopen("input.txt", "r");
FILE *output = fopen("output.txt", "w");

int ch;
while ((ch = getc(input)) != EOF) {
    putc(ch, output);  // 파일 복사
}

fclose(input);
fclose(output);
```

**fgetc()와 fputc() - 함수로 보장**

```c
int fgetc(FILE *stream);  // 반드시 함수 호출
int fputc(int c, FILE *stream);

// getc/putc는 매크로일 수 있지만, fgetc/fputc는 항상 함수
```

### 실용적인 문자 입출력 예제

**1. 파일 내용 출력 (cat 명령어)**

```c
#include <stdio.h>

void print_file(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        perror("파일 열기 실패");
        return;
    }

    int ch;
    while ((ch = fgetc(file)) != EOF) {
        putchar(ch);
    }

    fclose(file);
}
```

**2. 대소문자 변환 필터**

```c
#include <stdio.h>
#include <ctype.h>

int main() {
    printf("텍스트를 입력하세요 (대문자로 변환됩니다):\n");

    int ch;
    while ((ch = getchar()) != EOF) {
        putchar(toupper(ch));
    }

    return 0;
}
```

**3. 단어 개수 세기**

```c
#include <stdio.h>
#include <ctype.h>

int count_words(FILE *file) {
    int ch;
    int in_word = 0;
    int word_count = 0;

    while ((ch = fgetc(file)) != EOF) {
        if (isspace(ch)) {
            in_word = 0;
        } else if (!in_word) {
            in_word = 1;
            word_count++;
        }
    }

    return word_count;
}
```

**4. 16진수 뷰어**

```c
#include <stdio.h>
#include <ctype.h>

void hex_view(const char *filename) {
    FILE *file = fopen(filename, "rb");  // 바이너리 모드
    if (file == NULL) {
        perror("파일 열기 실패");
        return;
    }

    int ch;
    int pos = 0;

    while ((ch = fgetc(file)) != EOF) {
        if (pos % 16 == 0) {
            printf("%08x: ", pos);
        }

        printf("%02x ", (unsigned char)ch);

        if (pos % 16 == 15) {
            printf(" | ");
            fseek(file, pos - 15, SEEK_SET);
            for (int i = 0; i < 16; i++) {
                int ascii_ch = fgetc(file);
                putchar(isprint(ascii_ch) ? ascii_ch : '.');
            }
            printf("\n");
        }

        pos++;
    }

    fclose(file);
}
```

### 버퍼링과 성능 고려사항

**getchar/putchar vs fgetc/fputc vs scanf/printf 성능 비교:**

```c
#include <stdio.h>
#include <time.h>

void test_performance() {
    clock_t start, end;
    const int COUNT = 1000000;

    // 1. putchar 테스트
    start = clock();
    for (int i = 0; i < COUNT; i++) {
        putchar('A');
    }
    end = clock();
    printf("\nputchar: %f초\n",
           ((double)(end - start)) / CLOCKS_PER_SEC);

    // 2. printf 테스트
    start = clock();
    for (int i = 0; i < COUNT; i++) {
        printf("A");
    }
    end = clock();
    printf("printf: %f초\n",
           ((double)(end - start)) / CLOCKS_PER_SEC);
}
```

**일반적인 성능 순서:**
1. `putchar/getchar` (가장 빠름)
2. `putc/getc`
3. `fputc/fgetc`
4. `printf/scanf` (가장 느림, 하지만 가장 유연함)

## 문자열 입출력 함수들

### gets()와 puts() - 기본 문자열 입출력

**puts() - 문자열 출력**

```c
#include <stdio.h>

int puts(const char *s);  // 문자열 출력 후 자동으로 개행 추가
```

**gets() - 문자열 입력 (위험함!)**

```c
// 사용하지 마세요! 보안 위험
char *gets(char *s);  // C11에서 제거됨
```

**사용 예제:**

```c
char message[] = "Hello, World!";
puts(message);           // "Hello, World!\n" 출력
puts("안녕하세요!");     // "안녕하세요!\n" 출력

// gets는 사용하지 마세요!
// char buffer[100];
// gets(buffer);  // 버퍼 오버플로우 위험!
```

### fgets()와 fputs() - 안전한 문자열 입출력

**fgets() - 안전한 문자열 입력**

```c
#include <stdio.h>

char *fgets(char *s, int size, FILE *stream);
```

**특징:**
- 최대 `size-1`개 문자 읽기 (널 문자 공간 확보)
- 개행 문자(`\n`)도 문자열에 포함
- EOF나 오류 시 NULL 반환

**fputs() - 문자열 출력 (개행 없음)**

```c
int fputs(const char *s, FILE *stream);
```

**기본 사용 예제:**

```c
#include <stdio.h>
#include <string.h>

int main() {
    char line[256];

    printf("한 줄을 입력하세요: ");
    if (fgets(line, sizeof(line), stdin) != NULL) {
        // 개행 문자 제거
        size_t len = strlen(line);
        if (len > 0 && line[len-1] == '\n') {
            line[len-1] = '\0';
        }

        printf("입력받은 내용: ");
        fputs(line, stdout);
        fputs("\n", stdout);
    }

    return 0;
}
```

### 안전한 문자열 입력 구현

**1. 개행 문자 처리**

```c
char *safe_gets(char *buffer, size_t size) {
    if (fgets(buffer, size, stdin) != NULL) {
        size_t len = strlen(buffer);
        // 개행 문자 제거
        if (len > 0 && buffer[len-1] == '\n') {
            buffer[len-1] = '\0';
        } else {
            // 버퍼가 가득 찬 경우, 나머지 입력 제거
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF);
        }
        return buffer;
    }
    return NULL;
}
```

**2. 검증이 포함된 입력**

```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int get_valid_string(char *buffer, size_t size, const char *prompt) {
    while (1) {
        printf("%s", prompt);

        if (fgets(buffer, size, stdin) == NULL) {
            return -1;  // EOF 또는 오류
        }

        // 개행 문자 제거
        size_t len = strlen(buffer);
        if (len > 0 && buffer[len-1] == '\n') {
            buffer[len-1] = '\0';
            len--;
        }

        // 빈 문자열 검사
        if (len == 0) {
            printf("빈 문자열은 허용되지 않습니다.\n");
            continue;
        }

        // 공백만 있는지 검사
        int only_spaces = 1;
        for (size_t i = 0; i < len; i++) {
            if (!isspace(buffer[i])) {
                only_spaces = 0;
                break;
            }
        }

        if (only_spaces) {
            printf("공백만으로는 허용되지 않습니다.\n");
            continue;
        }

        return len;  // 성공
    }
}
```

### 파일 기반 문자열 처리

**1. 텍스트 파일 라인별 처리**

```c
#include <stdio.h>
#include <string.h>

void process_file_lines(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        perror("파일 열기 실패");
        return;
    }

    char line[1024];
    int line_number = 1;

    while (fgets(line, sizeof(line), file) != NULL) {
        printf("%3d: %s", line_number, line);
        line_number++;
    }

    fclose(file);
}
```

**2. 설정 파일 파서**

```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

typedef struct {
    char key[64];
    char value[256];
} Config;

int parse_config(const char *filename, Config configs[], int max_configs) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        return -1;
    }

    char line[512];
    int count = 0;

    while (fgets(line, sizeof(line), file) != NULL && count < max_configs) {
        // 주석과 빈 줄 건너뛰기
        char *start = line;
        while (isspace(*start)) start++;
        if (*start == '#' || *start == '\0') continue;

        // 키=값 형식 파싱
        char *eq = strchr(start, '=');
        if (eq == NULL) continue;

        *eq = '\0';
        char *key = start;
        char *value = eq + 1;

        // 앞뒤 공백 제거
        char *key_end = key + strlen(key) - 1;
        while (key_end > key && isspace(*key_end)) *key_end-- = '\0';

        while (isspace(*value)) value++;
        char *value_end = value + strlen(value) - 1;
        while (value_end > value && isspace(*value_end)) *value_end-- = '\0';

        // 구조체에 저장
        strncpy(configs[count].key, key, sizeof(configs[count].key) - 1);
        strncpy(configs[count].value, value, sizeof(configs[count].value) - 1);
        count++;
    }

    fclose(file);
    return count;
}
```

**3. 로그 파일 분석기**

```c
#include <stdio.h>
#include <string.h>
#include <time.h>

typedef struct {
    char timestamp[32];
    char level[16];
    char message[256];
} LogEntry;

int parse_log_line(const char *line, LogEntry *entry) {
    // "[2023-12-25 10:30:45] INFO: 서버 시작" 형식 파싱
    if (sscanf(line, "[%31[^]]] %15[^:]: %255[^\n]",
               entry->timestamp, entry->level, entry->message) == 3) {
        return 1;
    }
    return 0;
}

void analyze_log_file(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        perror("로그 파일 열기 실패");
        return;
    }

    char line[512];
    LogEntry entry;
    int total_lines = 0;
    int error_count = 0;
    int warning_count = 0;

    while (fgets(line, sizeof(line), file) != NULL) {
        total_lines++;

        if (parse_log_line(line, &entry)) {
            if (strcmp(entry.level, "ERROR") == 0) {
                error_count++;
                printf("오류 발견: [%s] %s\n", entry.timestamp, entry.message);
            } else if (strcmp(entry.level, "WARN") == 0) {
                warning_count++;
            }
        }
    }

    printf("\n=== 로그 분석 결과 ===\n");
    printf("총 라인 수: %d\n", total_lines);
    printf("오류 개수: %d\n", error_count);
    printf("경고 개수: %d\n", warning_count);

    fclose(file);
}
```

## 입출력 함수 활용 실습

### 실습 1: 간단한 계산기

```c
#include <stdio.h>
#include <math.h>

void calculator() {
    double num1, num2, result;
    char operator;
    char line[256];

    printf("=== 간단한 계산기 ===\n");
    printf("사용법: 숫자1 연산자 숫자2 (예: 3.5 + 2.1)\n");
    printf("종료하려면 'q'를 입력하세요.\n\n");

    while (1) {
        printf("계산식: ");
        if (fgets(line, sizeof(line), stdin) == NULL) break;

        if (line[0] == 'q' || line[0] == 'Q') {
            printf("계산기를 종료합니다.\n");
            break;
        }

        if (sscanf(line, "%lf %c %lf", &num1, &operator, &num2) != 3) {
            printf("잘못된 형식입니다. 다시 입력해주세요.\n");
            continue;
        }

        switch (operator) {
            case '+':
                result = num1 + num2;
                printf("%.2f + %.2f = %.2f\n", num1, num2, result);
                break;
            case '-':
                result = num1 - num2;
                printf("%.2f - %.2f = %.2f\n", num1, num2, result);
                break;
            case '*':
                result = num1 * num2;
                printf("%.2f * %.2f = %.2f\n", num1, num2, result);
                break;
            case '/':
                if (num2 != 0) {
                    result = num1 / num2;
                    printf("%.2f / %.2f = %.2f\n", num1, num2, result);
                } else {
                    printf("오류: 0으로 나눌 수 없습니다.\n");
                }
                break;
            case '^':
                result = pow(num1, num2);
                printf("%.2f ^ %.2f = %.2f\n", num1, num2, result);
                break;
            default:
                printf("지원하지 않는 연산자입니다: %c\n", operator);
        }
        printf("\n");
    }
}
```

### 실습 2: 학생 성적 관리 시스템

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_STUDENTS 100
#define NAME_SIZE 50

typedef struct {
    char name[NAME_SIZE];
    int korean;
    int english;
    int math;
    float average;
} Student;

void input_student(Student *student) {
    printf("학생 이름: ");
    fgets(student->name, sizeof(student->name), stdin);
    // 개행 문자 제거
    size_t len = strlen(student->name);
    if (len > 0 && student->name[len-1] == '\n') {
        student->name[len-1] = '\0';
    }

    printf("국어 점수: ");
    scanf("%d", &student->korean);

    printf("영어 점수: ");
    scanf("%d", &student->english);

    printf("수학 점수: ");
    scanf("%d", &student->math);

    // 버퍼 비우기
    while (getchar() != '\n');

    // 평균 계산
    student->average = (student->korean + student->english + student->math) / 3.0f;
}

void print_student(const Student *student) {
    printf("%-15s %3d %3d %3d %6.2f\n",
           student->name, student->korean, student->english,
           student->math, student->average);
}

void print_all_students(Student students[], int count) {
    printf("\n=== 학생 성적 현황 ===\n");
    printf("%-15s %3s %3s %3s %6s\n", "이름", "국어", "영어", "수학", "평균");
    printf("----------------------------------------\n");

    for (int i = 0; i < count; i++) {
        print_student(&students[i]);
    }

    if (count > 0) {
        float total_avg = 0;
        for (int i = 0; i < count; i++) {
            total_avg += students[i].average;
        }
        total_avg /= count;
        printf("----------------------------------------\n");
        printf("전체 평균: %.2f\n", total_avg);
    }
}

void save_to_file(Student students[], int count, const char *filename) {
    FILE *file = fopen(filename, "w");
    if (file == NULL) {
        printf("파일 저장에 실패했습니다.\n");
        return;
    }

    fprintf(file, "%d\n", count);
    for (int i = 0; i < count; i++) {
        fprintf(file, "%s\n%d %d %d %.2f\n",
                students[i].name, students[i].korean,
                students[i].english, students[i].math, students[i].average);
    }

    fclose(file);
    printf("파일이 저장되었습니다: %s\n", filename);
}

int load_from_file(Student students[], const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        return 0;  // 파일이 없으면 0 반환
    }

    int count;
    fscanf(file, "%d", &count);

    char line[256];
    fgets(line, sizeof(line), file);  // 개행 문자 소비

    for (int i = 0; i < count && i < MAX_STUDENTS; i++) {
        fgets(students[i].name, sizeof(students[i].name), file);
        // 개행 문자 제거
        size_t len = strlen(students[i].name);
        if (len > 0 && students[i].name[len-1] == '\n') {
            students[i].name[len-1] = '\0';
        }

        fscanf(file, "%d %d %d %f",
               &students[i].korean, &students[i].english,
               &students[i].math, &students[i].average);
        fgets(line, sizeof(line), file);  // 개행 문자 소비
    }

    fclose(file);
    return count;
}

void student_management_system() {
    Student students[MAX_STUDENTS];
    int student_count = 0;
    char choice;

    // 파일에서 데이터 로드
    student_count = load_from_file(students, "students.dat");
    if (student_count > 0) {
        printf("기존 데이터 %d명을 불러왔습니다.\n", student_count);
    }

    while (1) {
        printf("\n=== 학생 성적 관리 시스템 ===\n");
        printf("1. 학생 추가\n");
        printf("2. 전체 학생 조회\n");
        printf("3. 파일 저장\n");
        printf("4. 종료\n");
        printf("선택: ");

        scanf(" %c", &choice);
        while (getchar() != '\n');  // 버퍼 비우기

        switch (choice) {
            case '1':
                if (student_count < MAX_STUDENTS) {
                    printf("\n=== 학생 정보 입력 ===\n");
                    input_student(&students[student_count]);
                    student_count++;
                    printf("학생이 추가되었습니다.\n");
                } else {
                    printf("더 이상 학생을 추가할 수 없습니다.\n");
                }
                break;

            case '2':
                print_all_students(students, student_count);
                break;

            case '3':
                save_to_file(students, student_count, "students.dat");
                break;

            case '4':
                printf("프로그램을 종료합니다.\n");
                return;

            default:
                printf("잘못된 선택입니다.\n");
        }
    }
}
```

### 실습 3: 텍스트 파일 분석기

```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

typedef struct {
    int lines;
    int words;
    int characters;
    int characters_no_spaces;
} TextStats;

void analyze_text_file(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("파일을 열 수 없습니다: %s\n", filename);
        return;
    }

    TextStats stats = {0, 0, 0, 0};
    int ch;
    int in_word = 0;
    int line_has_content = 0;

    while ((ch = fgetc(file)) != EOF) {
        stats.characters++;

        if (ch == '\n') {
            if (line_has_content) {
                stats.lines++;
            }
            line_has_content = 0;
            in_word = 0;
        } else {
            line_has_content = 1;

            if (!isspace(ch)) {
                stats.characters_no_spaces++;
                if (!in_word) {
                    stats.words++;
                    in_word = 1;
                }
            } else {
                in_word = 0;
            }
        }
    }

    // 마지막 줄이 개행 문자로 끝나지 않는 경우
    if (line_has_content) {
        stats.lines++;
    }

    fclose(file);

    printf("\n=== 텍스트 파일 분석 결과 ===\n");
    printf("파일명: %s\n", filename);
    printf("줄 수: %d\n", stats.lines);
    printf("단어 수: %d\n", stats.words);
    printf("문자 수: %d\n", stats.characters);
    printf("공백 제외 문자 수: %d\n", stats.characters_no_spaces);

    if (stats.lines > 0) {
        printf("평균 줄당 단어 수: %.2f\n", (float)stats.words / stats.lines);
    }
}

void find_word_in_file(const char *filename, const char *search_word) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("파일을 열 수 없습니다: %s\n", filename);
        return;
    }

    char line[1024];
    int line_number = 1;
    int total_count = 0;

    printf("\n=== '%s' 검색 결과 ===\n", search_word);

    while (fgets(line, sizeof(line), file) != NULL) {
        char *pos = line;
        int line_count = 0;

        while ((pos = strstr(pos, search_word)) != NULL) {
            if (line_count == 0) {
                printf("%d: %s", line_number, line);
            }
            line_count++;
            total_count++;
            pos += strlen(search_word);
        }

        line_number++;
    }

    printf("총 %d개 발견\n", total_count);
    fclose(file);
}

void text_analyzer() {
    char filename[256];
    char choice;

    printf("분석할 텍스트 파일명을 입력하세요: ");
    fgets(filename, sizeof(filename), stdin);

    // 개행 문자 제거
    size_t len = strlen(filename);
    if (len > 0 && filename[len-1] == '\n') {
        filename[len-1] = '\0';
    }

    while (1) {
        printf("\n=== 텍스트 분석기 ===\n");
        printf("1. 파일 통계 분석\n");
        printf("2. 단어 검색\n");
        printf("3. 다른 파일 선택\n");
        printf("4. 종료\n");
        printf("선택: ");

        scanf(" %c", &choice);
        while (getchar() != '\n');

        switch (choice) {
            case '1':
                analyze_text_file(filename);
                break;

            case '2': {
                char search_word[100];
                printf("검색할 단어: ");
                fgets(search_word, sizeof(search_word), stdin);

                // 개행 문자 제거
                len = strlen(search_word);
                if (len > 0 && search_word[len-1] == '\n') {
                    search_word[len-1] = '\0';
                }

                find_word_in_file(filename, search_word);
                break;
            }

            case '3':
                printf("새 파일명: ");
                fgets(filename, sizeof(filename), stdin);

                len = strlen(filename);
                if (len > 0 && filename[len-1] == '\n') {
                    filename[len-1] = '\0';
                }
                break;

            case '4':
                printf("프로그램을 종료합니다.\n");
                return;

            default:
                printf("잘못된 선택입니다.\n");
        }
    }
}
```

## 입출력 성능 최적화와 고급 기법

### 버퍼 크기 최적화

시스템 입출력의 성능은 버퍼 크기에 크게 의존합니다:

```c
#include <stdio.h>
#include <time.h>

void performance_test() {
    const char *test_file = "performance_test.txt";
    const int DATA_SIZE = 1000000;

    // 1. 문자 단위 출력 (느림)
    clock_t start = clock();
    FILE *file1 = fopen(test_file, "w");
    for (int i = 0; i < DATA_SIZE; i++) {
        fputc('A', file1);
    }
    fclose(file1);
    clock_t end = clock();
    printf("문자 단위: %.3f초\n",
           ((double)(end - start)) / CLOCKS_PER_SEC);

    // 2. 라인 단위 출력 (중간)
    start = clock();
    FILE *file2 = fopen(test_file, "w");
    for (int i = 0; i < DATA_SIZE / 1000; i++) {
        for (int j = 0; j < 1000; j++) {
            fputc('A', file2);
        }
        fputc('\n', file2);
    }
    fclose(file2);
    end = clock();
    printf("라인 단위: %.3f초\n",
           ((double)(end - start)) / CLOCKS_PER_SEC);

    // 3. 큰 블록 단위 출력 (빠름)
    start = clock();
    FILE *file3 = fopen(test_file, "w");
    char buffer[8192];
    memset(buffer, 'A', sizeof(buffer));
    for (int i = 0; i < DATA_SIZE / sizeof(buffer); i++) {
        fwrite(buffer, 1, sizeof(buffer), file3);
    }
    fclose(file3);
    end = clock();
    printf("블록 단위: %.3f초\n",
           ((double)(end - start)) / CLOCKS_PER_SEC);
}
```

### 이진 파일 입출력

텍스트가 아닌 이진 데이터를 다룰 때는 `fread()`와 `fwrite()`를 사용합니다:

```c
#include <stdio.h>
#include <stdint.h>

typedef struct {
    uint32_t id;
    char name[32];
    float salary;
    uint16_t department;
} Employee;

void save_employees_binary(Employee employees[], int count, const char *filename) {
    FILE *file = fopen(filename, "wb");  // 이진 쓰기 모드
    if (file == NULL) {
        perror("파일 열기 실패");
        return;
    }

    // 헤더 정보 쓰기
    uint32_t header = 0x454D504C;  // "EMPL" 매직 넘버
    fwrite(&header, sizeof(header), 1, file);
    fwrite(&count, sizeof(count), 1, file);

    // 직원 데이터 쓰기
    fwrite(employees, sizeof(Employee), count, file);

    fclose(file);
    printf("%d명의 직원 데이터를 저장했습니다.\n", count);
}

int load_employees_binary(Employee employees[], int max_count, const char *filename) {
    FILE *file = fopen(filename, "rb");  // 이진 읽기 모드
    if (file == NULL) {
        return -1;
    }

    // 헤더 검증
    uint32_t header;
    if (fread(&header, sizeof(header), 1, file) != 1 || header != 0x454D504C) {
        printf("잘못된 파일 형식입니다.\n");
        fclose(file);
        return -1;
    }

    int count;
    if (fread(&count, sizeof(count), 1, file) != 1) {
        printf("파일 읽기 오류\n");
        fclose(file);
        return -1;
    }

    if (count > max_count) {
        printf("데이터가 너무 많습니다. 최대 %d개만 로드합니다.\n", max_count);
        count = max_count;
    }

    // 직원 데이터 읽기
    int read_count = fread(employees, sizeof(Employee), count, file);
    fclose(file);

    printf("%d명의 직원 데이터를 로드했습니다.\n", read_count);
    return read_count;
}
```

### 메모리 매핑을 이용한 고성능 파일 처리

큰 파일을 처리할 때는 메모리 매핑이 효율적입니다 (POSIX 시스템):

```c
#ifdef __unix__
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

void process_large_file_mmap(const char *filename) {
    int fd = open(filename, O_RDONLY);
    if (fd == -1) {
        perror("파일 열기 실패");
        return;
    }

    struct stat sb;
    if (fstat(fd, &sb) == -1) {
        perror("파일 정보 가져오기 실패");
        close(fd);
        return;
    }

    // 파일을 메모리에 매핑
    char *mapped = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (mapped == MAP_FAILED) {
        perror("메모리 매핑 실패");
        close(fd);
        return;
    }

    // 메모리처럼 직접 접근하여 처리
    size_t line_count = 0;
    for (size_t i = 0; i < sb.st_size; i++) {
        if (mapped[i] == '\n') {
            line_count++;
        }
    }

    printf("총 줄 수: %zu\n", line_count);

    // 정리
    munmap(mapped, sb.st_size);
    close(fd);
}
#endif
```

## 마무리

입출력 함수는 C 프로그래밍에서 **외부 세계와 소통하는 핵심 도구**입니다. 단순한 텍스트 출력부터 복잡한 이진 파일 처리까지, 입출력 함수들의 특성을 정확히 이해하면 강력하고 효율적인 프로그램을 작성할 수 있습니다.

**핵심 포인트:**

1. **스트림과 버퍼링**을 이해하여 입출력 동작 원리 파악
2. **printf/scanf 형식 지정자**를 정확히 사용하여 데이터 형식화
3. **안전한 입력 함수** (`fgets`)를 사용하여 보안 취약점 방지
4. **적절한 함수 선택**으로 성능과 안전성 확보
5. **오류 처리**를 통한 견고한 프로그램 작성

**실용적 조언:**

- `gets()` 대신 `fgets()`를 사용하세요
- 항상 scanf의 반환값을 확인하세요
- 이진 데이터는 적절한 이진 모드로 처리하세요
- 큰 파일은 블록 단위로 처리하여 성능을 최적화하세요
- 플랫폼별 차이점을 고려한 이식 가능한 코드를 작성하세요

입출력 함수의 깊은 이해는 사용자 친화적이고 견고한 프로그램 작성의 기초가 되며, 파일 처리, 네트워크 프로그래밍, 시스템 프로그래밍으로의 발전을 위한 필수 지식입니다.