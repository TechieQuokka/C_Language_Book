# 2.2 자료형 (Data Type)

## 자료형이란 무엇인가?

자료형(Data Type)은 컴퓨터가 데이터를 이해하고 처리하는 방법을 정의하는 규칙입니다. 이는 단순히 "숫자"나 "문자"라는 추상적 개념을 넘어서, **컴퓨터의 메모리에서 비트 패턴을 어떻게 해석할 것인가**를 결정하는 핵심 메커니즘입니다.

### 자료형의 본질적 역할

자료형은 세 가지 핵심 정보를 컴파일러와 프로그래머에게 제공합니다:

1. **메모리 크기**: 이 데이터가 차지할 메모리 공간의 크기
2. **해석 방법**: 메모리의 비트 패턴을 어떤 값으로 해석할 것인가
3. **연산 규칙**: 이 데이터에 적용할 수 있는 연산의 종류

예를 들어, 메모리의 32비트가 `01000001001000000000000000000000`라는 패턴을 가지고 있다면:

- `int`로 해석하면: 1,090,519,040 (십진수)
- `float`로 해석하면: 10.0 (부동소수점)
- `char` 배열로 해석하면: 'A', '\002', '\000', '\000' (문자들)

같은 비트 패턴이지만 자료형에 따라 완전히 다른 의미를 갖는 것입니다.

## 이진수 시스템의 이해 (Binary System)

모든 자료형을 이해하기 위해서는 먼저 컴퓨터가 데이터를 저장하는 방식인 이진수 시스템을 깊이 이해해야 합니다.

### 이진수의 원리

컴퓨터는 전기적 신호를 이용해 동작하며, 전기가 흐르는 상태(1)와 흐르지 않는 상태(0)만을 구분할 수 있습니다. 이러한 물리적 제약으로 인해 컴퓨터는 모든 정보를 0과 1의 조합인 이진수로 표현합니다.

**이진수에서 십진수로의 변환**:

```
이진수 1101₂ = 1×2³ + 1×2² + 0×2¹ + 1×2⁰
             = 1×8 + 1×4 + 0×2 + 1×1
             = 8 + 4 + 0 + 1
             = 13₁₀
```

### 비트와 바이트의 관계

- **비트(Bit)**: Binary Digit의 줄임말, 0 또는 1의 값을 가지는 최소 정보 단위
- **바이트(Byte)**: 8개의 비트가 모인 것, 컴퓨터에서 주소를 지정할 수 있는 최소 메모리 단위
- **워드(Word)**: 프로세서가 한 번에 처리할 수 있는 비트 수 (32비트 시스템: 4바이트, 64비트 시스템: 8바이트)

### 이진수 표현의 한계와 범위

n비트로 표현할 수 있는 서로 다른 값의 개수는 2ⁿ개입니다:

- 1비트: 2¹ = 2개 (0, 1)
- 8비트: 2⁸ = 256개 (0 ~ 255)
- 16비트: 2¹⁶ = 65,536개
- 32비트: 2³² = 4,294,967,296개

이는 왜 8비트 `unsigned char`가 0~255의 범위를 가지는지, 32비트 `unsigned int`가 약 43억까지의 값을 표현할 수 있는지를 설명합니다.

### 위치 기수법과 가중치

이진수는 위치 기수법을 사용합니다. 각 자리수의 위치가 그 자리수의 가중치를 결정합니다:

```
8비트 이진수: b₇ b₆ b₅ b₄ b₃ b₂ b₁ b₀
가중치:      128 64 32 16  8  4  2  1
```

예시: `10110101₂`

```
= 1×128 + 0×64 + 1×32 + 1×16 + 0×8 + 1×4 + 0×2 + 1×1
= 128 + 0 + 32 + 16 + 0 + 4 + 0 + 1
= 181₁₀
```

## 부호가 있는 정수의 표현: 2의 보수 (Two's Complement)

컴퓨터에서 음수를 표현하는 방법은 여러 가지가 있지만, 현대의 모든 컴퓨터는 **2의 보수(Two's Complement)** 방식을 사용합니다.

### 2의 보수 방식이 필요한 이유

단순히 최상위 비트를 부호 비트로 사용하는 방법(부호-크기 표현)은 다음과 같은 문제가 있습니다:

- 0을 두 가지 방법(+0, -0)으로 표현
- 덧셈과 뺄셈에 서로 다른 회로 필요
- 비교 연산의 복잡성

### 2의 보수의 원리

2의 보수는 다음과 같이 정의됩니다:
어떤 수 A의 2의 보수 = 2ⁿ - A (n은 비트 수)

실제 계산 방법:

1. **1의 보수**: 모든 비트를 반전 (0→1, 1→0)
2. **2의 보수**: 1의 보수에 1을 더함

**예시: 8비트에서 -5 표현**

```
1. +5의 이진 표현:     00000101
2. 1의 보수 (비트 반전): 11111010
3. 2의 보수 (1 더하기):  11111011
따라서 -5 = 11111011₂
```

### 2의 보수의 특성과 장점

**1. 유일한 0 표현**

```
+0 = 00000000
-0을 만들려면: 00000000 → 11111111 → 00000000 (오버플로우로 인해 +0과 동일)
```

**2. 자연스러운 산술 연산**

```
5 + (-5) = 00000101 + 11111011 = 100000000
(9비트 결과에서 최상위 비트 버림) = 00000000 = 0
```

**3. 범위의 비대칭성**
n비트 2의 보수에서:

- 최댓값: +2ⁿ⁻¹ - 1
- 최솟값: -2ⁿ⁻¹

8비트의 경우: -128 ~ +127 (음수가 하나 더 많음)

이는 -128의 2의 보수를 만들면 다시 -128이 되는 특이한 성질을 만듭니다:

```
-128 = 10000000
1의 보수: 01111111
2의 보수: 10000000 (원래와 동일)
```

### 2의 보수와 하드웨어 설계

2의 보수 방식을 사용하면:

- 덧셈과 뺄셈을 동일한 회로로 처리 가능 (뺄셈 = 2의 보수 덧셈)
- 비교 연산이 간단 (단순 이진 비교)
- 곱셈과 나눗셈 알고리즘이 일관됨

## 부동소수점 표현: IEEE 754 표준

실수를 컴퓨터에서 표현하는 것은 정수보다 훨씬 복잡합니다. 실수는 무한히 많지만, 컴퓨터의 메모리는 유한하기 때문입니다.

### 부동소수점의 개념

부동소수점(Floating Point)은 과학적 표기법의 이진 버전입니다:

```
과학적 표기법: 3.14159 × 10²
부동소수점:   1.11001... × 2¹
```

"부동(floating)"이라는 용어는 소수점의 위치가 고정되지 않고 움직인다는 의미입니다.

### IEEE 754 표준의 구조

IEEE 754는 1985년에 제정된 부동소수점 산술 표준으로, 현재 거의 모든 컴퓨터에서 사용됩니다.

**32비트 단정밀도 (float) 구조:**

```
31    30-23    22-0
[S] [Exponent] [Fraction]
 1비트  8비트    23비트
```

- **부호 비트 (S)**: 0 = 양수, 1 = 음수
- **지수 부 (Exponent)**: 8비트, 바이어스 127 적용
- **가수 부 (Fraction)**: 23비트, 정규화된 가수의 소수 부분

### IEEE 754의 표현 방법

실제 값 = (-1)ˢ × (1 + fraction) × 2^(exponent - 127)

**예시: 3.14를 IEEE 754로 표현**

1. **이진 변환**: 3.14 ≈ 11.001000111...₂
2. **정규화**: 1.1001000111... × 2¹
3. **지수**: 1 + 127 = 128 = 10000000₂
4. **가수**: 1001000111... (앞의 1은 생략)
5. **결과**: 0 10000000 10010001011101001111111

### 특수 값들

IEEE 754는 몇 가지 특수 값을 정의합니다:

**1. 정규화된 수 (Normalized Numbers)**

- 지수: 1 ~ 254
- 가수 앞에 암시적 1이 있음

**2. 비정규화된 수 (Denormalized Numbers)**

- 지수: 0
- 가수 앞에 암시적 0이 있음
- 0에 가까운 매우 작은 수 표현

**3. 무한대 (Infinity)**

- 지수: 255 (모든 비트 1)
- 가수: 0 (모든 비트 0)
- 양의 무한대: 부호 비트 0
- 음의 무한대: 부호 비트 1

**4. NaN (Not a Number)**

- 지수: 255 (모든 비트 1)
- 가수: 0이 아닌 값
- 정의되지 않은 연산의 결과 (0/0, ∞-∞ 등)

### IEEE 754의 한계와 정밀도

부동소수점 표현의 근본적 한계:

**1. 정밀도 손실**
10진수 0.1은 이진수로 정확히 표현할 수 없습니다:

```
0.1₁₀ = 0.000110011001100...₂ (무한 반복)
```

**2. 반올림 오차**
유한한 비트로는 모든 실수를 정확히 표현할 수 없어 반올림이 발생합니다.

**3. 범위의 제한**
32비트 float:

- 가장 작은 양수: 약 1.4 × 10⁻⁴⁵
- 가장 큰 양수: 약 3.4 × 10³⁸

## C언어의 자료형 체계

C언어의 자료형은 크게 **기본형(Primitive Types)**과 **파생형(Derived Types)**으로 나뉩니다.

### 기본형 자료형 분류

```
C언어 기본 자료형
├── 정수형 (Integer Types)
│   ├── char (1바이트)
│   ├── short (2바이트)
│   ├── int (일반적으로 4바이트)
│   ├── long (플랫폼 의존적)
│   └── long long (8바이트)
├── 실수형 (Floating-point Types)
│   ├── float (4바이트)
│   ├── double (8바이트)
│   └── long double (플랫폼 의존적)
└── void (특수 타입)
```

### 정수형 자료형들

**1. char (1바이트)**

- **크기**: 1바이트 (8비트)
- **범위**: -128 ~ 127 (signed) 또는 0 ~ 255 (unsigned)
- **용도**: 문자 저장이 주목적이지만 실제로는 가장 작은 정수형
- **특징**: ASCII 문자 코드와 밀접한 관련

**2. short (2바이트)**

- **크기**: 2바이트 (16비트)
- **범위**: -32,768 ~ 32,767 (signed) 또는 0 ~ 65,535 (unsigned)
- **용도**: 16비트 시대의 기본 정수형, 현재는 메모리 절약이 필요한 경우
- **특징**: int보다 작거나 같은 크기 보장

**3. int (일반적으로 4바이트)**

- **크기**: 플랫폼에 따라 다름 (현재 대부분 4바이트)
- **범위**: 약 -21억 ~ +21억 (32비트 기준)
- **용도**: C언어의 기본 정수형, 가장 자연스럽고 효율적
- **특징**: 프로세서의 워드 크기와 연관

**4. long (플랫폼 의존적)**

- **크기**: 32비트 시스템에서 4바이트, 64비트 시스템에서 4바이트(Windows) 또는 8바이트(Unix/Linux)
- **범위**: 플랫폼에 따라 int와 같거나 더 큼
- **용도**: 큰 정수값이 필요한 경우, 시간 값, 파일 크기 등
- **특징**: 플랫폼별 호환성 문제 주의 필요

**5. long long (8바이트)**

- **크기**: 8바이트 (64비트)
- **범위**: 약 -922경 ~ +922경
- **용도**: 매우 큰 정수 계산, 64비트 시간 값 등
- **특징**: C99 표준에서 도입, 모든 플랫폼에서 최소 64비트 보장

### 부동소수점 자료형들

**1. float (4바이트)**

- **크기**: 4바이트 (32비트)
- **정밀도**: 약 6-7자리 십진수
- **범위**: 약 ±3.4 × 10³⁸
- **용도**: 메모리 절약이 중요한 그래픽, 게임 분야
- **특징**: IEEE 754 단정밀도 표준

**2. double (8바이트)**

- **크기**: 8바이트 (64비트)
- **정밀도**: 약 15-16자리 십진수
- **범위**: 약 ±1.7 × 10³⁰⁸
- **용도**: C언어에서 실수 연산의 기본형
- **특징**: IEEE 754 배정밀도 표준, 일반적으로 권장

**3. long double (플랫폼 의존적)**

- **크기**: 8, 12, 또는 16바이트 (플랫폼에 따라)
- **정밀도**: 플랫폼에 따라 다름 (일반적으로 18-19자리)
- **범위**: double보다 크거나 같음
- **용도**: 최고 정밀도가 필요한 과학 계산
- **특징**: 확장 정밀도, 이식성에 주의

### void형의 특별한 의미

`void`는 "값이 없음"을 나타내는 특수한 자료형입니다:

- **함수 반환형**: 반환 값이 없는 함수
- **함수 매개변수**: 매개변수가 없는 함수
- **포인터**: 타입이 정해지지 않은 메모리 주소

`void*`는 모든 포인터 타입으로 변환 가능한 범용 포인터로, C언어의 제네릭 프로그래밍에서 핵심적인 역할을 합니다.

## 자료형 수정자 (Type Modifiers)

### signed와 unsigned

**signed (기본값)**

- 부호 있는 정수 (양수, 0, 음수)
- 최상위 비트를 부호 비트로 사용
- 2의 보수 방식으로 음수 표현

**unsigned**

- 부호 없는 정수 (0과 양수만)
- 모든 비트를 값 표현에 사용
- 같은 비트 수로 2배 큰 양수 표현 가능

### short와 long

**short**

- 자료형의 크기를 줄임
- 메모리 절약이 중요한 경우

**long**

- 자료형의 크기를 늘림
- 더 큰 범위가 필요한 경우

**long long**

- 가장 큰 정수 자료형
- C99 표준에서 도입
- 64비트 보장

## 자료형의 크기 보장과 제한

### C 표준의 크기 보장

C 표준은 자료형들 간의 **상대적 크기 관계**만 보장합니다:

```
sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)
sizeof(float) ≤ sizeof(double) ≤ sizeof(long double)
```

**최소 크기 보장:**

- char: 최소 8비트
- short: 최소 16비트
- int: 최소 16비트
- long: 최소 32비트
- long long: 최소 64비트

### 플랫폼별 차이점

**32비트 시스템 (일반적)**

- char: 1바이트, short: 2바이트, int: 4바이트, long: 4바이트

**64비트 Windows (LLP64 모델)**

- char: 1바이트, short: 2바이트, int: 4바이트, long: 4바이트, long long: 8바이트

**64비트 Unix/Linux (LP64 모델)**

- char: 1바이트, short: 2바이트, int: 4바이트, long: 8바이트, long long: 8바이트

### 이식성을 위한 고정 크기 타입

크기가 정확해야 하는 경우 `stdint.h` 헤더의 고정 크기 타입을 사용합니다:

**정확한 크기 타입:**

- `int8_t`, `int16_t`, `int32_t`, `int64_t` (signed)
- `uint8_t`, `uint16_t`, `uint32_t`, `uint64_t` (unsigned)

**최소 크기 타입:**

- `int_least8_t`, `int_least16_t`, `int_least32_t`, `int_least64_t`

**최고 성능 타입:**

- `int_fast8_t`, `int_fast16_t`, `int_fast32_t`, `int_fast64_t`

## 자료형과 메모리 효율성

### 메모리 정렬 (Memory Alignment)

현대 프로세서는 효율적인 메모리 접근을 위해 데이터를 특정 주소 경계에 정렬합니다:

- **1바이트 데이터**: 어떤 주소든 가능
- **2바이트 데이터**: 2의 배수 주소
- **4바이트 데이터**: 4의 배수 주소
- **8바이트 데이터**: 8의 배수 주소

정렬되지 않은 접근은 성능 저하나 오류를 발생시킬 수 있습니다.

### 구조체 패딩

컴파일러는 구조체 멤버들을 정렬하기 위해 빈 공간(패딩)을 삽입합니다:

```c
struct Example {
    char c;     // 1바이트
    // 3바이트 패딩
    int i;      // 4바이트
    short s;    // 2바이트
    // 2바이트 패딩 (전체 크기를 4의 배수로)
};
// 총 크기: 12바이트 (실제 데이터는 7바이트)
```

메모리 효율을 위해서는 큰 타입부터 작은 타입 순으로 배치하는 것이 좋습니다.

### 바이트 순서 (Endianness)

다중 바이트 데이터를 메모리에 저장하는 순서:

**Little Endian** (Intel x86, ARM 등):

- 최하위 바이트를 낮은 주소에 저장
- 0x12345678 → [78][56][34][12]

**Big Endian** (네트워크, 일부 RISC):

- 최상위 바이트를 낮은 주소에 저장
- 0x12345678 → [12][34][56][78]

네트워크 프로그래밍에서는 바이트 순서 변환이 중요합니다.

## 자료형 변환

### 자동 형 변환 (Implicit Conversion)

C언어는 다음 상황에서 자동으로 형 변환을 수행합니다:

**1. 대입 시 변환**

```c
int i = 3.14;  // double → int (소수 부분 절삭)
float f = 100; // int → float
```

**2. 산술 연산 시 변환**
일반적인 산술 변환 규칙:

- 두 피연산자가 같은 타입이면 변환 없음
- 그렇지 않으면 더 넓은 타입으로 변환
- 변환 순서: char/short → int → long → long long → float → double → long double

**3. 함수 호출 시 변환**
매개변수 타입에 맞춰 인수가 자동 변환됩니다.

### 명시적 형 변환 (Cast)

프로그래머가 직접 타입을 변환하는 것:

```c
int i = (int)3.14;          // double을 int로 변환
void *ptr = malloc(100);
int *iptr = (int*)ptr;      // void*를 int*로 변환
```

### 형 변환 시 주의사항

**1. 정밀도 손실**

- 큰 타입에서 작은 타입으로 변환 시 데이터 손실 가능
- 실수에서 정수로 변환 시 소수 부분 제거

**2. 오버플로우**

- 타입의 범위를 벗어나는 값 할당 시 예상치 못한 결과

**3. 부호 변환**

- signed와 unsigned 간 변환 시 비트 패턴은 동일하지만 해석이 달라짐

## 자료형 선택 가이드

### 일반적인 선택 기준

**1. 기본 선택**

- **정수**: `int` (일반적인 용도)
- **실수**: `double` (충분한 정밀도)
- **문자**: `char` (ASCII 문자)
- **불린**: `int` 또는 `_Bool` (C99)

**2. 특수한 경우**

- **메모리가 중요한 경우**: 더 작은 타입 (`char`, `short`)
- **큰 범위가 필요한 경우**: `long long`, `double`
- **최고 정밀도가 필요한 경우**: `long double`
- **크기가 정확해야 하는 경우**: `stdint.h` 타입들

**3. 성능 고려사항**

- `int`는 일반적으로 가장 빠른 정수 연산
- `double`은 `float`보다 정밀하지만 메모리를 2배 사용
- 정렬된 데이터 접근이 비정렬 접근보다 빠름

### 현대적 관점에서의 권장사항

**1. 이식성이 중요한 경우**

- `stdint.h`의 고정 크기 타입 사용
- 플랫폼별 차이를 고려한 코드 작성

**2. 일반적인 애플리케이션**

- `int`, `double` 위주 사용
- 메모리 사용량보다 개발 편의성 우선

**3. 시스템 프로그래밍**

- 플랫폼 특성을 정확히 파악
- 포인터 크기와 정수 타입의 관계 이해

**4. 임베디드 시스템**

- 메모리 효율성을 최우선 고려
- 필요한 최소 크기의 타입 선택

## 마무리

자료형은 C언어에서 가장 기본적이면서도 중요한 개념입니다. 단순히 "숫자를 저장하는 것"이 아니라, **컴퓨터가 데이터를 이해하고 처리하는 방식을 정의하는 핵심 메커니즘**입니다.

**핵심 포인트:**

1. **이진수 시스템의 이해**는 모든 자료형의 기초입니다
2. **2의 보수**는 음수 표현의 표준이며 하드웨어 설계와 밀접합니다
3. **IEEE 754**는 부동소수점의 표준이지만 정밀도 한계가 있습니다
4. **자료형 선택**은 메모리 효율성, 성능, 이식성을 종합적으로 고려해야 합니다
5. **플랫폼별 차이**를 이해하고 적절한 대응이 필요합니다

이러한 하위 레벨의 개념들을 이해하면:

- 자료형의 한계와 특성을 정확히 알 수 있습니다
- 예상치 못한 버그를 예방할 수 있습니다
- 더 효율적이고 안정적인 프로그램을 작성할 수 있습니다

자료형에 대한 깊은 이해는 C언어 마스터의 첫 걸음이자, 견고한 프로그래밍 실력의 토대가 됩니다.
