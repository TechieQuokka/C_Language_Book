# 2.2 자료형 (기본형, 파생형)

자료형(Data Type)은 변수가 저장할 수 있는 데이터의 종류와 크기를 정의합니다. C언어는 정적 타입 언어로, 변수 선언 시 반드시 자료형을 명시해야 합니다. 자료형은 컴퓨터가 메모리에서 데이터를 어떻게 해석하고 처리할지를 결정하는 핵심 요소입니다.

## C언어에서 자료형의 의미와 중요성

### 1. 메모리 할당과 관리
자료형은 변수가 차지할 메모리 공간의 크기를 결정합니다. 컴파일러는 자료형 정보를 바탕으로 적절한 크기의 메모리를 할당하고, 이 메모리에 저장된 비트 패턴을 올바른 값으로 해석합니다.

### 2. 연산 규칙 정의
자료형은 해당 데이터에 수행할 수 있는 연산의 종류와 방법을 정의합니다. 예를 들어, 정수형과 실수형은 서로 다른 산술 연산 규칙을 가집니다.

### 3. 타입 안전성 보장
컴파일 시점에 타입 검사를 통해 잘못된 연산이나 할당을 방지하여 프로그램의 안정성을 높입니다.

### 4. 성능 최적화
자료형 정보를 통해 컴파일러는 최적화된 기계어 코드를 생성할 수 있습니다.

## C언어 자료형 분류

```
C언어 자료형
├── 기본형 (Basic Types)
│   ├── 정수형 (Integer Types)
│   │   ├── char
│   │   ├── short (short int)
│   │   ├── int
│   │   ├── long (long int)
│   │   └── long long (long long int)
│   ├── 실수형 (Floating-point Types)
│   │   ├── float
│   │   ├── double
│   │   └── long double
│   └── void
└── 파생형 (Derived Types)
    ├── 배열 (Array)
    ├── 포인터 (Pointer)
    ├── 구조체 (Structure)
    ├── 공용체 (Union)
    ├── 열거형 (Enumeration)
    └── 함수 (Function)
```

## 기본형 (Basic Types)

### 정수형 (Integer Types)

#### char 형

```c
#include <stdio.h>
#include <limits.h>

int main() {
    char ch1 = 'A';
    char ch2 = 65;          // 'A'의 ASCII 코드
    char ch3 = -128;        // 최솟값
    char ch4 = 127;         // 최댓값

    printf("char 크기: %zu bytes\n", sizeof(char));
    printf("char 범위: %d ~ %d\n", CHAR_MIN, CHAR_MAX);
    printf("ch1: %c (%d)\n", ch1, ch1);
    printf("ch2: %c (%d)\n", ch2, ch2);
    printf("ch3: %d\n", ch3);
    printf("ch4: %d\n", ch4);

    // unsigned char
    unsigned char uch = 255;
    printf("unsigned char 최댓값: %d\n", uch);

    return 0;
}
```

**특징:**
- 크기: 1바이트 (8비트)
- 범위: -128 ~ 127 (signed), 0 ~ 255 (unsigned)
- 문자와 작은 정수 저장

#### short 형

```c
#include <stdio.h>
#include <limits.h>

int main() {
    short s1 = 32767;       // 최댓값
    short s2 = -32768;      // 최솟값
    unsigned short us = 65535;

    printf("short 크기: %zu bytes\n", sizeof(short));
    printf("short 범위: %d ~ %d\n", SHRT_MIN, SHRT_MAX);
    printf("s1: %d\n", s1);
    printf("s2: %d\n", s2);
    printf("unsigned short 최댓값: %u\n", us);

    return 0;
}
```

**특징:**
- 크기: 2바이트 (16비트)
- 범위: -32,768 ~ 32,767 (signed), 0 ~ 65,535 (unsigned)
- int보다 작은 정수

#### int 형

```c
#include <stdio.h>
#include <limits.h>

int main() {
    int i1 = 2147483647;    // 최댓값
    int i2 = -2147483648;   // 최솟값
    unsigned int ui = 4294967295U;

    printf("int 크기: %zu bytes\n", sizeof(int));
    printf("int 범위: %d ~ %d\n", INT_MIN, INT_MAX);
    printf("i1: %d\n", i1);
    printf("i2: %d\n", i2);
    printf("unsigned int 최댓값: %u\n", ui);

    return 0;
}
```

**특징:**
- 크기: 4바이트 (32비트, 대부분의 현대 시스템)
- 범위: -2,147,483,648 ~ 2,147,483,647 (signed)
- 가장 일반적으로 사용되는 정수형

#### long 형

```c
#include <stdio.h>
#include <limits.h>

int main() {
    long l1 = 2147483647L;      // 플랫폼에 따라 다름
    long l2 = -2147483648L;
    unsigned long ul = 4294967295UL;

    printf("long 크기: %zu bytes\n", sizeof(long));
    printf("long 범위: %ld ~ %ld\n", LONG_MIN, LONG_MAX);
    printf("l1: %ld\n", l1);
    printf("l2: %ld\n", l2);
    printf("unsigned long 최댓값: %lu\n", ul);

    return 0;
}
```

**특징:**
- 크기: 4바이트 (32비트 시스템) 또는 8바이트 (64비트 시스템)
- 범위: 플랫폼에 따라 int와 같거나 더 큼
- 최소 32비트 보장

**상세 분석 및 활용:**

**1. 플랫폼 진화의 산물**
`long`은 과거 16비트 시스템에서 32비트 정수를 표현하기 위해 도입되었으나, 현재는 플랫폼별로 다른 크기를 가집니다.

```c
#include <stdio.h>
#include <limits.h>

int main() {
    printf("=== long형 플랫폼별 차이 ===\n");
    printf("long 크기: %zu bytes\n", sizeof(long));
    printf("long 범위: %ld ~ %ld\n", LONG_MIN, LONG_MAX);

    // Windows 64bit: long은 여전히 32비트
    // Linux/Unix 64bit: long은 64비트

    if (sizeof(long) == sizeof(int)) {
        printf("이 시스템에서 long과 int는 같은 크기입니다.\n");
    } else {
        printf("이 시스템에서 long이 int보다 큽니다.\n");
    }

    return 0;
}
```

**2. 시간과 날짜 처리의 전통적 선택**
유닉스 타임스탬프, 파일 크기 등 큰 수를 다룰 때 전통적으로 사용되었습니다.

```c
#include <stdio.h>
#include <time.h>

int main() {
    // 유닉스 타임스탬프 (1970년 1월 1일부터 초 단위)
    long timestamp = time(NULL);
    printf("현재 타임스탬프: %ld\n", timestamp);

    // 큰 파일 크기 처리
    long file_size = 2147483648L;  // 2GB
    printf("파일 크기: %ld bytes\n", file_size);

    // 날짜 계산
    long seconds_per_day = 24L * 60L * 60L;  // 24시간 * 60분 * 60초
    long days = timestamp / seconds_per_day;
    printf("1970년 1월 1일부터 %ld일이 지났습니다.\n", days);

    return 0;
}
```

**3. 포인터 산술과의 관계**
64비트 시스템에서 포인터와 `long`의 크기가 같아 포인터를 정수로 변환할 때 사용됩니다.

```c
#include <stdio.h>
#include <stdint.h>

int main() {
    int value = 42;
    int *ptr = &value;

    // 포인터를 정수로 변환 (64비트 시스템에서)
    if (sizeof(long) == sizeof(void*)) {
        long addr = (long)ptr;
        printf("포인터 주소 (long): 0x%lx\n", addr);
    }

    // 더 안전한 방법 (C99 이후)
    uintptr_t safe_addr = (uintptr_t)ptr;
    printf("포인터 주소 (uintptr_t): 0x%lx\n", safe_addr);

    return 0;
}
```

**4. 이식성 문제와 해결책**
`long`의 크기가 플랫폼마다 다르므로 이식성 있는 코드 작성에 주의가 필요합니다.

```c
#include <stdio.h>
#include <stdint.h>

int main() {
    // 문제가 될 수 있는 코드
    long data = 0x123456789ABCDEF0L;  // 64비트 값

    if (sizeof(long) < 8) {
        printf("경고: 이 시스템에서 long은 64비트 값을 저장할 수 없습니다!\n");
    }

    // 이식성 있는 해결책
    int64_t portable_data = 0x123456789ABCDEF0LL;
    printf("이식성 있는 64비트 값: 0x%016llx\n", portable_data);

    return 0;
}
```

#### long long 형

```c
#include <stdio.h>
#include <limits.h>

int main() {
    long long ll1 = 9223372036854775807LL;      // 최댓값
    long long ll2 = -9223372036854775808LL;     // 최솟값
    unsigned long long ull = 18446744073709551615ULL;

    printf("long long 크기: %zu bytes\n", sizeof(long long));
    printf("long long 범위: %lld ~ %lld\n", LLONG_MIN, LLONG_MAX);
    printf("ll1: %lld\n", ll1);
    printf("ll2: %lld\n", ll2);
    printf("unsigned long long 최댓값: %llu\n", ull);

    return 0;
}
```

**특징:**
- 크기: 8바이트 (64비트)
- 범위: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (signed)
- C99 표준에서 도입
- 가장 큰 정수 자료형

#### 정수형 크기와 바이너리 표현

```c
#include <stdio.h>
#include <limits.h>

int main() {
    printf("=== 정수형 크기와 범위 비교 ===\n");
    printf("자료형        크기    범위 (signed)\n");
    printf("-----------------------------------------\n");
    printf("char:      %zu bytes  %d ~ %d\n", sizeof(char), CHAR_MIN, CHAR_MAX);
    printf("short:     %zu bytes  %d ~ %d\n", sizeof(short), SHRT_MIN, SHRT_MAX);
    printf("int:       %zu bytes  %d ~ %d\n", sizeof(int), INT_MIN, INT_MAX);
    printf("long:      %zu bytes  %ld ~ %ld\n", sizeof(long), LONG_MIN, LONG_MAX);
    printf("long long: %zu bytes  %lld ~ %lld\n", sizeof(long long), LLONG_MIN, LLONG_MAX);

    printf("\n=== 크기 관계 ===\n");
    printf("sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)\n");
    printf("%zu <= %zu <= %zu <= %zu <= %zu\n",
           sizeof(char), sizeof(short), sizeof(int), sizeof(long), sizeof(long long));

    return 0;
}
```

## 자료형과 바이너리의 관계 - 컴퓨터 과학의 핵심

### 정수의 바이너리 표현과 해석

```c
#include <stdio.h>

// 향상된 바이너리 출력 함수
void printBinary(unsigned int n, int bits) {
    for (int i = bits - 1; i >= 0; i--) {
        printf("%d", (n >> i) & 1);
        if (i % 4 == 0 && i != 0) printf(" ");  // 4비트마다 공백
    }
    printf("\n");
}

// 바이너리 패턴 분석 함수
void analyzeBinaryPattern(int value, const char* description) {
    printf("\n=== %s ===\n", description);
    printf("10진수: %d\n", value);
    printf("2진수:  ");
    printBinary((unsigned int)value, 32);
    printf("16진수: 0x%08X\n", (unsigned int)value);

    // 각 바이트별로 분석
    unsigned char* bytes = (unsigned char*)&value;
    printf("바이트별: ");
    for (int i = sizeof(int) - 1; i >= 0; i--) {
        printf("0x%02X ", bytes[i]);
    }
    printf("\n");
}

int main() {
    printf("=== 정수의 바이너리 표현 심화 분석 ===\n");

    // 다양한 정수값들의 바이너리 표현
    analyzeBinaryPattern(0, "영(0)의 표현");
    analyzeBinaryPattern(1, "1의 표현");
    analyzeBinaryPattern(255, "8비트 최댓값 (2^8-1)");
    analyzeBinaryPattern(256, "2^8");
    analyzeBinaryPattern(65535, "16비트 최댓값 (2^16-1)");
    analyzeBinaryPattern(65536, "2^16");
    analyzeBinaryPattern(-1, "음수 -1 (모든 비트가 1)");
    analyzeBinaryPattern(-128, "char 최솟값");
    analyzeBinaryPattern(127, "char 최댓값");

    return 0;
}
```

**심층 분석:**

**1. 비트 패턴의 의미**
- 같은 비트 패턴이라도 자료형에 따라 다른 값으로 해석됩니다
- `10000000` (8비트)은 unsigned char에서는 128, signed char에서는 -128입니다
- 이는 최상위 비트(MSB)가 부호 비트로 사용되기 때문입니다

**2. 2의 거듭제곱과 컴퓨터**
```c
#include <stdio.h>

int main() {
    printf("=== 2의 거듭제곱이 중요한 이유 ===\n");

    for (int i = 0; i <= 16; i++) {
        unsigned int power = 1U << i;  // 2^i
        printf("2^%2d = %10u (0x%08X)\n", i, power, power);

        // 실생활에서의 의미
        if (i == 8) printf("     → 1바이트가 표현할 수 있는 값의 수\n");
        if (i == 10) printf("     → 1KB (1024 bytes)\n");
        if (i == 16) printf("     → 16비트 시스템의 주소 공간\n");
    }

    return 0;
}
```

**3. 바이트 순서(Endianness)의 실제 영향**
```c
#include <stdio.h>
#include <stdint.h>

void demonstrateEndianness() {
    uint32_t test_value = 0x12345678;
    uint8_t *bytes = (uint8_t*)&test_value;

    printf("=== 바이트 순서의 실제 확인 ===\n");
    printf("32비트 값: 0x%08X\n", test_value);
    printf("메모리 배치:\n");

    for (int i = 0; i < 4; i++) {
        printf("  주소 +%d: 0x%02X\n", i, bytes[i]);
    }

    if (bytes[0] == 0x78) {
        printf("→ Little Endian 시스템 (Intel x86, ARM 등)\n");
        printf("  최하위 바이트가 낮은 주소에 저장\n");
    } else if (bytes[0] == 0x12) {
        printf("→ Big Endian 시스템 (일부 RISC, 네트워크 바이트 순서)\n");
        printf("  최상위 바이트가 낮은 주소에 저장\n");
    }

    // 네트워크 프로그래밍에서의 영향
    printf("\n네트워크 전송 시 주의사항:\n");
    printf("  - 네트워크는 Big Endian 사용\n");
    printf("  - htonl(), ntohl() 함수로 변환 필요\n");
}

int main() {
    demonstrateEndianness();
    return 0;
}
```

### 2의 보수 (Two's Complement) 이해

```c
#include <stdio.h>

void printBinary8(char n) {
    for (int i = 7; i >= 0; i--) {
        printf("%d", (n >> i) & 1);
    }
}

int main() {
    printf("=== 2의 보수 표현 ===\n");

    char positive = 5;
    char negative = -5;

    printf("양수 5:  ");
    printBinary8(positive);
    printf(" = %d\n", positive);

    printf("음수 -5: ");
    printBinary8(negative);
    printf(" = %d\n", negative);

    // 2의 보수 계산 과정
    printf("\n=== 2의 보수 계산 과정 ===\n");
    printf("1. 원래 수:     00000101 (5)\n");
    printf("2. 1의 보수:    11111010 (비트 반전)\n");
    printf("3. 2의 보수:    11111011 (1 더하기) = -5\n");

    // 부호 없는 타입에서의 해석
    unsigned char u_negative = (unsigned char)negative;
    printf("\n같은 비트를 unsigned로 해석: %u\n", u_negative);

    return 0;
}
```

### 부동소수점의 바이너리 표현 (IEEE 754)

```c
#include <stdio.h>
#include <string.h>

typedef union {
    float f;
    unsigned int i;
} FloatUnion;

void printFloatBinary(float f) {
    FloatUnion fu;
    fu.f = f;

    unsigned int bits = fu.i;

    // 부호 비트 (1비트)
    printf("부호: %d\n", (bits >> 31) & 1);

    // 지수 비트 (8비트)
    printf("지수: ");
    for (int i = 30; i >= 23; i--) {
        printf("%d", (bits >> i) & 1);
    }
    printf(" (bias 127)\n");

    // 가수 비트 (23비트)
    printf("가수: ");
    for (int i = 22; i >= 0; i--) {
        printf("%d", (bits >> i) & 1);
        if (i % 4 == 0 && i != 0) printf(" ");
    }
    printf("\n");

    // 전체 32비트
    printf("전체: ");
    for (int i = 31; i >= 0; i--) {
        printf("%d", (bits >> i) & 1);
        if (i == 31 || i == 23) printf(" ");  // 구분자
    }
    printf("\n");
}

int main() {
    printf("=== float의 IEEE 754 표현 ===\n");

    float values[] = {1.0f, -1.0f, 0.5f, 3.14159f};

    for (int i = 0; i < 4; i++) {
        printf("\n%.5f:\n", values[i]);
        printFloatBinary(values[i]);
    }

    return 0;
}
```

### 실수형 (Floating-point Types)

#### float 형

```c
#include <stdio.h>
#include <float.h>

int main() {
    float f1 = 3.14159f;
    float f2 = 1.23e4f;     // 과학적 표기법
    float f3 = 5.67e-3f;

    printf("float 크기: %zu bytes\n", sizeof(float));
    printf("float 정밀도: %d digits\n", FLT_DIG);
    printf("float 범위: %e ~ %e\n", FLT_MIN, FLT_MAX);

    printf("f1: %f\n", f1);
    printf("f1 (과학적): %e\n", f1);
    printf("f1 (간략): %g\n", f1);
    printf("f2: %.2f\n", f2);
    printf("f3: %.5f\n", f3);

    return 0;
}
```

**특징:**
- 크기: 4바이트 (32비트)
- 정밀도: 약 6-7자리 십진수
- 범위: 약 ±3.4 × 10^38
- IEEE 754 단정밀도 부동소수점 형식

#### double 형

```c
#include <stdio.h>
#include <float.h>

int main() {
    double d1 = 3.141592653589793;
    double d2 = 1.23456789e10;

    printf("double 크기: %zu bytes\n", sizeof(double));
    printf("double 정밀도: %d digits\n", DBL_DIG);
    printf("double 범위: %e ~ %e\n", DBL_MIN, DBL_MAX);

    printf("d1: %.15f\n", d1);
    printf("d1 (과학적): %.15e\n", d1);
    printf("d2: %.2f\n", d2);

    // float vs double 정밀도 비교
    float f = 3.141592653589793f;
    printf("\n=== 정밀도 비교 ===\n");
    printf("float:  %.15f\n", f);
    printf("double: %.15f\n", d1);

    return 0;
}
```

**특징:**
- 크기: 8바이트 (64비트)
- 정밀도: 약 15-16자리 십진수
- 범위: 약 ±1.7 × 10^308
- IEEE 754 배정밀도 부동소수점 형식

#### long double 형

```c
#include <stdio.h>
#include <float.h>

int main() {
    long double ld = 3.141592653589793238L;

    printf("long double 크기: %zu bytes\n", sizeof(long double));
    printf("long double 정밀도: %d digits\n", LDBL_DIG);
    printf("long double 범위: %Le ~ %Le\n", LDBL_MIN, LDBL_MAX);
    printf("ld: %.18Lf\n", ld);

    return 0;
}
```

**특징:**
- 크기: 8바이트, 12바이트, 또는 16바이트 (플랫폼 의존적)
- 정밀도: 플랫폼에 따라 다름 (일반적으로 18-19자리)
- 범위: double보다 크거나 같음
- 확장 정밀도 부동소수점 형식

### 실수형 크기와 정밀도 비교

```c
#include <stdio.h>
#include <float.h>

int main() {
    printf("=== 실수형 크기와 정밀도 비교 ===\n");
    printf("자료형        크기      정밀도(자릿수)    범위\n");
    printf("--------------------------------------------------------\n");
    printf("float      %zu bytes     %d digits      %e ~ %e\n",
           sizeof(float), FLT_DIG, FLT_MIN, FLT_MAX);
    printf("double     %zu bytes     %d digits      %e ~ %e\n",
           sizeof(double), DBL_DIG, DBL_MIN, DBL_MAX);
    printf("long double %zu bytes    %d digits      %Le ~ %Le\n",
           sizeof(long double), LDBL_DIG, LDBL_MIN, LDBL_MAX);

    return 0;
}
```

#### 실수형 정밀도 테스트

```c
#include <stdio.h>

int main() {
    printf("=== 실수형 정밀도 테스트 ===\n");

    float f = 0.1f + 0.2f;
    double d = 0.1 + 0.2;
    long double ld = 0.1L + 0.2L;

    printf("float:       %.20f\n", f);
    printf("double:      %.20f\n", d);
    printf("long double: %.20Lf\n", ld);
    printf("실제 값:      0.30000000000000000000\n");

    // 부동소수점 연산의 한계
    if (f == 0.3f) {
        printf("float: 0.1 + 0.2 == 0.3\n");
    } else {
        printf("float: 0.1 + 0.2 != 0.3 (부동소수점 오차)\n");
    }

    return 0;
}
```

### void 형 - 타입 시스템의 특별한 존재

void는 "아무것도 없음"을 나타내는 특수한 자료형으로, C언어의 타입 시스템에서 독특한 위치를 차지합니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// void 반환 타입 (리턴값이 없는 함수)
void printMessage() {
    printf("Hello, World!\n");
}

// void 매개변수 (매개변수가 없는 함수)
int getRandomNumber(void) {
    return 42;
}

// void 포인터 (범용 포인터) - 고급 활용
void printAnyType(void *ptr, char type) {
    switch (type) {
        case 'i':
            printf("정수: %d\n", *(int*)ptr);
            break;
        case 'f':
            printf("실수: %.2f\n", *(float*)ptr);
            break;
        case 'c':
            printf("문자: %c\n", *(char*)ptr);
            break;
        case 's':
            printf("문자열: %s\n", (char*)ptr);
            break;
    }
}

// void 포인터를 이용한 범용 비교 함수
int compareInts(const void *a, const void *b) {
    int ia = *(const int*)a;
    int ib = *(const int*)b;
    return (ia > ib) - (ia < ib);
}

// void 포인터를 이용한 범용 복사 함수
void* safeCopy(void *dest, const void *src, size_t size) {
    if (dest == NULL || src == NULL || size == 0) {
        return NULL;
    }
    return memcpy(dest, src, size);
}

int main() {
    printf("=== void 타입의 다양한 활용 ===\n");

    printMessage();

    int number = getRandomNumber();
    printf("랜덤 수: %d\n", number);

    // 다양한 타입 출력
    int i = 100;
    float f = 3.14f;
    char c = 'A';
    char str[] = "Hello";

    printAnyType(&i, 'i');
    printAnyType(&f, 'f');
    printAnyType(&c, 'c');
    printAnyType(str, 's');

    // void 포인터와 qsort 활용
    printf("\n=== void 포인터와 표준 라이브러리 ===\n");
    int numbers[] = {64, 34, 25, 12, 22, 11, 90};
    int count = sizeof(numbers) / sizeof(numbers[0]);

    printf("정렬 전: ");
    for (int j = 0; j < count; j++) {
        printf("%d ", numbers[j]);
    }
    printf("\n");

    qsort(numbers, count, sizeof(int), compareInts);

    printf("정렬 후: ");
    for (int j = 0; j < count; j++) {
        printf("%d ", numbers[j]);
    }
    printf("\n");

    // void 포인터를 이용한 범용 복사
    printf("\n=== 범용 메모리 조작 ===\n");
    int source = 0x12345678;
    int destination;

    void *result = safeCopy(&destination, &source, sizeof(int));
    if (result != NULL) {
        printf("복사 성공: 0x%X → 0x%X\n", source, destination);
    }

    return 0;
}
```

**void의 심층 이해:**

**1. void의 철학적 의미**
- void는 "타입이 없음"이 아니라 "완전한 타입"입니다
- 크기를 가지지 않지만 타입 시스템에서 중요한 역할을 합니다
- 컴파일러에게 "이 위치에는 특정 타입의 값이 없음"을 명시적으로 알립니다

**2. void 포인터의 강력함과 위험성**
```c
#include <stdio.h>

void demonstrateVoidPointerPower() {
    printf("=== void 포인터의 강력함과 위험성 ===\n");

    int integer = 42;
    float real = 3.14f;
    char character = 'A';

    // 같은 void 포인터로 다양한 타입 가리키기
    void *universal_ptr;

    universal_ptr = &integer;
    printf("정수로 해석: %d\n", *(int*)universal_ptr);

    universal_ptr = &real;
    printf("실수로 해석: %.2f\n", *(float*)universal_ptr);

    universal_ptr = &character;
    printf("문자로 해석: %c\n", *(char*)universal_ptr);

    // 위험한 사용 예시
    universal_ptr = &integer;
    printf("잘못된 해석 (float로): %.2f\n", *(float*)universal_ptr);
    // → 정수의 비트 패턴을 부동소수점으로 해석하여 이상한 값 출력

    printf("이것이 void 포인터의 위험성입니다!\n");
}

int main() {
    demonstrateVoidPointerPower();
    return 0;
}
```

**3. void와 함수 포인터**
```c
#include <stdio.h>

// 다양한 시그니처의 함수들
void operation1(void) {
    printf("Operation 1 실행\n");
}

void operation2(int x) {
    printf("Operation 2: %d\n", x);
}

int operation3(int a, int b) {
    return a + b;
}

// 함수 포인터를 이용한 콜백 시스템
typedef void (*VoidCallback)(void);
typedef void (*IntCallback)(int);
typedef int (*BinaryOperation)(int, int);

int main() {
    printf("=== void와 함수 포인터 시스템 ===\n");

    // 함수 포인터 배열
    VoidCallback void_funcs[] = {operation1};
    IntCallback int_funcs[] = {operation2};
    BinaryOperation binary_funcs[] = {operation3};

    // 함수 포인터 실행
    void_funcs[0]();
    int_funcs[0](100);
    int result = binary_funcs[0](10, 20);
    printf("이항 연산 결과: %d\n", result);

    return 0;
}
```

**4. void의 실무적 활용 - 제네릭 프로그래밍**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 제네릭 스택 구현
typedef struct {
    void *data;
    size_t element_size;
    size_t capacity;
    size_t count;
} GenericStack;

GenericStack* createStack(size_t element_size, size_t initial_capacity) {
    GenericStack *stack = malloc(sizeof(GenericStack));
    if (stack == NULL) return NULL;

    stack->data = malloc(element_size * initial_capacity);
    if (stack->data == NULL) {
        free(stack);
        return NULL;
    }

    stack->element_size = element_size;
    stack->capacity = initial_capacity;
    stack->count = 0;

    return stack;
}

int push(GenericStack *stack, const void *element) {
    if (stack == NULL || element == NULL) return -1;
    if (stack->count >= stack->capacity) return -1;  // 간단화: 리사이징 생략

    char *data_ptr = (char*)stack->data;
    char *target = data_ptr + (stack->count * stack->element_size);
    memcpy(target, element, stack->element_size);
    stack->count++;

    return 0;
}

int pop(GenericStack *stack, void *element) {
    if (stack == NULL || element == NULL || stack->count == 0) return -1;

    stack->count--;
    char *data_ptr = (char*)stack->data;
    char *source = data_ptr + (stack->count * stack->element_size);
    memcpy(element, source, stack->element_size);

    return 0;
}

void destroyStack(GenericStack *stack) {
    if (stack != NULL) {
        free(stack->data);
        free(stack);
    }
}

int main() {
    printf("=== 제네릭 스택 (void 포인터 활용) ===\n");

    // 정수 스택
    GenericStack *int_stack = createStack(sizeof(int), 10);
    int values[] = {10, 20, 30, 40, 50};

    printf("정수 스택에 push:\n");
    for (int i = 0; i < 5; i++) {
        push(int_stack, &values[i]);
        printf("  %d 추가\n", values[i]);
    }

    printf("정수 스택에서 pop:\n");
    int popped;
    while (int_stack->count > 0) {
        pop(int_stack, &popped);
        printf("  %d 제거\n", popped);
    }

    // 실수 스택
    GenericStack *float_stack = createStack(sizeof(float), 10);
    float float_values[] = {1.1f, 2.2f, 3.3f};

    printf("\n실수 스택에 push:\n");
    for (int i = 0; i < 3; i++) {
        push(float_stack, &float_values[i]);
        printf("  %.1f 추가\n", float_values[i]);
    }

    printf("실수 스택에서 pop:\n");
    float popped_float;
    while (float_stack->count > 0) {
        pop(float_stack, &popped_float);
        printf("  %.1f 제거\n", popped_float);
    }

    destroyStack(int_stack);
    destroyStack(float_stack);

    printf("\nvoid 포인터로 타입에 무관한 자료구조 구현 완료!\n");

    return 0;
}
```

## 자료형 수정자 (Type Modifiers)

### signed와 unsigned

```c
#include <stdio.h>

int main() {
    // signed (기본값)
    signed char sc = -100;
    signed int si = -2000000000;

    // unsigned
    unsigned char uc = 200;
    unsigned int ui = 4000000000U;

    printf("signed char: %d\n", sc);
    printf("unsigned char: %u\n", uc);
    printf("signed int: %d\n", si);
    printf("unsigned int: %u\n", ui);

    // 오버플로우 테스트
    unsigned char overflow = 255;
    printf("overflow 전: %u\n", overflow);
    overflow++;
    printf("overflow 후: %u\n", overflow);  // 0으로 순환

    return 0;
}
```

### short와 long

```c
#include <stdio.h>

int main() {
    short int si = 32000;           // short int와 동일
    short s = 32000;                // int 생략 가능

    long int li = 2000000000L;      // long int와 동일
    long l = 2000000000L;           // int 생략 가능

    long long int lli = 9000000000000000000LL;
    long long ll = 9000000000000000000LL;

    printf("short: %d\n", s);
    printf("long: %ld\n", l);
    printf("long long: %lld\n", ll);

    return 0;
}
```

## 자료형 변환 (Type Conversion)

### 자동 형 변환 (Implicit Conversion)

```c
#include <stdio.h>

int main() {
    // 승격 (Promotion)
    char c = 100;
    int i = c;          // char → int (자동 승격)
    printf("char %d → int %d\n", c, i);

    // 산술 연산에서의 자동 변환
    int intVal = 5;
    float floatVal = 2.5f;
    double result = intVal + floatVal;  // int + float → double
    printf("int %d + float %.1f = double %.1f\n", intVal, floatVal, result);

    // 대입 시 자동 변환
    double d = 3.14159;
    int truncated = d;  // double → int (소수점 버림)
    printf("double %.5f → int %d (소수점 버림)\n", d, truncated);

    return 0;
}
```

### 명시적 형 변환 (Explicit Conversion)

```c
#include <stdio.h>

int main() {
    // 캐스팅 (Casting)
    double pi = 3.14159;
    int intPi = (int)pi;            // 명시적 형 변환

    printf("원본: %.5f\n", pi);
    printf("캐스팅: %d\n", intPi);

    // 정밀도 변환
    float f = 3.14159f;
    double d = (double)f;
    printf("float: %.10f\n", f);
    printf("double: %.10f\n", d);

    // 포인터 캐스팅
    int number = 0x12345678;
    char *bytePtr = (char*)&number;

    printf("정수: 0x%x\n", number);
    printf("바이트별: ");
    for (int i = 0; i < sizeof(int); i++) {
        printf("0x%02x ", (unsigned char)bytePtr[i]);
    }
    printf("\n");

    return 0;
}
```

## 파생형 (Derived Types)

### 배열 (Array)

```c
#include <stdio.h>

int main() {
    // 1차원 배열
    int numbers[5] = {1, 2, 3, 4, 5};
    char name[] = "Hello";  // 문자 배열

    // 2차원 배열
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    printf("1차원 배열:\n");
    for (int i = 0; i < 5; i++) {
        printf("numbers[%d] = %d\n", i, numbers[i]);
    }

    printf("\n문자 배열: %s\n", name);

    printf("\n2차원 배열:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }

    printf("\n배열 크기 정보:\n");
    printf("numbers 크기: %zu bytes\n", sizeof(numbers));
    printf("matrix 크기: %zu bytes\n", sizeof(matrix));

    return 0;
}
```

### 포인터 (Pointer)

```c
#include <stdio.h>

int main() {
    int number = 42;
    int *ptr = &number;     // 포인터 선언 및 초기화

    printf("변수 정보:\n");
    printf("number 값: %d\n", number);
    printf("number 주소: %p\n", (void*)&number);

    printf("\n포인터 정보:\n");
    printf("ptr 값 (주소): %p\n", (void*)ptr);
    printf("ptr이 가리키는 값: %d\n", *ptr);
    printf("ptr 자체의 주소: %p\n", (void*)&ptr);

    // 포인터를 통한 값 변경
    *ptr = 100;
    printf("\n포인터를 통한 값 변경 후:\n");
    printf("number 값: %d\n", number);

    // 다양한 자료형의 포인터
    float f = 3.14f;
    char c = 'A';

    float *fptr = &f;
    char *cptr = &c;

    printf("\nfloat 포인터: %.2f\n", *fptr);
    printf("char 포인터: %c\n", *cptr);

    return 0;
}
```

### 구조체 (Structure) 기본

```c
#include <stdio.h>

// 구조체 정의
struct Student {
    int id;
    char name[50];
    float gpa;
};

int main() {
    // 구조체 변수 선언 및 초기화
    struct Student student1 = {1001, "김철수", 3.75f};
    struct Student student2;

    // 개별 멤버 할당
    student2.id = 1002;
    strcpy(student2.name, "이영희");  // string.h 필요
    student2.gpa = 4.0f;

    printf("=== 학생 정보 ===\n");
    printf("학생1: ID=%d, 이름=%s, GPA=%.2f\n",
           student1.id, student1.name, student1.gpa);
    printf("학생2: ID=%d, 이름=%s, GPA=%.2f\n",
           student2.id, student2.name, student2.gpa);

    printf("구조체 크기: %zu bytes\n", sizeof(struct Student));

    return 0;
}
```

### 열거형 (Enumeration)

```c
#include <stdio.h>

// 열거형 정의
enum Color {
    RED,        // 0
    GREEN,      // 1
    BLUE        // 2
};

enum Status {
    INACTIVE = 0,
    ACTIVE = 1,
    PENDING = 10,
    COMPLETED = 11
};

int main() {
    enum Color favoriteColor = BLUE;
    enum Status currentStatus = ACTIVE;

    printf("좋아하는 색상: %d\n", favoriteColor);
    printf("현재 상태: %d\n", currentStatus);

    // switch문에서 활용
    switch (favoriteColor) {
        case RED:
            printf("빨간색을 선택했습니다.\n");
            break;
        case GREEN:
            printf("초록색을 선택했습니다.\n");
            break;
        case BLUE:
            printf("파란색을 선택했습니다.\n");
            break;
    }

    return 0;
}
```

## typedef를 이용한 자료형 별칭

```c
#include <stdio.h>

// 기본 자료형 별칭
typedef int Integer;
typedef float Real;
typedef char Character;

// 복합 자료형 별칭
typedef struct {
    int x, y;
} Point;

typedef enum {
    SUNDAY,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY
} Day;

int main() {
    // 별칭 사용
    Integer age = 25;
    Real height = 175.5f;
    Character grade = 'A';

    Point center = {0, 0};
    Point corner = {10, 20};

    Day today = FRIDAY;

    printf("나이: %d\n", age);
    printf("키: %.1f\n", height);
    printf("등급: %c\n", grade);
    printf("중심점: (%d, %d)\n", center.x, center.y);
    printf("모서리점: (%d, %d)\n", corner.x, corner.y);
    printf("오늘: %d (금요일)\n", today);

    return 0;
}
```

## 자료형 크기와 메모리 정렬

### 플랫폼별 자료형 크기

```c
#include <stdio.h>
#include <stddef.h>
#include <limits.h>
#include <float.h>

int main() {
    printf("=== 플랫폼별 자료형 크기 ===\n");
    printf("자료형        크기(bytes)   비트   범위\n");
    printf("----------------------------------------------------------\n");
    printf("char:         %zu           %d     %d ~ %d\n",
           sizeof(char), (int)sizeof(char)*8, CHAR_MIN, CHAR_MAX);
    printf("short:        %zu           %d     %d ~ %d\n",
           sizeof(short), (int)sizeof(short)*8, SHRT_MIN, SHRT_MAX);
    printf("int:          %zu           %d     %d ~ %d\n",
           sizeof(int), (int)sizeof(int)*8, INT_MIN, INT_MAX);
    printf("long:         %zu           %d     %ld ~ %ld\n",
           sizeof(long), (int)sizeof(long)*8, LONG_MIN, LONG_MAX);
    printf("long long:    %zu           %d     %lld ~ %lld\n",
           sizeof(long long), (int)sizeof(long long)*8, LLONG_MIN, LLONG_MAX);
    printf("float:        %zu           %d     정밀도 %d자리\n",
           sizeof(float), (int)sizeof(float)*8, FLT_DIG);
    printf("double:       %zu           %d     정밀도 %d자리\n",
           sizeof(double), (int)sizeof(double)*8, DBL_DIG);
    printf("long double:  %zu           %d     정밀도 %d자리\n",
           sizeof(long double), (int)sizeof(long double)*8, LDBL_DIG);
    printf("pointer:      %zu           %d     주소 공간\n",
           sizeof(void*), (int)sizeof(void*)*8);

    printf("\n=== 메모리 효율성 ===\n");
    printf("1비트당 표현 가능한 값의 개수: 2^1 = 2개\n");
    printf("8비트(1byte)당 표현 가능한 값: 2^8 = 256개\n");
    printf("32비트 int가 표현 가능한 값: 2^32 = %llu개\n", (1ULL << 32));

    return 0;
}
```

### 메모리 정렬과 패딩

```c
#include <stdio.h>
#include <stddef.h>

struct Example {
    char c;     // 1 byte
    int i;      // 4 bytes
    short s;    // 2 bytes
};

struct Packed {
    char c;
    char padding[3];  // 명시적 패딩
    int i;
    short s;
    char padding2[2]; // 명시적 패딩
};

// 정렬을 고려한 구조체
struct Optimized {
    int i;      // 4 bytes (4바이트 정렬)
    short s;    // 2 bytes
    char c;     // 1 byte
    // 1 byte 패딩 자동 추가됨
};

int main() {
    printf("=== 구조체 메모리 정렬 분석 ===\n");

    printf("Example 구조체:\n");
    printf("  전체 크기: %zu bytes\n", sizeof(struct Example));
    printf("  c의 오프셋: %zu (크기: %zu)\n", offsetof(struct Example, c), sizeof(char));
    printf("  i의 오프셋: %zu (크기: %zu)\n", offsetof(struct Example, i), sizeof(int));
    printf("  s의 오프셋: %zu (크기: %zu)\n", offsetof(struct Example, s), sizeof(short));

    printf("\nOptimized 구조체:\n");
    printf("  전체 크기: %zu bytes\n", sizeof(struct Optimized));
    printf("  i의 오프셋: %zu\n", offsetof(struct Optimized, i));
    printf("  s의 오프셋: %zu\n", offsetof(struct Optimized, s));
    printf("  c의 오프셋: %zu\n", offsetof(struct Optimized, c));

    printf("\n=== 메모리 정렬 규칙 ===\n");
    printf("1. 각 멤버는 자신의 크기의 배수 주소에 정렬\n");
    printf("2. 구조체 전체 크기는 가장 큰 멤버 크기의 배수\n");
    printf("3. 패딩은 정렬을 위해 자동으로 삽입됨\n");

    printf("\n예상 vs 실제:\n");
    printf("Example 예상: 1+4+2 = 7 bytes\n");
    printf("Example 실제: %zu bytes (패딩 포함)\n", sizeof(struct Example));
    printf("낭비된 메모리: %zu bytes\n", sizeof(struct Example) - 7);

    return 0;
}
```

### 바이트 순서 (Endianness)

```c
#include <stdio.h>

typedef union {
    int i;
    char bytes[sizeof(int)];
} IntBytes;

int main() {
    IntBytes data;
    data.i = 0x12345678;

    printf("=== 바이트 순서 (Endianness) ===\n");
    printf("정수 값: 0x%X\n", data.i);
    printf("메모리 배치:\n");

    for (int i = 0; i < sizeof(int); i++) {
        printf("  주소 +%d: 0x%02X\n", i, (unsigned char)data.bytes[i]);
    }

    // 엔디안 판별
    if (data.bytes[0] == 0x78) {
        printf("\n이 시스템은 Little Endian입니다.\n");
        printf("(최하위 바이트가 낮은 주소에 저장)\n");
    } else if (data.bytes[0] == 0x12) {
        printf("\n이 시스템은 Big Endian입니다.\n");
        printf("(최상위 바이트가 낮은 주소에 저장)\n");
    }

    return 0;
}
```

## 자료형 선택 가이드

### 실무에서의 자료형 선택

```c
#include <stdio.h>
#include <stdint.h>  // 고정 크기 정수형

int main() {
    // 크기가 명확한 정수형 (권장)
    int8_t  byte = -128;        // 1바이트 정수
    int16_t word = 32000;       // 2바이트 정수
    int32_t dword = 2000000000; // 4바이트 정수
    int64_t qword = 9000000000000000000LL; // 8바이트 정수

    uint8_t  ubyte = 255;       // 1바이트 unsigned
    uint16_t uword = 65000;     // 2바이트 unsigned
    uint32_t udword = 4000000000U; // 4바이트 unsigned
    uint64_t uqword = 18000000000000000000ULL; // 8바이트 unsigned

    printf("=== 고정 크기 정수형 ===\n");
    printf("int8_t:  %d (크기: %zu)\n", byte, sizeof(byte));
    printf("int16_t: %d (크기: %zu)\n", word, sizeof(word));
    printf("int32_t: %d (크기: %zu)\n", dword, sizeof(dword));
    printf("int64_t: %lld (크기: %zu)\n", qword, sizeof(qword));

    printf("uint8_t:  %u (크기: %zu)\n", ubyte, sizeof(ubyte));
    printf("uint16_t: %u (크기: %zu)\n", uword, sizeof(uword));
    printf("uint32_t: %u (크기: %zu)\n", udword, sizeof(udword));
    printf("uint64_t: %llu (크기: %zu)\n", uqword, sizeof(uqword));

    return 0;
}
```

### 자료형 선택 기준

```c
#include <stdio.h>

int main() {
    printf("=== 자료형 선택 가이드 ===\n\n");

    printf("1. 정수형 선택:\n");
    printf("   - 일반적인 정수: int\n");
    printf("   - 작은 범위 (-128~127): char\n");
    printf("   - 큰 범위가 필요한 경우: long long\n");
    printf("   - 양수만 필요한 경우: unsigned 타입\n");
    printf("   - 크기가 중요한 경우: int8_t, int16_t, int32_t, int64_t\n\n");

    printf("2. 실수형 선택:\n");
    printf("   - 일반적인 실수: double (권장)\n");
    printf("   - 메모리가 중요한 경우: float\n");
    printf("   - 최고 정밀도가 필요한 경우: long double\n\n");

    printf("3. 문자/문자열:\n");
    printf("   - 단일 문자: char\n");
    printf("   - 문자열: char 배열 또는 char*\n\n");

    printf("4. 포인터:\n");
    printf("   - 특정 타입 가리킬 때: 해당 타입*\n");
    printf("   - 범용 포인터: void*\n");

    return 0;
}
```

## 정리

이번 장에서 학습한 C언어 자료형의 핵심 내용:

### 기본형
- **정수형**: char, short, int, long, long long
- **실수형**: float, double, long double
- **void**: 특수 목적 자료형

### 중요 개념
- **크기와 범위**: 각 자료형의 메모리 크기와 값의 범위
- **signed/unsigned**: 부호 있음/없음
- **자동/명시적 형변환**: 타입 간 변환
- **메모리 정렬**: 구조체의 패딩

### 파생형
- **배열**: 같은 타입의 연속된 메모리
- **포인터**: 메모리 주소를 저장
- **구조체**: 여러 데이터를 묶음
- **열거형**: 상수들의 집합

### 실무 팁
- 크기가 명확해야 할 때는 `stdint.h`의 고정 크기 타입 사용
- 일반적으로는 `int`, `double` 사용 권장
- 메모리 효율이 중요한 경우에만 작은 타입 사용

자료형에 대한 정확한 이해는 효율적이고 안전한 C 프로그램 작성의 기초가 됩니다.