# 3.2 반복문 (Loop Statements)

## 반복문의 개념

반복문은 **특정 조건이 만족되는 동안 코드 블록을 반복 실행하는 제어 구조**입니다. 컴퓨터의 강력한 특성인 반복 능력을 활용하여 효율적인 프로그래밍을 가능하게 합니다.

### 왜 반복문이 필요한가?

```c
// 반복문 없이 1부터 10까지 출력
printf("%d ", 1);
printf("%d ", 2);
printf("%d ", 3);
// ... 10번 반복

// 반복문 사용
for (int i = 1; i <= 10; i++) {
    printf("%d ", i);
}
```

반복문의 장점:
- **코드 재사용**: 한 번 작성으로 여러 번 실행
- **동적 처리**: 실행 시점에 반복 횟수 결정
- **유지보수**: 수정이 쉽고 오류 가능성 감소

### 반복문의 기본 구조

모든 반복문은 세 가지 요소로 구성됩니다:

1. **초기화**: 반복 시작을 위한 준비
2. **조건**: 반복 계속 여부 판단
3. **갱신**: 각 반복 후 상태 변경

```c
// 일반적인 패턴
초기화;
while (조건) {
    // 실행할 코드
    갱신;
}
```

### 반복문의 종류

**1. 진입 조건 반복문**
- `for`, `while`: 조건을 먼저 검사
- 조건이 거짓이면 실행되지 않음

**2. 탈출 조건 반복문**
- `do-while`: 한 번 실행 후 조건 검사
- 최소 한 번은 실행됨

### 무한 루프 주의

```c
// 올바른 예
int i = 0;
while (i < 10) {
    printf("%d ", i);
    i++;  // 갱신 필수!
}

// 잘못된 예 - 무한 루프
int i = 0;
while (i < 10) {
    printf("%d ", i);
    // i++; 빠뜨림!
}
```

## for 문

### for 문 기본 구조

```c
for (초기화; 조건; 갱신) {
    // 실행할 코드
}
```

**실행 순서:**
1. 초기화 (한 번만)
2. 조건 검사
3. 조건이 참이면 본문 실행
4. 갱신
5. 2번부터 반복

### for 문 예제

**1. 기본 카운팅**
```c
// 1부터 10까지
for (int i = 1; i <= 10; i++) {
    printf("%d ", i);
}

// 10부터 1까지 (역순)
for (int i = 10; i >= 1; i--) {
    printf("%d ", i);
}

// 2씩 증가 (짝수)
for (int i = 2; i <= 20; i += 2) {
    printf("%d ", i);
}
```

**2. 팩토리얼 계산**
```c
int factorial(int n) {
    int result = 1;
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}

int main() {
    int n = 5;
    printf("%d! = %d\n", n, factorial(n));  // 출력: 5! = 120
    return 0;
}
```

### 중첩 for 문

**1. 구구단**
```c
for (int i = 2; i <= 9; i++) {
    printf("[%d단]\n", i);
    for (int j = 1; j <= 9; j++) {
        printf("%d × %d = %d\n", i, j, i * j);
    }
    printf("\n");
}
```

**2. 삼각형 패턴**
```c
for (int i = 1; i <= 5; i++) {
    for (int j = 1; j <= i; j++) {
        printf("* ");
    }
    printf("\n");
}
// 출력:
// *
// * *
// * * *
// * * * *
// * * * * *
```

**3. 2차원 배열 처리**
```c
int matrix[3][3] = {{1,2,3}, {4,5,6}, {7,8,9}};

// 배열 출력
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        printf("%d ", matrix[i][j]);
    }
    printf("\n");
}
```

### for 문 응용

**1. 여러 변수 사용**
```c
// 두 변수 동시 제어
for (int i = 0, j = 10; i < j; i++, j--) {
    printf("i=%d, j=%d\n", i, j);
}
```

**2. 특별한 형태**
```c
// 초기화 생략
int i = 0;
for (; i < 10; i++) {
    printf("%d ", i);
}

// 무한 루프
for (;;) {
    // 조건에 따라 break로 탈출
    if (조건) break;
}
```

## while 문

### 기본 구조

```c
while (조건) {
    // 실행할 코드
    // 조건을 변경하는 코드 필수!
}
```

while 문은 **조건이 참인 동안 반복**하며, 반복 횟수를 미리 알 수 없을 때 사용합니다.

### while 문 예제

**1. 자릿수 계산**
```c
int count_digits(int n) {
    int count = 0;
    while (n > 0) {
        n /= 10;
        count++;
    }
    return count;
}

int main() {
    int num = 12345;
    printf("%d는 %d자리 수\n", num, count_digits(num));  // 출력: 12345는 5자리 수
    return 0;
}
```

**2. 최대공약수 (유클리드 호제법)**
```c
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main() {
    printf("gcd(48, 18) = %d\n", gcd(48, 18));  // 출력: 6
    return 0;
}
```

**3. 입력 반복**
```c
int main() {
    int num, sum = 0;

    printf("정수 입력 (0으로 종료): ");
    while (scanf("%d", &num) && num != 0) {
        sum += num;
        printf("현재 합: %d, 다음 수: ", sum);
    }

    printf("\n최종 합: %d\n", sum);
    return 0;
}
```

### while 문 활용

**1. 메뉴 시스템**
```c
int main() {
    int choice;

    while (1) {
        printf("\n1. 덧셈  2. 뺄셈  3. 종료\n선택: ");
        scanf("%d", &choice);

        if (choice == 3) {
            printf("종료합니다.\n");
            break;
        }

        if (choice == 1 || choice == 2) {
            int a, b;
            printf("두 수 입력: ");
            scanf("%d %d", &a, &b);

            if (choice == 1) {
                printf("%d + %d = %d\n", a, b, a + b);
            } else {
                printf("%d - %d = %d\n", a, b, a - b);
            }
        } else {
            printf("잘못된 선택입니다.\n");
        }
    }
    return 0;
}
```

**2. 입력 검증**
```c
int get_positive_number() {
    int num;
    while (1) {
        printf("양수를 입력하세요: ");
        scanf("%d", &num);
        if (num > 0) {
            return num;
        }
        printf("0보다 큰 수를 입력하세요.\n");
    }
}
```

### while 문과 파일 처리

**1. 파일 읽기**
```c
#include <stdio.h>
#include <stdlib.h>

void count_file_statistics(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("파일을 열 수 없습니다: %s\n", filename);
        return;
    }

    int ch;
    int lines = 0, words = 0, chars = 0;
    bool in_word = false;

    while ((ch = fgetc(file)) != EOF) {
        chars++;

        if (ch == '\n') {
            lines++;
            in_word = false;
        } else if (ch == ' ' || ch == '\t') {
            in_word = false;
        } else if (!in_word) {
            words++;
            in_word = true;
        }
    }

    fclose(file);

    printf("파일 통계: %s\n", filename);
    printf("문자 수: %d\n", chars);
    printf("단어 수: %d\n", words);
    printf("줄 수: %d\n", lines);
}

void copy_file(const char *source, const char *destination) {
    FILE *src = fopen(source, "r");
    FILE *dst = fopen(destination, "w");

    if (src == NULL || dst == NULL) {
        printf("파일 열기 실패\n");
        if (src) fclose(src);
        if (dst) fclose(dst);
        return;
    }

    int ch;
    while ((ch = fgetc(src)) != EOF) {
        fputc(ch, dst);
    }

    fclose(src);
    fclose(dst);
    printf("파일 복사 완료: %s -> %s\n", source, destination);
}
```

## do-while 문

### do-while 문의 기본 구조

```c
do {
    // 반복할 코드
} while (조건);
```

do-while 문은 **최소 한 번은 실행되어야 하는 경우**에 사용합니다.

### do-while 문의 특징

**while vs do-while 비교:**
```c
// while: 조건이 거짓이면 한 번도 실행되지 않음
int i = 10;
while (i < 5) {
    printf("while: %d\n", i);  // 출력되지 않음
    i++;
}

// do-while: 최소 한 번은 실행됨
int j = 10;
do {
    printf("do-while: %d\n", j);  // 한 번 출력됨
    j++;
} while (j < 5);
```

### do-while 문 실용 예제

**1. 메뉴 시스템 (최소 한 번은 메뉴 표시)**
```c
#include <stdio.h>

int main() {
    int choice;

    do {
        printf("\n=== 메뉴 ===\n");
        printf("1. 옵션 1\n");
        printf("2. 옵션 2\n");
        printf("3. 옵션 3\n");
        printf("0. 종료\n");
        printf("선택: ");

        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("옵션 1을 선택했습니다.\n");
                break;
            case 2:
                printf("옵션 2를 선택했습니다.\n");
                break;
            case 3:
                printf("옵션 3을 선택했습니다.\n");
                break;
            case 0:
                printf("프로그램을 종료합니다.\n");
                break;
            default:
                printf("잘못된 선택입니다.\n");
                break;
        }
    } while (choice != 0);

    return 0;
}
```

**2. 게임의 재시작 기능**
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void number_guessing_game() {
    int secret, guess, attempts;
    char play_again;

    srand(time(NULL));

    do {
        secret = rand() % 100 + 1;  // 1-100 사이의 랜덤 수
        attempts = 0;

        printf("\n=== 숫자 맞히기 게임 ===\n");
        printf("1부터 100 사이의 숫자를 맞혀보세요!\n");

        do {
            printf("추측: ");
            scanf("%d", &guess);
            attempts++;

            if (guess < secret) {
                printf("더 큰 수입니다.\n");
            } else if (guess > secret) {
                printf("더 작은 수입니다.\n");
            } else {
                printf("정답입니다! %d번 만에 맞혔습니다.\n", attempts);
            }
        } while (guess != secret);

        printf("다시 하시겠습니까? (y/n): ");
        scanf(" %c", &play_again);

    } while (play_again == 'y' || play_again == 'Y');

    printf("게임을 종료합니다.\n");
}
```

**3. 입력 검증 (반드시 유효한 입력을 받을 때까지)**
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

void get_valid_password(char *password, size_t size) {
    bool valid;

    do {
        valid = true;
        printf("비밀번호를 입력하세요 (8자 이상, 대소문자+숫자 포함): ");
        scanf("%49s", password);

        // 길이 검사
        if (strlen(password) < 8) {
            printf("비밀번호는 8자 이상이어야 합니다.\n");
            valid = false;
            continue;
        }

        // 대문자, 소문자, 숫자 포함 검사
        bool has_upper = false, has_lower = false, has_digit = false;

        for (int i = 0; password[i]; i++) {
            if (isupper(password[i])) has_upper = true;
            else if (islower(password[i])) has_lower = true;
            else if (isdigit(password[i])) has_digit = true;
        }

        if (!has_upper || !has_lower || !has_digit) {
            printf("비밀번호는 대문자, 소문자, 숫자를 모두 포함해야 합니다.\n");
            valid = false;
        }

    } while (!valid);

    printf("유효한 비밀번호가 설정되었습니다.\n");
}
```

## 반복문 제어: break와 continue

### break 문

break 문은 **반복문을 즉시 종료**하고 반복문 다음 문장으로 제어를 이동시킵니다.

**기본 사용법:**
```c
#include <stdio.h>

int main() {
    // 특정 조건에서 루프 탈출
    for (int i = 1; i <= 10; i++) {
        if (i == 6) {
            printf("6에서 루프를 종료합니다.\n");
            break;
        }
        printf("%d ", i);
    }
    printf("\n루프 종료 후\n");

    return 0;
}
// 출력: 1 2 3 4 5 6에서 루프를 종료합니다.
//       루프 종료 후
```

**실용적인 break 활용:**

**1. 검색에서 찾으면 중단**
```c
#include <stdio.h>

int linear_search(int arr[], int size, int target) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == target) {
            return i;  // 찾으면 즉시 반환
        }
    }
    return -1;  // 찾지 못함
}

// break를 사용한 버전
int linear_search_with_break(int arr[], int size, int target) {
    int index = -1;

    for (int i = 0; i < size; i++) {
        if (arr[i] == target) {
            index = i;
            break;  // 찾으면 즉시 종료
        }
    }

    return index;
}
```

**2. 중첩 루프에서의 break**
```c
#include <stdio.h>

// 2차원 배열에서 특정 값 찾기
void find_in_matrix(int matrix[3][3], int target) {
    bool found = false;

    for (int i = 0; i < 3 && !found; i++) {
        for (int j = 0; j < 3; j++) {
            if (matrix[i][j] == target) {
                printf("%d를 (%d, %d)에서 찾았습니다.\n", target, i, j);
                found = true;
                break;  // 안쪽 루프만 종료
            }
        }
    }

    if (!found) {
        printf("%d를 찾지 못했습니다.\n", target);
    }
}

// goto를 사용한 다중 루프 탈출 (권장하지 않음)
void find_in_matrix_goto(int matrix[3][3], int target) {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (matrix[i][j] == target) {
                printf("%d를 (%d, %d)에서 찾았습니다.\n", target, i, j);
                goto found;  // 모든 루프 탈출
            }
        }
    }
    printf("%d를 찾지 못했습니다.\n", target);
    return;

found:
    printf("검색 완료\n");
}
```

**3. 안전한 입력 루프**
```c
#include <stdio.h>

int get_positive_integer() {
    int value;

    while (1) {  // 무한 루프
        printf("양의 정수를 입력하세요: ");

        if (scanf("%d", &value) != 1) {
            printf("잘못된 입력입니다.\n");
            while (getchar() != '\n');  // 버퍼 비우기
            continue;
        }

        if (value > 0) {
            break;  // 유효한 입력이면 루프 탈출
        }

        printf("0보다 큰 수를 입력하세요.\n");
    }

    return value;
}
```

### continue 문

continue 문은 **현재 반복의 나머지 부분을 건너뛰고** 다음 반복으로 이동합니다.

**기본 사용법:**
```c
#include <stdio.h>

int main() {
    // 홀수만 출력 (짝수는 건너뛰기)
    for (int i = 1; i <= 10; i++) {
        if (i % 2 == 0) {
            continue;  // 짝수면 아래 코드 건너뛰고 다음 반복
        }
        printf("%d ", i);
    }
    printf("\n");

    return 0;
}
// 출력: 1 3 5 7 9
```

**실용적인 continue 활용:**

**1. 조건부 처리**
```c
#include <stdio.h>
#include <ctype.h>

void process_characters(const char *str) {
    printf("문자열의 알파벳만 처리:\n");

    for (int i = 0; str[i]; i++) {
        // 알파벳이 아니면 건너뛰기
        if (!isalpha(str[i])) {
            continue;
        }

        printf("%c -> %c\n", str[i], toupper(str[i]));
    }
}

int main() {
    const char *text = "Hello, World! 123";
    process_characters(text);
    return 0;
}
```

**2. 배열에서 유효한 값만 처리**
```c
#include <stdio.h>

double calculate_average_positive(double arr[], int size) {
    double sum = 0.0;
    int count = 0;

    for (int i = 0; i < size; i++) {
        // 음수나 0은 건너뛰기
        if (arr[i] <= 0) {
            continue;
        }

        sum += arr[i];
        count++;
    }

    return count > 0 ? sum / count : 0.0;
}

void print_valid_scores(int scores[], int size) {
    printf("유효한 점수들 (0-100):\n");

    for (int i = 0; i < size; i++) {
        // 범위를 벗어난 점수는 건너뛰기
        if (scores[i] < 0 || scores[i] > 100) {
            continue;
        }

        printf("학생 %d: %d점\n", i + 1, scores[i]);
    }
}
```

**3. 파일 처리에서 빈 줄 건너뛰기**
```c
#include <stdio.h>
#include <string.h>

void process_config_file(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("파일을 열 수 없습니다: %s\n", filename);
        return;
    }

    char line[256];
    int line_number = 0;

    while (fgets(line, sizeof(line), file)) {
        line_number++;

        // 빈 줄이나 주석 줄은 건너뛰기
        if (line[0] == '\n' || line[0] == '#') {
            continue;
        }

        // 앞뒤 공백 제거 후 빈 줄 체크
        char *start = line;
        while (*start == ' ' || *start == '\t') start++;

        if (*start == '\n' || *start == '\0') {
            continue;  // 공백만 있는 줄
        }

        printf("라인 %d: %s", line_number, start);
    }

    fclose(file);
}
```

### break vs continue vs return

**비교 예제:**
```c
#include <stdio.h>

void demonstrate_control_statements() {
    printf("=== break 예제 ===\n");
    for (int i = 1; i <= 5; i++) {
        if (i == 3) {
            printf("break at %d\n", i);
            break;  // 루프 완전 종료
        }
        printf("%d ", i);
    }
    printf("after break loop\n\n");

    printf("=== continue 예제 ===\n");
    for (int i = 1; i <= 5; i++) {
        if (i == 3) {
            printf("skip %d\n", i);
            continue;  // 현재 반복만 건너뛰기
        }
        printf("%d ", i);
    }
    printf("after continue loop\n\n");

    printf("=== return 예제 ===\n");
    for (int i = 1; i <= 5; i++) {
        if (i == 3) {
            printf("return at %d\n", i);
            return;  // 함수 완전 종료
        }
        printf("%d ", i);
    }
    printf("이 줄은 실행되지 않음\n");
}
```

## 반복문 최적화와 성능

### 루프 최적화 기법

**1. 루프 불변 코드 이동 (Loop Invariant Code Motion)**
```c
// 비효율적인 코드
for (int i = 0; i < 1000; i++) {
    int limit = calculate_expensive_limit();  // 매번 계산
    if (array[i] < limit) {
        process(array[i]);
    }
}

// 최적화된 코드
int limit = calculate_expensive_limit();  // 한 번만 계산
for (int i = 0; i < 1000; i++) {
    if (array[i] < limit) {
        process(array[i]);
    }
}
```

**2. 강도 축소 (Strength Reduction)**
```c
// 비효율적인 코드 (곱셈 사용)
for (int i = 0; i < 100; i++) {
    array[i] = i * 5;
}

// 최적화된 코드 (덧셈 사용)
int value = 0;
for (int i = 0; i < 100; i++) {
    array[i] = value;
    value += 5;
}
```

**3. 언롤링 (Loop Unrolling)**
```c
// 원본 루프
for (int i = 0; i < 1000; i++) {
    sum += array[i];
}

// 부분 언롤링 (4배수 처리)
int i;
for (i = 0; i < 1000 - 3; i += 4) {
    sum += array[i] + array[i+1] + array[i+2] + array[i+3];
}
// 나머지 처리
for (; i < 1000; i++) {
    sum += array[i];
}
```

**4. 루프 융합 (Loop Fusion)**
```c
// 분리된 루프들
for (int i = 0; i < size; i++) {
    a[i] = b[i] + c[i];
}
for (int i = 0; i < size; i++) {
    d[i] = a[i] * 2;
}

// 융합된 루프
for (int i = 0; i < size; i++) {
    a[i] = b[i] + c[i];
    d[i] = a[i] * 2;
}
```

### 메모리 접근 패턴 최적화

**1. 캐시 친화적 접근 (Cache-Friendly Access)**
```c
#define SIZE 1000

// 비효율적: 열 우선 접근 (캐시 미스 많음)
void matrix_multiply_bad(int a[SIZE][SIZE], int b[SIZE][SIZE], int c[SIZE][SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            for (int k = 0; k < SIZE; k++) {
                c[i][j] += a[i][k] * b[k][j];  // b[k][j]가 비연속적
            }
        }
    }
}

// 효율적: 행 우선 접근 + 루프 순서 변경
void matrix_multiply_good(int a[SIZE][SIZE], int b[SIZE][SIZE], int c[SIZE][SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int k = 0; k < SIZE; k++) {
            for (int j = 0; j < SIZE; j++) {
                c[i][j] += a[i][k] * b[k][j];  // 연속적인 메모리 접근
            }
        }
    }
}
```

**2. 블록화 (Blocking/Tiling)**
```c
#define BLOCK_SIZE 64

void matrix_multiply_blocked(int a[SIZE][SIZE], int b[SIZE][SIZE], int c[SIZE][SIZE]) {
    for (int ii = 0; ii < SIZE; ii += BLOCK_SIZE) {
        for (int jj = 0; jj < SIZE; jj += BLOCK_SIZE) {
            for (int kk = 0; kk < SIZE; kk += BLOCK_SIZE) {
                // 블록 단위로 처리
                for (int i = ii; i < ii + BLOCK_SIZE && i < SIZE; i++) {
                    for (int j = jj; j < jj + BLOCK_SIZE && j < SIZE; j++) {
                        for (int k = kk; k < kk + BLOCK_SIZE && k < SIZE; k++) {
                            c[i][j] += a[i][k] * b[k][j];
                        }
                    }
                }
            }
        }
    }
}
```

### 컴파일러 최적화 힌트

**1. restrict 키워드 사용**
```c
// 포인터 앨리어싱 방지
void vector_add(int * restrict a, int * restrict b, int * restrict c, int n) {
    for (int i = 0; i < n; i++) {
        c[i] = a[i] + b[i];  // 컴파일러가 벡터화 최적화 가능
    }
}
```

**2. 프래그마 지시어 활용**
```c
#include <stdio.h>

void optimized_loop(float *a, float *b, float *c, int n) {
    #pragma omp simd  // OpenMP SIMD 지시어
    for (int i = 0; i < n; i++) {
        c[i] = a[i] + b[i];
    }
}

void unroll_hint_loop(int *arr, int n) {
    #pragma unroll 4  // 컴파일러에게 4배 언롤링 힌트
    for (int i = 0; i < n; i++) {
        arr[i] *= 2;
    }
}
```

## 반복문 활용 실습

### 실습 1: 고급 수학 계산기

```c
#include <stdio.h>
#include <math.h>
#include <stdbool.h>

// π 근사값 계산 (라이프니츠 공식)
double calculate_pi(int n) {
    double pi = 0.0;
    int sign = 1;
    for (int i = 0; i < n; i++) {
        pi += sign * (1.0 / (2 * i + 1));
        sign *= -1;
    }
    return pi * 4;
}

// 팩토리얼 계산
long factorial(int n) {
    long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

// 소수 판정
int is_prime(int n) {
    if (n < 2) return 0;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return 0;
    }
    return 1;
}

int main() {
    printf("π ≈ %.6f\n", calculate_pi(100000));
    printf("10! = %ld\n", factorial(10));

    // 100 이하 소수 찾기
    printf("100 이하 소수: ");
    for (int i = 2; i <= 100; i++) {
        if (is_prime(i)) printf("%d ", i);
    }
    printf("\n");

    return 0;
}
```

### 간단한 데이터 분석

```c
#include <stdio.h>

void analyze_scores(int scores[], int size) {
    // 평균 계산
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += scores[i];
    }
    double average = (double)sum / size;

    // 최댓값, 최솟값
    int max = scores[0], min = scores[0];
    for (int i = 1; i < size; i++) {
        if (scores[i] > max) max = scores[i];
        if (scores[i] < min) min = scores[i];
    }

    // 등급 분류
    int grade_count[5] = {0}; // A, B, C, D, F
    for (int i = 0; i < size; i++) {
        if (scores[i] >= 90) grade_count[0]++;
        else if (scores[i] >= 80) grade_count[1]++;
        else if (scores[i] >= 70) grade_count[2]++;
        else if (scores[i] >= 60) grade_count[3]++;
        else grade_count[4]++;
    }

    printf("=== 성적 분석 ===\n");
    printf("평균: %.1f\n", average);
    printf("최고: %d, 최저: %d\n", max, min);
    printf("A:%d B:%d C:%d D:%d F:%d\n",
           grade_count[0], grade_count[1], grade_count[2],
           grade_count[3], grade_count[4]);
}

int main() {
    int scores[] = {95, 87, 92, 78, 85, 90, 76, 88, 94, 82};
    int size = sizeof(scores) / sizeof(scores[0]);

    analyze_scores(scores, size);
    return 0;
}
```

### 문자열 처리 예제

```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

// 시저 암호 (간단한 치환 암호)
void caesar_cipher(char *text, int shift) {
    for (int i = 0; text[i]; i++) {
        if (isalpha(text[i])) {
            char base = isupper(text[i]) ? 'A' : 'a';
            text[i] = ((text[i] - base + shift) % 26) + base;
        }
    }
}

// 문자 빈도 계산
void char_frequency(const char *text) {
    int freq[26] = {0};
    int total = 0;

    for (int i = 0; text[i]; i++) {
        if (isalpha(text[i])) {
            freq[toupper(text[i]) - 'A']++;
            total++;
        }
    }

    printf("=== 문자 빈도 ===\n");
    for (int i = 0; i < 26; i++) {
        if (freq[i] > 0) {
            printf("%c: %d번 (%.1f%%)\n",
                   'A' + i, freq[i], (100.0 * freq[i]) / total);
        }
    }
}

// 단어 개수 세기
int count_words(const char *text) {
    int words = 0;
    int in_word = 0;

    for (int i = 0; text[i]; i++) {
        if (isalpha(text[i])) {
            if (!in_word) {
                words++;
                in_word = 1;
            }
        } else {
            in_word = 0;
        }
    }
    return words;
}

int main() {
    char text[] = "Hello World! This is a sample text for analysis.";

    printf("원본: %s\n", text);

    // 시저 암호
    char encrypted[100];
    strcpy(encrypted, text);
    caesar_cipher(encrypted, 3);
    printf("암호화: %s\n", encrypted);

    // 빈도 분석
    char_frequency(text);

    // 단어 수
    printf("\n단어 수: %d\n", count_words(text));

    return 0;
}
```

## 반복문 성능 팁

### 기본 최적화

**1. 루프 밖으로 빼내기**
```c
// 비효율적
for (int i = 0; i < 1000; i++) {
    int limit = expensive_calculation();  // 매번 계산
    if (array[i] < limit) process(array[i]);
}

// 효율적
int limit = expensive_calculation();  // 한 번만 계산
for (int i = 0; i < 1000; i++) {
    if (array[i] < limit) process(array[i]);
}
```

**2. 메모리 연속 접근**
```c
// 비효율적: 열 우선 접근
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        matrix[j][i] = value;  // 비연속적
    }
}

// 효율적: 행 우선 접근
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        matrix[i][j] = value;  // 연속적
    }
}
```

**3. 조건 검사 최소화**
```c
// 비효율적: 매번 같은 조건 검사
for (int i = 0; i < size; i++) {
    if (flag) process_a(array[i]);
    else process_b(array[i]);
}

// 효율적: 조건을 루프 밖으로
if (flag) {
    for (int i = 0; i < size; i++) process_a(array[i]);
} else {
    for (int i = 0; i < size; i++) process_b(array[i]);
}
```

## 실전 예제

### 수학 계산 프로그램

```c
#include <stdio.h>

// π 근사값 계산
double calculate_pi(int n) {
    double pi = 0.0;
    int sign = 1;
    for (int i = 0; i < n; i++) {
        pi += sign * (1.0 / (2 * i + 1));
        sign *= -1;
    }
    return pi * 4;
}

// 팩토리얼 계산
long factorial(int n) {
    long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

// 소수 판정
int is_prime(int n) {
    if (n < 2) return 0;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return 0;
    }
    return 1;
}

int main() {
    printf("π ≈ %.6f\n", calculate_pi(100000));
    printf("10! = %ld\n", factorial(10));

    // 100 이하 소수 찾기
    printf("100 이하 소수: ");
    for (int i = 2; i <= 100; i++) {
        if (is_prime(i)) printf("%d ", i);
    }
    printf("\n");

    return 0;
}
```

### 간단한 데이터 분석

```c
#include <stdio.h>

void analyze_scores(int scores[], int size) {
    // 평균 계산
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += scores[i];
    }
    double average = (double)sum / size;

    // 최댓값, 최솟값
    int max = scores[0], min = scores[0];
    for (int i = 1; i < size; i++) {
        if (scores[i] > max) max = scores[i];
        if (scores[i] < min) min = scores[i];
    }

    // 등급 분류
    int grade_count[5] = {0}; // A, B, C, D, F
    for (int i = 0; i < size; i++) {
        if (scores[i] >= 90) grade_count[0]++;
        else if (scores[i] >= 80) grade_count[1]++;
        else if (scores[i] >= 70) grade_count[2]++;
        else if (scores[i] >= 60) grade_count[3]++;
        else grade_count[4]++;
    }

    printf("=== 성적 분석 ===\n");
    printf("평균: %.1f\n", average);
    printf("최고: %d, 최저: %d\n", max, min);
    printf("A:%d B:%d C:%d D:%d F:%d\n",
           grade_count[0], grade_count[1], grade_count[2],
           grade_count[3], grade_count[4]);
}

int main() {
    int scores[] = {95, 87, 92, 78, 85, 90, 76, 88, 94, 82};
    int size = sizeof(scores) / sizeof(scores[0]);

    analyze_scores(scores, size);
    return 0;
}
```

### 문자열 처리 예제

```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

// 시저 암호 (간단한 치환 암호)
void caesar_cipher(char *text, int shift) {
    for (int i = 0; text[i]; i++) {
        if (isalpha(text[i])) {
            char base = isupper(text[i]) ? 'A' : 'a';
            text[i] = ((text[i] - base + shift) % 26) + base;
        }
    }
}

// 문자 빈도 계산
void char_frequency(const char *text) {
    int freq[26] = {0};
    int total = 0;

    for (int i = 0; text[i]; i++) {
        if (isalpha(text[i])) {
            freq[toupper(text[i]) - 'A']++;
            total++;
        }
    }

    printf("=== 문자 빈도 ===\n");
    for (int i = 0; i < 26; i++) {
        if (freq[i] > 0) {
            printf("%c: %d번 (%.1f%%)\n",
                   'A' + i, freq[i], (100.0 * freq[i]) / total);
        }
    }
}

// 단어 개수 세기
int count_words(const char *text) {
    int words = 0;
    int in_word = 0;

    for (int i = 0; text[i]; i++) {
        if (isalpha(text[i])) {
            if (!in_word) {
                words++;
                in_word = 1;
            }
        } else {
            in_word = 0;
        }
    }
    return words;
}

int main() {
    char text[] = "Hello World! This is a sample text for analysis.";

    printf("원본: %s\n", text);

    // 시저 암호
    char encrypted[100];
    strcpy(encrypted, text);
    caesar_cipher(encrypted, 3);
    printf("암호화: %s\n", encrypted);

    // 빈도 분석
    char_frequency(text);

    // 단어 수
    printf("\n단어 수: %d\n", count_words(text));

    return 0;
}
```
    // 알파벳 초기화
    for (int i = 0; i < 26; i++) {
        key[i] = 'A' + i;
    }
    key[26] = '\0';

    // 피셔-예이츠 셔플
    for (int i = 25; i > 0; i--) {
        int j = rand() % (i + 1);
        char temp = key[i];
        key[i] = key[j];
        key[j] = temp;
    }
}

void substitution_cipher(char *text, const char *key, bool encrypt) {
    int len = strlen(text);

    for (int i = 0; i < len; i++) {
        if (isalpha(text[i])) {
            if (encrypt) {
                if (isupper(text[i])) {
                    text[i] = key[text[i] - 'A'];
                } else {
                    text[i] = tolower(key[text[i] - 'a']);
                }
            } else {
                // 복호화: 키에서 문자 위치 찾기
                for (int j = 0; j < 26; j++) {
                    if (toupper(text[i]) == key[j]) {
                        text[i] = isupper(text[i]) ? ('A' + j) : ('a' + j);
                        break;
                    }
                }
            }
        }
    }
}

// 문자 빈도 분석
void frequency_analysis(const char *text) {
    int freq[26] = {0};
    int total_letters = 0;

    for (int i = 0; text[i]; i++) {
        if (isalpha(text[i])) {
            freq[toupper(text[i]) - 'A']++;
            total_letters++;
        }
    }

    printf("\n=== 문자 빈도 분석 ===\n");
    printf("총 문자 수: %d\n\n", total_letters);

    // 빈도순으로 정렬하기 위한 구조체
    typedef struct {
        char letter;
        int count;
        double percentage;
    } LetterFreq;

    LetterFreq letters[26];
    for (int i = 0; i < 26; i++) {
        letters[i].letter = 'A' + i;
        letters[i].count = freq[i];
        letters[i].percentage = total_letters > 0 ? (100.0 * freq[i] / total_letters) : 0;
    }

    // 버블 정렬 (빈도 기준 내림차순)
    for (int i = 0; i < 25; i++) {
        for (int j = 0; j < 25 - i; j++) {
            if (letters[j].count < letters[j + 1].count) {
                LetterFreq temp = letters[j];
                letters[j] = letters[j + 1];
                letters[j + 1] = temp;
            }
        }
    }

    printf("문자  빈도  비율     그래프\n");
    printf("------------------------\n");

    for (int i = 0; i < 26 && letters[i].count > 0; i++) {
        printf(" %c   %4d  %5.1f%%  ",
               letters[i].letter, letters[i].count, letters[i].percentage);

        // 그래프 출력 (최대 20개 문자)
        int bar_length = (int)(letters[i].percentage / 2);
        for (int j = 0; j < bar_length; j++) {
            printf("█");
        }
        printf("\n");
    }
}

// 단어 개수 및 통계
void text_statistics(const char *text) {
    int chars = 0, words = 0, lines = 1, sentences = 0;
    bool in_word = false;

    for (int i = 0; text[i]; i++) {
        chars++;

        if (text[i] == '\n') {
            lines++;
            in_word = false;
        } else if (text[i] == ' ' || text[i] == '\t') {
            in_word = false;
        } else if (!in_word) {
            words++;
            in_word = true;
        }

        if (text[i] == '.' || text[i] == '!' || text[i] == '?') {
            sentences++;
        }
    }

    printf("\n=== 텍스트 통계 ===\n");
    printf("문자 수: %d\n", chars);
    printf("단어 수: %d\n", words);
    printf("문장 수: %d\n", sentences);
    printf("줄 수: %d\n", lines);

    if (words > 0) {
        printf("평균 단어 길이: %.1f\n", (double)chars / words);
    }
    if (sentences > 0) {
        printf("문장당 평균 단어 수: %.1f\n", (double)words / sentences);
    }
}

// ROT13 (특별한 시저 암호)
void rot13(char *text) {
    caesar_cipher(text, 13, true);
}

void text_crypto_tool() {
    char text[1000];
    char key[100];
    char substitution_key[27];
    int choice;

    srand(time(NULL));

    do {
        printf("\n=== 텍스트 처리 및 암호화 도구 ===\n");
        printf("1. 텍스트 입력\n");
        printf("2. 시저 암호 (암호화)\n");
        printf("3. 시저 암호 (복호화)\n");
        printf("4. 비제네르 암호 (암호화)\n");
        printf("5. 비제네르 암호 (복호화)\n");
        printf("6. 단순 치환 암호 (키 생성 및 암호화)\n");
        printf("7. 단순 치환 암호 (복호화)\n");
        printf("8. ROT13\n");
        printf("9. 문자 빈도 분석\n");
        printf("10. 텍스트 통계\n");
        printf("0. 종료\n");
        printf("선택: ");

        scanf("%d", &choice);
        getchar();  // 개행 문자 소비

        switch (choice) {
            case 1:
                printf("텍스트를 입력하세요:\n");
                fgets(text, sizeof(text), stdin);
                // 마지막 개행 문자 제거
                text[strcspn(text, "\n")] = 0;
                printf("입력된 텍스트: %s\n", text);
                break;

            case 2:
            case 3: {
                int shift;
                printf("이동 값을 입력하세요 (1-25): ");
                scanf("%d", &shift);

                char temp[1000];
                strcpy(temp, text);
                caesar_cipher(temp, shift, choice == 2);

                printf("결과: %s\n", temp);
                printf("원본으로 적용하시겠습니까? (y/n): ");

                char confirm;
                scanf(" %c", &confirm);
                if (confirm == 'y' || confirm == 'Y') {
                    strcpy(text, temp);
                }
                break;
            }

            case 4:
            case 5:
                printf("키를 입력하세요: ");
                scanf("%99s", key);

                char temp2[1000];
                strcpy(temp2, text);
                vigenere_cipher(temp2, key, choice == 4);

                printf("결과: %s\n", temp2);
                printf("원본으로 적용하시겠습니까? (y/n): ");

                char confirm2;
                scanf(" %c", &confirm2);
                if (confirm2 == 'y' || confirm2 == 'Y') {
                    strcpy(text, temp2);
                }
                break;

            case 6:
                generate_substitution_key(substitution_key);
                printf("생성된 치환 키: %s\n", substitution_key);

                char temp3[1000];
                strcpy(temp3, text);
                substitution_cipher(temp3, substitution_key, true);

                printf("암호화 결과: %s\n", temp3);
                printf("원본으로 적용하시겠습니까? (y/n): ");

                char confirm3;
                scanf(" %c", &confirm3);
                if (confirm3 == 'y' || confirm3 == 'Y') {
                    strcpy(text, temp3);
                }
                break;

            case 7:
                printf("복호화 키를 입력하세요: ");
                scanf("%26s", substitution_key);

                char temp4[1000];
                strcpy(temp4, text);
                substitution_cipher(temp4, substitution_key, false);

                printf("복호화 결과: %s\n", temp4);
                printf("원본으로 적용하시겠습니까? (y/n): ");

                char confirm4;
                scanf(" %c", &confirm4);
                if (confirm4 == 'y' || confirm4 == 'Y') {
                    strcpy(text, temp4);
                }
                break;

            case 8: {
                char temp5[1000];
                strcpy(temp5, text);
                rot13(temp5);

                printf("ROT13 결과: %s\n", temp5);
                printf("원본으로 적용하시겠습니까? (y/n): ");

                char confirm5;
                scanf(" %c", &confirm5);
                if (confirm5 == 'y' || confirm5 == 'Y') {
                    strcpy(text, temp5);
                }
                break;
            }

            case 9:
                frequency_analysis(text);
                break;

            case 10:
                text_statistics(text);
                break;

            case 0:
                printf("도구를 종료합니다.\n");
                break;

            default:
                printf("잘못된 선택입니다.\n");
                break;
        }
    } while (choice != 0);
}

int main() {
    int choice;

    do {
        printf("\n=== 반복문 실습 프로그램 ===\n");
        printf("1. 고급 수학 계산기\n");
        printf("2. 데이터 분석 도구\n");
        printf("3. 텍스트 처리 및 암호화 도구\n");
        printf("0. 종료\n");
        printf("선택: ");

        scanf("%d", &choice);

        switch (choice) {
            case 1:
                math_calculator();
                break;
            case 2:
                data_analysis_tool();
                break;
            case 3:
                text_crypto_tool();
                break;
            case 0:
                printf("프로그램을 종료합니다.\n");
                break;
            default:
                printf("잘못된 선택입니다.\n");
                break;
        }
    } while (choice != 0);

    return 0;
}
```

## 마무리

반복문은 프로그래밍에서 **반복적인 작업을 효율적으로 처리하는 핵심 도구**입니다. 단순한 카운팅부터 복잡한 알고리즘 구현까지, 반복문을 적절히 활용하면 강력하고 효율적인 프로그램을 작성할 수 있습니다.

**핵심 포인트:**

1. **적절한 반복문 선택**: for vs while vs do-while의 특성과 사용 시기
2. **루프 제어**: break와 continue를 이용한 효과적인 흐름 제어
3. **성능 최적화**: 루프 불변 조건, 강도 축소, 캐시 친화적 접근
4. **무한 루프 방지**: 종료 조건을 명확히 설정
5. **실전 응용**: 수학 계산, 데이터 처리, 텍스트 분석 등 다양한 도메인 활용

**실용적 조언:**

- 반복 횟수가 명확하면 for문, 조건 중심이면 while문을 사용하세요
- 최소 한 번은 실행되어야 하면 do-while문을 고려하세요
- 중첩 루프에서는 성능과 가독성을 함께 고려하세요
- 항상 루프의 종료 조건을 명확히 하여 무한 루프를 방지하세요
- 복잡한 반복문은 함수로 분리하여 가독성을 높이세요

반복문에 대한 깊은 이해는 알고리즘 구현, 데이터 처리, 수치 계산 등 프로그래밍의 핵심 영역에서 필수적이며, 효율적이고 우아한 코드 작성의 기초가 됩니다.