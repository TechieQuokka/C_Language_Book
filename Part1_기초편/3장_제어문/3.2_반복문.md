# 3.2 반복문 (Loop Statements)

## 반복문이란 무엇인가?

반복문은 **특정 조건이 만족되는 동안 코드 블록을 반복 실행하는 제어 구조**입니다. 이는 컴퓨터의 가장 강력한 특성 중 하나인 **무한 반복 능력**을 프로그래밍 언어로 표현하는 핵심 메커니즘입니다.

### 반복문의 본질적 의미

반복문이 없다면:
- 같은 작업을 수행하기 위해 동일한 코드를 수백, 수천 번 작성해야 함
- 데이터의 크기에 따라 프로그램 구조가 달라져야 함
- 동적인 처리가 불가능함

반복문을 통해:
- **코드 재사용**: 한 번 작성한 코드로 무수히 많은 작업 수행
- **동적 처리**: 런타임에 결정되는 횟수만큼 반복
- **효율성**: 메모리와 개발 시간 절약

### 반복문과 수학적 개념

반복문은 수학의 **수열, 급수, 점화식** 개념과 직접적으로 연결됩니다:

```c
// 등차수열의 합: S = n(a₁ + aₙ)/2
int arithmetic_sum(int first, int last, int step) {
    int sum = 0;
    for (int i = first; i <= last; i += step) {
        sum += i;
    }
    return sum;
}

// 피보나치 수열: F(n) = F(n-1) + F(n-2)
long fibonacci(int n) {
    if (n <= 1) return n;

    long prev = 0, curr = 1;
    for (int i = 2; i <= n; i++) {
        long next = prev + curr;
        prev = curr;
        curr = next;
    }
    return curr;
}
```

### 반복문과 하드웨어의 관계

CPU는 **반복을 위한 전용 명령어와 최적화 기능**을 제공합니다:

**1. 루프 언롤링 (Loop Unrolling)**
```c
// 원본 루프
for (int i = 0; i < 4; i++) {
    array[i] = i * 2;
}

// 컴파일러가 자동으로 언롤링
array[0] = 0 * 2;
array[1] = 1 * 2;
array[2] = 2 * 2;
array[3] = 3 * 2;
```

**2. 벡터화 (Vectorization)**
```c
// SIMD 명령어로 병렬 처리 가능
for (int i = 0; i < 1000; i++) {
    result[i] = a[i] + b[i];
}
```

**3. 분기 예측**
- 반복문의 조건은 일반적으로 예측 가능한 패턴을 가짐
- 현대 CPU는 루프의 반복 패턴을 학습하여 성능 최적화

## 반복의 기본 개념

### 반복문의 구성 요소

모든 반복문은 다음 세 가지 요소를 포함합니다:

1. **초기화 (Initialization)**: 반복을 시작하기 위한 준비
2. **조건 검사 (Condition)**: 반복을 계속할지 판단하는 조건
3. **갱신 (Update)**: 각 반복 후 상태를 변경

```c
// 일반적인 반복문 패턴
초기화;
while (조건) {
    // 반복할 작업
    갱신;
}
```

### 반복문의 종류와 특성

**1. 진입 조건 루프 (Entry-Controlled Loop)**
- `for`, `while`
- 루프 진입 전에 조건을 검사
- 조건이 처음부터 거짓이면 한 번도 실행되지 않음

**2. 탈출 조건 루프 (Exit-Controlled Loop)**
- `do-while`
- 루프 실행 후에 조건을 검사
- 최소 한 번은 실행됨

### 무한 루프와 루프 불변조건

**무한 루프 (Infinite Loop)**
```c
// 의도된 무한 루프
while (1) {
    // 서버의 메인 루프
    process_requests();
    if (should_shutdown()) break;
}

// 실수로 만든 무한 루프
int i = 0;
while (i < 10) {
    printf("%d\n", i);
    // i++; 를 빼먹음!
}
```

**루프 불변조건 (Loop Invariant)**
루프 실행 중 항상 참이 되는 조건:

```c
// 배열에서 최댓값 찾기
int find_max(int arr[], int size) {
    int max = arr[0];  // 불변조건: max는 지금까지 본 값 중 최댓값

    for (int i = 1; i < size; i++) {
        if (arr[i] > max) {
            max = arr[i];  // 불변조건 유지
        }
        // 불변조건: max >= arr[j] for all j < i
    }

    return max;
}
```

## for 문

### for 문의 기본 구조

```c
for (초기화; 조건; 갱신) {
    // 반복할 코드
}
```

for 문은 **반복 횟수가 명확할 때** 가장 적합한 반복문입니다.

### for 문의 실행 순서

```c
for (int i = 0; i < 10; i++) {
    printf("%d ", i);
}
```

**실행 순서:**
1. `int i = 0` (초기화, 한 번만 실행)
2. `i < 10` (조건 검사)
3. 조건이 참이면 루프 본문 실행
4. `i++` (갱신)
5. 2번으로 돌아가서 반복

### 기본 for 문 예제

**1. 기본 카운팅**
```c
#include <stdio.h>

int main() {
    // 1부터 10까지 출력
    for (int i = 1; i <= 10; i++) {
        printf("%d ", i);
    }
    printf("\n");

    // 10부터 1까지 출력
    for (int i = 10; i >= 1; i--) {
        printf("%d ", i);
    }
    printf("\n");

    // 짝수만 출력
    for (int i = 2; i <= 20; i += 2) {
        printf("%d ", i);
    }
    printf("\n");

    return 0;
}
```

**2. 팩토리얼 계산**
```c
#include <stdio.h>

long long factorial(int n) {
    long long result = 1;

    for (int i = 1; i <= n; i++) {
        result *= i;
    }

    return result;
}

int main() {
    for (int i = 0; i <= 10; i++) {
        printf("%d! = %lld\n", i, factorial(i));
    }
    return 0;
}
```

**3. 구구단**
```c
#include <stdio.h>

void print_multiplication_table() {
    printf("=== 구구단 ===\n");

    for (int dan = 2; dan <= 9; dan++) {
        printf("\n[%d단]\n", dan);
        for (int i = 1; i <= 9; i++) {
            printf("%d × %d = %2d\n", dan, i, dan * i);
        }
    }
}

// 가로로 출력하는 버전
void print_multiplication_table_horizontal() {
    printf("=== 구구단 (가로) ===\n");

    for (int i = 1; i <= 9; i++) {
        for (int dan = 2; dan <= 9; dan++) {
            printf("%d×%d=%2d  ", dan, i, dan * i);
        }
        printf("\n");
    }
}
```

### 중첩된 for 문

중첩된 for 문은 **다차원 구조의 처리**에 필수적입니다:

**1. 2차원 배열 처리**
```c
#include <stdio.h>

void initialize_matrix(int matrix[3][3]) {
    int value = 1;

    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 3; col++) {
            matrix[row][col] = value++;
        }
    }
}

void print_matrix(int matrix[3][3]) {
    printf("매트릭스:\n");
    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 3; col++) {
            printf("%3d ", matrix[row][col]);
        }
        printf("\n");
    }
}

void matrix_multiply(int a[3][3], int b[3][3], int result[3][3]) {
    // 행렬 곱셈: C[i][j] = Σ(A[i][k] * B[k][j])
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            result[i][j] = 0;
            for (int k = 0; k < 3; k++) {
                result[i][j] += a[i][k] * b[k][j];
            }
        }
    }
}
```

**2. 패턴 출력**
```c
#include <stdio.h>

void print_triangle_pattern() {
    printf("삼각형 패턴:\n");
    for (int i = 1; i <= 5; i++) {
        for (int j = 1; j <= i; j++) {
            printf("* ");
        }
        printf("\n");
    }
}

void print_diamond_pattern() {
    printf("다이아몬드 패턴:\n");
    int n = 5;

    // 상단 부분
    for (int i = 1; i <= n; i++) {
        // 공백 출력
        for (int j = 1; j <= n - i; j++) {
            printf(" ");
        }
        // 별 출력
        for (int j = 1; j <= 2 * i - 1; j++) {
            printf("*");
        }
        printf("\n");
    }

    // 하단 부분
    for (int i = n - 1; i >= 1; i--) {
        // 공백 출력
        for (int j = 1; j <= n - i; j++) {
            printf(" ");
        }
        // 별 출력
        for (int j = 1; j <= 2 * i - 1; j++) {
            printf("*");
        }
        printf("\n");
    }
}
```

**3. 소수 찾기 (에라토스테네스의 체)**
```c
#include <stdio.h>
#include <stdbool.h>

void sieve_of_eratosthenes(int limit) {
    bool is_prime[1001] = {false};  // 0으로 초기화

    // 2부터 limit까지를 소수로 가정
    for (int i = 2; i <= limit; i++) {
        is_prime[i] = true;
    }

    // 에라토스테네스의 체 알고리즘
    for (int i = 2; i * i <= limit; i++) {
        if (is_prime[i]) {
            // i의 배수들을 모두 제거
            for (int j = i * i; j <= limit; j += i) {
                is_prime[j] = false;
            }
        }
    }

    // 소수 출력
    printf("%d 이하의 소수:\n", limit);
    int count = 0;
    for (int i = 2; i <= limit; i++) {
        if (is_prime[i]) {
            printf("%4d", i);
            count++;
            if (count % 10 == 0) printf("\n");
        }
    }
    printf("\n총 %d개의 소수\n", count);
}
```

### for 문의 고급 활용

**1. 빈 구성 요소 활용**
```c
// 초기화 생략
int i = 0;
for (; i < 10; i++) {
    printf("%d ", i);
}

// 갱신 생략 (본문에서 처리)
for (int i = 0; i < 10;) {
    printf("%d ", i);
    i += 2;  // 본문에서 갱신
}

// 무한 루프
for (;;) {
    // 무한 반복
    if (some_condition) break;
}
```

**2. 여러 변수 사용**
```c
// 여러 변수 초기화 및 갱신
for (int i = 0, j = 10; i < j; i++, j--) {
    printf("i=%d, j=%d\n", i, j);
}

// 배열 두 개 동시 순회
int arr1[] = {1, 2, 3, 4, 5};
int arr2[] = {10, 20, 30, 40, 50};

for (int i = 0; i < 5; i++) {
    printf("arr1[%d]=%d, arr2[%d]=%d\n", i, arr1[i], i, arr2[i]);
}
```

**3. 포인터를 이용한 배열 순회**
```c
#include <stdio.h>

void traverse_array_with_pointer() {
    int numbers[] = {10, 20, 30, 40, 50};
    size_t size = sizeof(numbers) / sizeof(numbers[0]);

    // 포인터를 이용한 순회
    for (int *ptr = numbers; ptr < numbers + size; ptr++) {
        printf("%d ", *ptr);
    }
    printf("\n");

    // 역순 순회
    for (int *ptr = numbers + size - 1; ptr >= numbers; ptr--) {
        printf("%d ", *ptr);
    }
    printf("\n");
}
```

## while 문

### while 문의 기본 구조

```c
while (조건) {
    // 반복할 코드
    // 조건을 변경하는 코드가 있어야 함
}
```

while 문은 **조건이 참인 동안 계속 반복**하며, 반복 횟수가 미리 정해지지 않은 경우에 적합합니다.

### while 문의 기본 예제

**1. 입력 받기 계속하기**
```c
#include <stdio.h>

int main() {
    int number;
    int sum = 0;

    printf("정수를 입력하세요 (0을 입력하면 종료):\n");

    while (scanf("%d", &number) == 1 && number != 0) {
        sum += number;
        printf("현재 합계: %d\n", sum);
        printf("다음 정수를 입력하세요: ");
    }

    printf("최종 합계: %d\n", sum);
    return 0;
}
```

**2. 자릿수 계산**
```c
#include <stdio.h>

int count_digits(int number) {
    if (number == 0) return 1;

    int count = 0;
    number = number < 0 ? -number : number;  // 음수 처리

    while (number > 0) {
        number /= 10;
        count++;
    }

    return count;
}

void print_digits_reverse(int number) {
    printf("%d의 각 자릿수 (역순): ", number);

    number = number < 0 ? -number : number;  // 음수 처리

    if (number == 0) {
        printf("0");
    } else {
        while (number > 0) {
            printf("%d ", number % 10);
            number /= 10;
        }
    }
    printf("\n");
}
```

**3. 최대공약수와 최소공배수**
```c
#include <stdio.h>

// 유클리드 호제법을 이용한 최대공약수
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// 최소공배수
int lcm(int a, int b) {
    return (a * b) / gcd(a, b);
}

int main() {
    int num1, num2;

    printf("두 정수를 입력하세요: ");
    scanf("%d %d", &num1, &num2);

    int greatest = gcd(num1, num2);
    int least = lcm(num1, num2);

    printf("최대공약수: %d\n", greatest);
    printf("최소공배수: %d\n", least);

    return 0;
}
```

### while 문과 입력 검증

**1. 범위 체크가 있는 입력**
```c
#include <stdio.h>

int get_valid_input(int min, int max, const char *prompt) {
    int value;

    while (1) {
        printf("%s (%d~%d): ", prompt, min, max);

        if (scanf("%d", &value) != 1) {
            printf("잘못된 입력입니다. 숫자를 입력하세요.\n");
            // 입력 버퍼 비우기
            while (getchar() != '\n');
            continue;
        }

        if (value >= min && value <= max) {
            return value;
        }

        printf("범위를 벗어났습니다. %d부터 %d 사이의 값을 입력하세요.\n", min, max);
    }
}

int main() {
    int age = get_valid_input(0, 150, "나이를 입력하세요");
    int score = get_valid_input(0, 100, "점수를 입력하세요");

    printf("나이: %d, 점수: %d\n", age, score);
    return 0;
}
```

**2. 메뉴 시스템**
```c
#include <stdio.h>
#include <stdbool.h>

void display_menu() {
    printf("\n=== 간단한 계산기 ===\n");
    printf("1. 덧셈\n");
    printf("2. 뺄셈\n");
    printf("3. 곱셈\n");
    printf("4. 나눗셈\n");
    printf("5. 종료\n");
    printf("선택: ");
}

double get_number(const char *prompt) {
    double number;
    while (1) {
        printf("%s", prompt);
        if (scanf("%lf", &number) == 1) {
            return number;
        }
        printf("잘못된 입력입니다. 숫자를 입력하세요.\n");
        while (getchar() != '\n');
    }
}

int main() {
    int choice;
    bool running = true;

    while (running) {
        display_menu();

        if (scanf("%d", &choice) != 1) {
            printf("잘못된 입력입니다.\n");
            while (getchar() != '\n');
            continue;
        }

        switch (choice) {
            case 1: {
                double a = get_number("첫 번째 수: ");
                double b = get_number("두 번째 수: ");
                printf("결과: %.2f + %.2f = %.2f\n", a, b, a + b);
                break;
            }
            case 2: {
                double a = get_number("첫 번째 수: ");
                double b = get_number("두 번째 수: ");
                printf("결과: %.2f - %.2f = %.2f\n", a, b, a - b);
                break;
            }
            case 3: {
                double a = get_number("첫 번째 수: ");
                double b = get_number("두 번째 수: ");
                printf("결과: %.2f × %.2f = %.2f\n", a, b, a * b);
                break;
            }
            case 4: {
                double a = get_number("첫 번째 수: ");
                double b = get_number("두 번째 수: ");
                if (b != 0) {
                    printf("결과: %.2f ÷ %.2f = %.2f\n", a, b, a / b);
                } else {
                    printf("0으로 나눌 수 없습니다.\n");
                }
                break;
            }
            case 5:
                printf("계산기를 종료합니다.\n");
                running = false;
                break;
            default:
                printf("잘못된 선택입니다. 1-5 사이의 숫자를 입력하세요.\n");
                break;
        }
    }

    return 0;
}
```

### while 문과 파일 처리

**1. 파일 읽기**
```c
#include <stdio.h>
#include <stdlib.h>

void count_file_statistics(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("파일을 열 수 없습니다: %s\n", filename);
        return;
    }

    int ch;
    int lines = 0, words = 0, chars = 0;
    bool in_word = false;

    while ((ch = fgetc(file)) != EOF) {
        chars++;

        if (ch == '\n') {
            lines++;
            in_word = false;
        } else if (ch == ' ' || ch == '\t') {
            in_word = false;
        } else if (!in_word) {
            words++;
            in_word = true;
        }
    }

    fclose(file);

    printf("파일 통계: %s\n", filename);
    printf("문자 수: %d\n", chars);
    printf("단어 수: %d\n", words);
    printf("줄 수: %d\n", lines);
}

void copy_file(const char *source, const char *destination) {
    FILE *src = fopen(source, "r");
    FILE *dst = fopen(destination, "w");

    if (src == NULL || dst == NULL) {
        printf("파일 열기 실패\n");
        if (src) fclose(src);
        if (dst) fclose(dst);
        return;
    }

    int ch;
    while ((ch = fgetc(src)) != EOF) {
        fputc(ch, dst);
    }

    fclose(src);
    fclose(dst);
    printf("파일 복사 완료: %s -> %s\n", source, destination);
}
```

## do-while 문

### do-while 문의 기본 구조

```c
do {
    // 반복할 코드
} while (조건);
```

do-while 문은 **최소 한 번은 실행되어야 하는 경우**에 사용합니다.

### do-while 문의 특징

**while vs do-while 비교:**
```c
// while: 조건이 거짓이면 한 번도 실행되지 않음
int i = 10;
while (i < 5) {
    printf("while: %d\n", i);  // 출력되지 않음
    i++;
}

// do-while: 최소 한 번은 실행됨
int j = 10;
do {
    printf("do-while: %d\n", j);  // 한 번 출력됨
    j++;
} while (j < 5);
```

### do-while 문 실용 예제

**1. 메뉴 시스템 (최소 한 번은 메뉴 표시)**
```c
#include <stdio.h>

int main() {
    int choice;

    do {
        printf("\n=== 메뉴 ===\n");
        printf("1. 옵션 1\n");
        printf("2. 옵션 2\n");
        printf("3. 옵션 3\n");
        printf("0. 종료\n");
        printf("선택: ");

        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("옵션 1을 선택했습니다.\n");
                break;
            case 2:
                printf("옵션 2를 선택했습니다.\n");
                break;
            case 3:
                printf("옵션 3을 선택했습니다.\n");
                break;
            case 0:
                printf("프로그램을 종료합니다.\n");
                break;
            default:
                printf("잘못된 선택입니다.\n");
                break;
        }
    } while (choice != 0);

    return 0;
}
```

**2. 게임의 재시작 기능**
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void number_guessing_game() {
    int secret, guess, attempts;
    char play_again;

    srand(time(NULL));

    do {
        secret = rand() % 100 + 1;  // 1-100 사이의 랜덤 수
        attempts = 0;

        printf("\n=== 숫자 맞히기 게임 ===\n");
        printf("1부터 100 사이의 숫자를 맞혀보세요!\n");

        do {
            printf("추측: ");
            scanf("%d", &guess);
            attempts++;

            if (guess < secret) {
                printf("더 큰 수입니다.\n");
            } else if (guess > secret) {
                printf("더 작은 수입니다.\n");
            } else {
                printf("정답입니다! %d번 만에 맞혔습니다.\n", attempts);
            }
        } while (guess != secret);

        printf("다시 하시겠습니까? (y/n): ");
        scanf(" %c", &play_again);

    } while (play_again == 'y' || play_again == 'Y');

    printf("게임을 종료합니다.\n");
}
```

**3. 입력 검증 (반드시 유효한 입력을 받을 때까지)**
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

void get_valid_password(char *password, size_t size) {
    bool valid;

    do {
        valid = true;
        printf("비밀번호를 입력하세요 (8자 이상, 대소문자+숫자 포함): ");
        scanf("%49s", password);

        // 길이 검사
        if (strlen(password) < 8) {
            printf("비밀번호는 8자 이상이어야 합니다.\n");
            valid = false;
            continue;
        }

        // 대문자, 소문자, 숫자 포함 검사
        bool has_upper = false, has_lower = false, has_digit = false;

        for (int i = 0; password[i]; i++) {
            if (isupper(password[i])) has_upper = true;
            else if (islower(password[i])) has_lower = true;
            else if (isdigit(password[i])) has_digit = true;
        }

        if (!has_upper || !has_lower || !has_digit) {
            printf("비밀번호는 대문자, 소문자, 숫자를 모두 포함해야 합니다.\n");
            valid = false;
        }

    } while (!valid);

    printf("유효한 비밀번호가 설정되었습니다.\n");
}
```

## 반복문 제어: break와 continue

### break 문

break 문은 **반복문을 즉시 종료**하고 반복문 다음 문장으로 제어를 이동시킵니다.

**기본 사용법:**
```c
#include <stdio.h>

int main() {
    // 특정 조건에서 루프 탈출
    for (int i = 1; i <= 10; i++) {
        if (i == 6) {
            printf("6에서 루프를 종료합니다.\n");
            break;
        }
        printf("%d ", i);
    }
    printf("\n루프 종료 후\n");

    return 0;
}
// 출력: 1 2 3 4 5 6에서 루프를 종료합니다.
//       루프 종료 후
```

**실용적인 break 활용:**

**1. 검색에서 찾으면 중단**
```c
#include <stdio.h>

int linear_search(int arr[], int size, int target) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == target) {
            return i;  // 찾으면 즉시 반환
        }
    }
    return -1;  // 찾지 못함
}

// break를 사용한 버전
int linear_search_with_break(int arr[], int size, int target) {
    int index = -1;

    for (int i = 0; i < size; i++) {
        if (arr[i] == target) {
            index = i;
            break;  // 찾으면 즉시 종료
        }
    }

    return index;
}
```

**2. 중첩 루프에서의 break**
```c
#include <stdio.h>

// 2차원 배열에서 특정 값 찾기
void find_in_matrix(int matrix[3][3], int target) {
    bool found = false;

    for (int i = 0; i < 3 && !found; i++) {
        for (int j = 0; j < 3; j++) {
            if (matrix[i][j] == target) {
                printf("%d를 (%d, %d)에서 찾았습니다.\n", target, i, j);
                found = true;
                break;  // 안쪽 루프만 종료
            }
        }
    }

    if (!found) {
        printf("%d를 찾지 못했습니다.\n", target);
    }
}

// goto를 사용한 다중 루프 탈출 (권장하지 않음)
void find_in_matrix_goto(int matrix[3][3], int target) {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (matrix[i][j] == target) {
                printf("%d를 (%d, %d)에서 찾았습니다.\n", target, i, j);
                goto found;  // 모든 루프 탈출
            }
        }
    }
    printf("%d를 찾지 못했습니다.\n", target);
    return;

found:
    printf("검색 완료\n");
}
```

**3. 안전한 입력 루프**
```c
#include <stdio.h>

int get_positive_integer() {
    int value;

    while (1) {  // 무한 루프
        printf("양의 정수를 입력하세요: ");

        if (scanf("%d", &value) != 1) {
            printf("잘못된 입력입니다.\n");
            while (getchar() != '\n');  // 버퍼 비우기
            continue;
        }

        if (value > 0) {
            break;  // 유효한 입력이면 루프 탈출
        }

        printf("0보다 큰 수를 입력하세요.\n");
    }

    return value;
}
```

### continue 문

continue 문은 **현재 반복의 나머지 부분을 건너뛰고** 다음 반복으로 이동합니다.

**기본 사용법:**
```c
#include <stdio.h>

int main() {
    // 홀수만 출력 (짝수는 건너뛰기)
    for (int i = 1; i <= 10; i++) {
        if (i % 2 == 0) {
            continue;  // 짝수면 아래 코드 건너뛰고 다음 반복
        }
        printf("%d ", i);
    }
    printf("\n");

    return 0;
}
// 출력: 1 3 5 7 9
```

**실용적인 continue 활용:**

**1. 조건부 처리**
```c
#include <stdio.h>
#include <ctype.h>

void process_characters(const char *str) {
    printf("문자열의 알파벳만 처리:\n");

    for (int i = 0; str[i]; i++) {
        // 알파벳이 아니면 건너뛰기
        if (!isalpha(str[i])) {
            continue;
        }

        printf("%c -> %c\n", str[i], toupper(str[i]));
    }
}

int main() {
    const char *text = "Hello, World! 123";
    process_characters(text);
    return 0;
}
```

**2. 배열에서 유효한 값만 처리**
```c
#include <stdio.h>

double calculate_average_positive(double arr[], int size) {
    double sum = 0.0;
    int count = 0;

    for (int i = 0; i < size; i++) {
        // 음수나 0은 건너뛰기
        if (arr[i] <= 0) {
            continue;
        }

        sum += arr[i];
        count++;
    }

    return count > 0 ? sum / count : 0.0;
}

void print_valid_scores(int scores[], int size) {
    printf("유효한 점수들 (0-100):\n");

    for (int i = 0; i < size; i++) {
        // 범위를 벗어난 점수는 건너뛰기
        if (scores[i] < 0 || scores[i] > 100) {
            continue;
        }

        printf("학생 %d: %d점\n", i + 1, scores[i]);
    }
}
```

**3. 파일 처리에서 빈 줄 건너뛰기**
```c
#include <stdio.h>
#include <string.h>

void process_config_file(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("파일을 열 수 없습니다: %s\n", filename);
        return;
    }

    char line[256];
    int line_number = 0;

    while (fgets(line, sizeof(line), file)) {
        line_number++;

        // 빈 줄이나 주석 줄은 건너뛰기
        if (line[0] == '\n' || line[0] == '#') {
            continue;
        }

        // 앞뒤 공백 제거 후 빈 줄 체크
        char *start = line;
        while (*start == ' ' || *start == '\t') start++;

        if (*start == '\n' || *start == '\0') {
            continue;  // 공백만 있는 줄
        }

        printf("라인 %d: %s", line_number, start);
    }

    fclose(file);
}
```

### break vs continue vs return

**비교 예제:**
```c
#include <stdio.h>

void demonstrate_control_statements() {
    printf("=== break 예제 ===\n");
    for (int i = 1; i <= 5; i++) {
        if (i == 3) {
            printf("break at %d\n", i);
            break;  // 루프 완전 종료
        }
        printf("%d ", i);
    }
    printf("after break loop\n\n");

    printf("=== continue 예제 ===\n");
    for (int i = 1; i <= 5; i++) {
        if (i == 3) {
            printf("skip %d\n", i);
            continue;  // 현재 반복만 건너뛰기
        }
        printf("%d ", i);
    }
    printf("after continue loop\n\n");

    printf("=== return 예제 ===\n");
    for (int i = 1; i <= 5; i++) {
        if (i == 3) {
            printf("return at %d\n", i);
            return;  // 함수 완전 종료
        }
        printf("%d ", i);
    }
    printf("이 줄은 실행되지 않음\n");
}
```

## 반복문 최적화와 성능

### 루프 최적화 기법

**1. 루프 불변 코드 이동 (Loop Invariant Code Motion)**
```c
// 비효율적인 코드
for (int i = 0; i < 1000; i++) {
    int limit = calculate_expensive_limit();  // 매번 계산
    if (array[i] < limit) {
        process(array[i]);
    }
}

// 최적화된 코드
int limit = calculate_expensive_limit();  // 한 번만 계산
for (int i = 0; i < 1000; i++) {
    if (array[i] < limit) {
        process(array[i]);
    }
}
```

**2. 강도 축소 (Strength Reduction)**
```c
// 비효율적인 코드 (곱셈 사용)
for (int i = 0; i < 100; i++) {
    array[i] = i * 5;
}

// 최적화된 코드 (덧셈 사용)
int value = 0;
for (int i = 0; i < 100; i++) {
    array[i] = value;
    value += 5;
}
```

**3. 루프 언롤링 (Loop Unrolling)**
```c
// 원본 루프
for (int i = 0; i < 1000; i++) {
    sum += array[i];
}

// 부분 언롤링 (4배수 처리)
int i;
for (i = 0; i < 1000 - 3; i += 4) {
    sum += array[i] + array[i+1] + array[i+2] + array[i+3];
}
// 나머지 처리
for (; i < 1000; i++) {
    sum += array[i];
}
```

**4. 루프 융합 (Loop Fusion)**
```c
// 분리된 루프들
for (int i = 0; i < size; i++) {
    a[i] = b[i] + c[i];
}
for (int i = 0; i < size; i++) {
    d[i] = a[i] * 2;
}

// 융합된 루프
for (int i = 0; i < size; i++) {
    a[i] = b[i] + c[i];
    d[i] = a[i] * 2;
}
```

### 메모리 접근 패턴 최적화

**1. 캐시 친화적 접근 (Cache-Friendly Access)**
```c
#define SIZE 1000

// 비효율적: 열 우선 접근 (캐시 미스 많음)
void matrix_multiply_bad(int a[SIZE][SIZE], int b[SIZE][SIZE], int c[SIZE][SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            for (int k = 0; k < SIZE; k++) {
                c[i][j] += a[i][k] * b[k][j];  // b[k][j]가 비연속적
            }
        }
    }
}

// 효율적: 행 우선 접근 + 루프 순서 변경
void matrix_multiply_good(int a[SIZE][SIZE], int b[SIZE][SIZE], int c[SIZE][SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int k = 0; k < SIZE; k++) {
            for (int j = 0; j < SIZE; j++) {
                c[i][j] += a[i][k] * b[k][j];  // 연속적인 메모리 접근
            }
        }
    }
}
```

**2. 블록화 (Blocking/Tiling)**
```c
#define BLOCK_SIZE 64

void matrix_multiply_blocked(int a[SIZE][SIZE], int b[SIZE][SIZE], int c[SIZE][SIZE]) {
    for (int ii = 0; ii < SIZE; ii += BLOCK_SIZE) {
        for (int jj = 0; jj < SIZE; jj += BLOCK_SIZE) {
            for (int kk = 0; kk < SIZE; kk += BLOCK_SIZE) {
                // 블록 단위로 처리
                for (int i = ii; i < ii + BLOCK_SIZE && i < SIZE; i++) {
                    for (int j = jj; j < jj + BLOCK_SIZE && j < SIZE; j++) {
                        for (int k = kk; k < kk + BLOCK_SIZE && k < SIZE; k++) {
                            c[i][j] += a[i][k] * b[k][j];
                        }
                    }
                }
            }
        }
    }
}
```

### 컴파일러 최적화 힌트

**1. restrict 키워드 사용**
```c
// 포인터 앨리어싱 방지
void vector_add(int * restrict a, int * restrict b, int * restrict c, int n) {
    for (int i = 0; i < n; i++) {
        c[i] = a[i] + b[i];  // 컴파일러가 벡터화 최적화 가능
    }
}
```

**2. 프래그마 지시어 활용**
```c
#include <stdio.h>

void optimized_loop(float *a, float *b, float *c, int n) {
    #pragma omp simd  // OpenMP SIMD 지시어
    for (int i = 0; i < n; i++) {
        c[i] = a[i] + b[i];
    }
}

void unroll_hint_loop(int *arr, int n) {
    #pragma unroll 4  // 컴파일러에게 4배 언롤링 힌트
    for (int i = 0; i < n; i++) {
        arr[i] *= 2;
    }
}
```

## 반복문 활용 실습

### 실습 1: 고급 수학 계산기

```c
#include <stdio.h>
#include <math.h>
#include <stdbool.h>

// 수렴하는 급수를 이용한 π 계산 (라이프니츠 공식)
double calculate_pi(int iterations) {
    double pi = 0.0;
    int sign = 1;

    for (int i = 0; i < iterations; i++) {
        pi += sign * (1.0 / (2 * i + 1));
        sign *= -1;
    }

    return pi * 4;
}

// 테일러 급수를 이용한 sin(x) 계산
double calculate_sin(double x, int terms) {
    double result = 0.0;
    double term = x;  // 첫 번째 항

    for (int i = 0; i < terms; i++) {
        result += term;
        // 다음 항 계산: x^(2n+1) / (2n+1)! 에서 x^(2n+3) / (2n+3)!
        term *= -x * x / ((2 * i + 2) * (2 * i + 3));
    }

    return result;
}

// 뉴턴-랩슨 방법으로 제곱근 계산
double calculate_sqrt(double number, double precision) {
    if (number < 0) return -1;  // 음수는 처리하지 않음
    if (number == 0) return 0;

    double guess = number / 2;  // 초기 추정값

    while (1) {
        double new_guess = (guess + number / guess) / 2;

        if (fabs(new_guess - guess) < precision) {
            return new_guess;
        }

        guess = new_guess;
    }
}

// 소인수분해
void prime_factorization(int number) {
    printf("%d의 소인수분해: ", number);

    bool first = true;

    // 2로 나누기
    while (number % 2 == 0) {
        if (!first) printf(" × ");
        printf("2");
        first = false;
        number /= 2;
    }

    // 3부터 홀수로 나누기
    for (int i = 3; i * i <= number; i += 2) {
        while (number % i == 0) {
            if (!first) printf(" × ");
            printf("%d", i);
            first = false;
            number /= i;
        }
    }

    // 남은 수가 소수인 경우
    if (number > 2) {
        if (!first) printf(" × ");
        printf("%d", number);
    }

    printf("\n");
}

// 최대공약수와 최소공배수 (확장 유클리드 호제법)
int extended_gcd(int a, int b, int *x, int *y) {
    if (b == 0) {
        *x = 1;
        *y = 0;
        return a;
    }

    int x1, y1;
    int gcd = extended_gcd(b, a % b, &x1, &y1);

    *x = y1;
    *y = x1 - (a / b) * y1;

    return gcd;
}

void math_calculator() {
    int choice;

    do {
        printf("\n=== 고급 수학 계산기 ===\n");
        printf("1. π 근사값 계산\n");
        printf("2. sin(x) 계산\n");
        printf("3. 제곱근 계산\n");
        printf("4. 소인수분해\n");
        printf("5. 최대공약수/최소공배수\n");
        printf("0. 종료\n");
        printf("선택: ");

        scanf("%d", &choice);

        switch (choice) {
            case 1: {
                int iterations;
                printf("반복 횟수 입력: ");
                scanf("%d", &iterations);

                double pi = calculate_pi(iterations);
                printf("π ≈ %.10f (정확한 값: %.10f)\n", pi, M_PI);
                printf("오차: %.2e\n", fabs(pi - M_PI));
                break;
            }

            case 2: {
                double x;
                int terms;
                printf("각도(라디안)와 항의 개수 입력: ");
                scanf("%lf %d", &x, &terms);

                double my_sin = calculate_sin(x, terms);
                double lib_sin = sin(x);
                printf("계산된 sin(%.3f) = %.10f\n", x, my_sin);
                printf("라이브러리 sin(%.3f) = %.10f\n", x, lib_sin);
                printf("오차: %.2e\n", fabs(my_sin - lib_sin));
                break;
            }

            case 3: {
                double number;
                printf("제곱근을 구할 수 입력: ");
                scanf("%lf", &number);

                double my_sqrt = calculate_sqrt(number, 1e-10);
                double lib_sqrt = sqrt(number);
                printf("계산된 √%.3f = %.10f\n", number, my_sqrt);
                printf("라이브러리 √%.3f = %.10f\n", number, lib_sqrt);
                printf("오차: %.2e\n", fabs(my_sqrt - lib_sqrt));
                break;
            }

            case 4: {
                int number;
                printf("소인수분해할 수 입력: ");
                scanf("%d", &number);

                if (number <= 1) {
                    printf("1보다 큰 수를 입력하세요.\n");
                } else {
                    prime_factorization(number);
                }
                break;
            }

            case 5: {
                int a, b;
                printf("두 정수 입력: ");
                scanf("%d %d", &a, &b);

                int x, y;
                int gcd = extended_gcd(a, b, &x, &y);
                int lcm = (a * b) / gcd;

                printf("최대공약수: %d\n", gcd);
                printf("최소공배수: %d\n", lcm);
                printf("베주 등식: %d × %d + %d × %d = %d\n", a, x, b, y, gcd);
                break;
            }

            case 0:
                printf("계산기를 종료합니다.\n");
                break;

            default:
                printf("잘못된 선택입니다.\n");
                break;
        }
    } while (choice != 0);
}
```

### 실습 2: 데이터 분석 도구

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <stdbool.h>

#define MAX_DATA 1000

typedef struct {
    double *data;
    int count;
    int capacity;
} DataSet;

DataSet* create_dataset(int initial_capacity) {
    DataSet *ds = malloc(sizeof(DataSet));
    ds->data = malloc(sizeof(double) * initial_capacity);
    ds->count = 0;
    ds->capacity = initial_capacity;
    return ds;
}

void free_dataset(DataSet *ds) {
    free(ds->data);
    free(ds);
}

void add_data(DataSet *ds, double value) {
    if (ds->count >= ds->capacity) {
        ds->capacity *= 2;
        ds->data = realloc(ds->data, sizeof(double) * ds->capacity);
    }
    ds->data[ds->count++] = value;
}

// 버블 정렬 (교육용)
void bubble_sort(double arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                double temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// 기본 통계량 계산
void calculate_basic_stats(DataSet *ds) {
    if (ds->count == 0) {
        printf("데이터가 없습니다.\n");
        return;
    }

    // 평균
    double sum = 0;
    for (int i = 0; i < ds->count; i++) {
        sum += ds->data[i];
    }
    double mean = sum / ds->count;

    // 분산과 표준편차
    double variance_sum = 0;
    for (int i = 0; i < ds->count; i++) {
        double diff = ds->data[i] - mean;
        variance_sum += diff * diff;
    }
    double variance = variance_sum / ds->count;
    double std_dev = sqrt(variance);

    // 중앙값 계산을 위한 정렬
    double *sorted_data = malloc(sizeof(double) * ds->count);
    for (int i = 0; i < ds->count; i++) {
        sorted_data[i] = ds->data[i];
    }
    bubble_sort(sorted_data, ds->count);

    double median;
    if (ds->count % 2 == 0) {
        median = (sorted_data[ds->count/2 - 1] + sorted_data[ds->count/2]) / 2;
    } else {
        median = sorted_data[ds->count/2];
    }

    // 최댓값, 최솟값
    double min = sorted_data[0];
    double max = sorted_data[ds->count - 1];

    printf("\n=== 기본 통계량 ===\n");
    printf("데이터 개수: %d\n", ds->count);
    printf("평균: %.4f\n", mean);
    printf("중앙값: %.4f\n", median);
    printf("최솟값: %.4f\n", min);
    printf("최댓값: %.4f\n", max);
    printf("분산: %.4f\n", variance);
    printf("표준편차: %.4f\n", std_dev);

    free(sorted_data);
}

// 히스토그램 출력
void print_histogram(DataSet *ds, int bins) {
    if (ds->count == 0) return;

    // 최댓값, 최솟값 찾기
    double min = ds->data[0], max = ds->data[0];
    for (int i = 1; i < ds->count; i++) {
        if (ds->data[i] < min) min = ds->data[i];
        if (ds->data[i] > max) max = ds->data[i];
    }

    double bin_width = (max - min) / bins;
    int *histogram = calloc(bins, sizeof(int));

    // 히스토그램 계산
    for (int i = 0; i < ds->count; i++) {
        int bin = (int)((ds->data[i] - min) / bin_width);
        if (bin >= bins) bin = bins - 1;  // 최댓값 처리
        histogram[bin]++;
    }

    // 최대 빈도수 찾기 (스케일링용)
    int max_freq = 0;
    for (int i = 0; i < bins; i++) {
        if (histogram[i] > max_freq) max_freq = histogram[i];
    }

    printf("\n=== 히스토그램 ===\n");
    for (int i = 0; i < bins; i++) {
        printf("[%6.2f-%6.2f]: ", min + i * bin_width, min + (i + 1) * bin_width);

        // 막대 그래프 출력 (최대 50개 문자)
        int bar_length = (histogram[i] * 50) / (max_freq > 0 ? max_freq : 1);
        for (int j = 0; j < bar_length; j++) {
            printf("█");
        }
        printf(" (%d)\n", histogram[i]);
    }

    free(histogram);
}

// 이동 평균 계산
void calculate_moving_average(DataSet *ds, int window_size) {
    if (ds->count < window_size) {
        printf("데이터가 부족합니다. (필요: %d, 현재: %d)\n", window_size, ds->count);
        return;
    }

    printf("\n=== %d-기간 이동평균 ===\n", window_size);

    for (int i = 0; i <= ds->count - window_size; i++) {
        double sum = 0;
        for (int j = 0; j < window_size; j++) {
            sum += ds->data[i + j];
        }
        double avg = sum / window_size;
        printf("위치 %2d-%2d: %.4f\n", i + 1, i + window_size, avg);
    }
}

// 상관관계 분석 (두 데이터셋)
double calculate_correlation(DataSet *ds1, DataSet *ds2) {
    if (ds1->count != ds2->count || ds1->count == 0) {
        return 0.0;  // 계산 불가
    }

    // 평균 계산
    double mean1 = 0, mean2 = 0;
    for (int i = 0; i < ds1->count; i++) {
        mean1 += ds1->data[i];
        mean2 += ds2->data[i];
    }
    mean1 /= ds1->count;
    mean2 /= ds2->count;

    // 공분산과 표준편차 계산
    double covariance = 0, var1 = 0, var2 = 0;
    for (int i = 0; i < ds1->count; i++) {
        double diff1 = ds1->data[i] - mean1;
        double diff2 = ds2->data[i] - mean2;

        covariance += diff1 * diff2;
        var1 += diff1 * diff1;
        var2 += diff2 * diff2;
    }

    double std1 = sqrt(var1 / ds1->count);
    double std2 = sqrt(var2 / ds2->count);

    if (std1 == 0 || std2 == 0) return 0.0;

    return covariance / (ds1->count * std1 * std2);
}

void data_analysis_tool() {
    DataSet *dataset1 = create_dataset(10);
    DataSet *dataset2 = create_dataset(10);
    int choice;

    do {
        printf("\n=== 데이터 분석 도구 ===\n");
        printf("1. 데이터 입력 (데이터셋 1)\n");
        printf("2. 데이터 입력 (데이터셋 2)\n");
        printf("3. 기본 통계량 계산 (데이터셋 1)\n");
        printf("4. 히스토그램 출력 (데이터셋 1)\n");
        printf("5. 이동평균 계산 (데이터셋 1)\n");
        printf("6. 상관관계 분석 (두 데이터셋)\n");
        printf("7. 샘플 데이터 생성\n");
        printf("0. 종료\n");
        printf("선택: ");

        scanf("%d", &choice);

        switch (choice) {
            case 1:
            case 2: {
                DataSet *ds = (choice == 1) ? dataset1 : dataset2;
                printf("데이터를 입력하세요 (종료: -999):\n");

                double value;
                while (scanf("%lf", &value) == 1 && value != -999) {
                    add_data(ds, value);
                    printf("추가됨: %.4f (총 %d개)\n", value, ds->count);
                }
                break;
            }

            case 3:
                calculate_basic_stats(dataset1);
                break;

            case 4: {
                int bins;
                printf("구간 수를 입력하세요 (권장: 5-20): ");
                scanf("%d", &bins);
                print_histogram(dataset1, bins);
                break;
            }

            case 5: {
                int window;
                printf("이동평균 기간을 입력하세요: ");
                scanf("%d", &window);
                calculate_moving_average(dataset1, window);
                break;
            }

            case 6: {
                double correlation = calculate_correlation(dataset1, dataset2);
                printf("상관계수: %.4f\n", correlation);

                if (correlation > 0.7) {
                    printf("강한 양의 상관관계\n");
                } else if (correlation > 0.3) {
                    printf("약한 양의 상관관계\n");
                } else if (correlation > -0.3) {
                    printf("상관관계 없음\n");
                } else if (correlation > -0.7) {
                    printf("약한 음의 상관관계\n");
                } else {
                    printf("강한 음의 상관관계\n");
                }
                break;
            }

            case 7: {
                printf("샘플 데이터를 생성합니다...\n");

                // 데이터셋 1: 정규분포 근사
                for (int i = 0; i < 100; i++) {
                    double u1 = (double)rand() / RAND_MAX;
                    double u2 = (double)rand() / RAND_MAX;
                    double z = sqrt(-2 * log(u1)) * cos(2 * M_PI * u2);
                    add_data(dataset1, z * 10 + 50);  // 평균 50, 표준편차 10
                }

                // 데이터셋 2: 선형 관계
                for (int i = 0; i < dataset1->count; i++) {
                    double noise = ((double)rand() / RAND_MAX - 0.5) * 10;
                    add_data(dataset2, dataset1->data[i] * 0.8 + 20 + noise);
                }

                printf("데이터셋 1: %d개, 데이터셋 2: %d개 생성됨\n",
                       dataset1->count, dataset2->count);
                break;
            }

            case 0:
                printf("분석 도구를 종료합니다.\n");
                break;

            default:
                printf("잘못된 선택입니다.\n");
                break;
        }
    } while (choice != 0);

    free_dataset(dataset1);
    free_dataset(dataset2);
}
```

### 실습 3: 텍스트 처리 및 암호화 도구

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

// 시저 암호
void caesar_cipher(char *text, int shift, bool encrypt) {
    int len = strlen(text);

    if (!encrypt) shift = -shift;  // 복호화는 반대 방향

    for (int i = 0; i < len; i++) {
        if (isalpha(text[i])) {
            char base = isupper(text[i]) ? 'A' : 'a';
            text[i] = ((text[i] - base + shift + 26) % 26) + base;
        }
    }
}

// 비제네르 암호
void vigenere_cipher(char *text, const char *key, bool encrypt) {
    int text_len = strlen(text);
    int key_len = strlen(key);

    for (int i = 0, j = 0; i < text_len; i++) {
        if (isalpha(text[i])) {
            char text_base = isupper(text[i]) ? 'A' : 'a';
            char key_base = isupper(key[j % key_len]) ? 'A' : 'a';

            int shift = toupper(key[j % key_len]) - 'A';
            if (!encrypt) shift = -shift;

            text[i] = ((text[i] - text_base + shift + 26) % 26) + text_base;
            j++;
        }
    }
}

// 단순 치환 암호 (무작위 키 생성)
void generate_substitution_key(char *key) {
    // 알파벳 초기화
    for (int i = 0; i < 26; i++) {
        key[i] = 'A' + i;
    }
    key[26] = '\0';

    // 피셔-예이츠 셔플
    for (int i = 25; i > 0; i--) {
        int j = rand() % (i + 1);
        char temp = key[i];
        key[i] = key[j];
        key[j] = temp;
    }
}

void substitution_cipher(char *text, const char *key, bool encrypt) {
    int len = strlen(text);

    for (int i = 0; i < len; i++) {
        if (isalpha(text[i])) {
            if (encrypt) {
                if (isupper(text[i])) {
                    text[i] = key[text[i] - 'A'];
                } else {
                    text[i] = tolower(key[text[i] - 'a']);
                }
            } else {
                // 복호화: 키에서 문자 위치 찾기
                for (int j = 0; j < 26; j++) {
                    if (toupper(text[i]) == key[j]) {
                        text[i] = isupper(text[i]) ? ('A' + j) : ('a' + j);
                        break;
                    }
                }
            }
        }
    }
}

// 문자 빈도 분석
void frequency_analysis(const char *text) {
    int freq[26] = {0};
    int total_letters = 0;

    for (int i = 0; text[i]; i++) {
        if (isalpha(text[i])) {
            freq[toupper(text[i]) - 'A']++;
            total_letters++;
        }
    }

    printf("\n=== 문자 빈도 분석 ===\n");
    printf("총 문자 수: %d\n\n", total_letters);

    // 빈도순으로 정렬하기 위한 구조체
    typedef struct {
        char letter;
        int count;
        double percentage;
    } LetterFreq;

    LetterFreq letters[26];
    for (int i = 0; i < 26; i++) {
        letters[i].letter = 'A' + i;
        letters[i].count = freq[i];
        letters[i].percentage = total_letters > 0 ? (100.0 * freq[i] / total_letters) : 0;
    }

    // 버블 정렬 (빈도 기준 내림차순)
    for (int i = 0; i < 25; i++) {
        for (int j = 0; j < 25 - i; j++) {
            if (letters[j].count < letters[j + 1].count) {
                LetterFreq temp = letters[j];
                letters[j] = letters[j + 1];
                letters[j + 1] = temp;
            }
        }
    }

    printf("문자  빈도  비율     그래프\n");
    printf("------------------------\n");

    for (int i = 0; i < 26 && letters[i].count > 0; i++) {
        printf(" %c   %4d  %5.1f%%  ",
               letters[i].letter, letters[i].count, letters[i].percentage);

        // 그래프 출력 (최대 20개 문자)
        int bar_length = (int)(letters[i].percentage / 2);
        for (int j = 0; j < bar_length; j++) {
            printf("█");
        }
        printf("\n");
    }
}

// 단어 개수 및 통계
void text_statistics(const char *text) {
    int chars = 0, words = 0, lines = 1, sentences = 0;
    bool in_word = false;

    for (int i = 0; text[i]; i++) {
        chars++;

        if (text[i] == '\n') {
            lines++;
            in_word = false;
        } else if (text[i] == ' ' || text[i] == '\t') {
            in_word = false;
        } else if (!in_word) {
            words++;
            in_word = true;
        }

        if (text[i] == '.' || text[i] == '!' || text[i] == '?') {
            sentences++;
        }
    }

    printf("\n=== 텍스트 통계 ===\n");
    printf("문자 수: %d\n", chars);
    printf("단어 수: %d\n", words);
    printf("문장 수: %d\n", sentences);
    printf("줄 수: %d\n", lines);

    if (words > 0) {
        printf("평균 단어 길이: %.1f\n", (double)chars / words);
    }
    if (sentences > 0) {
        printf("문장당 평균 단어 수: %.1f\n", (double)words / sentences);
    }
}

// ROT13 (특별한 시저 암호)
void rot13(char *text) {
    caesar_cipher(text, 13, true);
}

void text_crypto_tool() {
    char text[1000];
    char key[100];
    char substitution_key[27];
    int choice;

    srand(time(NULL));

    do {
        printf("\n=== 텍스트 처리 및 암호화 도구 ===\n");
        printf("1. 텍스트 입력\n");
        printf("2. 시저 암호 (암호화)\n");
        printf("3. 시저 암호 (복호화)\n");
        printf("4. 비제네르 암호 (암호화)\n");
        printf("5. 비제네르 암호 (복호화)\n");
        printf("6. 단순 치환 암호 (키 생성 및 암호화)\n");
        printf("7. 단순 치환 암호 (복호화)\n");
        printf("8. ROT13\n");
        printf("9. 문자 빈도 분석\n");
        printf("10. 텍스트 통계\n");
        printf("0. 종료\n");
        printf("선택: ");

        scanf("%d", &choice);
        getchar();  // 개행 문자 소비

        switch (choice) {
            case 1:
                printf("텍스트를 입력하세요:\n");
                fgets(text, sizeof(text), stdin);
                // 마지막 개행 문자 제거
                text[strcspn(text, "\n")] = 0;
                printf("입력된 텍스트: %s\n", text);
                break;

            case 2:
            case 3: {
                int shift;
                printf("이동 값을 입력하세요 (1-25): ");
                scanf("%d", &shift);

                char temp[1000];
                strcpy(temp, text);
                caesar_cipher(temp, shift, choice == 2);

                printf("결과: %s\n", temp);
                printf("원본으로 적용하시겠습니까? (y/n): ");

                char confirm;
                scanf(" %c", &confirm);
                if (confirm == 'y' || confirm == 'Y') {
                    strcpy(text, temp);
                }
                break;
            }

            case 4:
            case 5:
                printf("키를 입력하세요: ");
                scanf("%99s", key);

                char temp2[1000];
                strcpy(temp2, text);
                vigenere_cipher(temp2, key, choice == 4);

                printf("결과: %s\n", temp2);
                printf("원본으로 적용하시겠습니까? (y/n): ");

                char confirm2;
                scanf(" %c", &confirm2);
                if (confirm2 == 'y' || confirm2 == 'Y') {
                    strcpy(text, temp2);
                }
                break;

            case 6:
                generate_substitution_key(substitution_key);
                printf("생성된 치환 키: %s\n", substitution_key);

                char temp3[1000];
                strcpy(temp3, text);
                substitution_cipher(temp3, substitution_key, true);

                printf("암호화 결과: %s\n", temp3);
                printf("원본으로 적용하시겠습니까? (y/n): ");

                char confirm3;
                scanf(" %c", &confirm3);
                if (confirm3 == 'y' || confirm3 == 'Y') {
                    strcpy(text, temp3);
                }
                break;

            case 7:
                printf("복호화 키를 입력하세요: ");
                scanf("%26s", substitution_key);

                char temp4[1000];
                strcpy(temp4, text);
                substitution_cipher(temp4, substitution_key, false);

                printf("복호화 결과: %s\n", temp4);
                printf("원본으로 적용하시겠습니까? (y/n): ");

                char confirm4;
                scanf(" %c", &confirm4);
                if (confirm4 == 'y' || confirm4 == 'Y') {
                    strcpy(text, temp4);
                }
                break;

            case 8: {
                char temp5[1000];
                strcpy(temp5, text);
                rot13(temp5);

                printf("ROT13 결과: %s\n", temp5);
                printf("원본으로 적용하시겠습니까? (y/n): ");

                char confirm5;
                scanf(" %c", &confirm5);
                if (confirm5 == 'y' || confirm5 == 'Y') {
                    strcpy(text, temp5);
                }
                break;
            }

            case 9:
                frequency_analysis(text);
                break;

            case 10:
                text_statistics(text);
                break;

            case 0:
                printf("도구를 종료합니다.\n");
                break;

            default:
                printf("잘못된 선택입니다.\n");
                break;
        }
    } while (choice != 0);
}

int main() {
    int choice;

    do {
        printf("\n=== 반복문 실습 프로그램 ===\n");
        printf("1. 고급 수학 계산기\n");
        printf("2. 데이터 분석 도구\n");
        printf("3. 텍스트 처리 및 암호화 도구\n");
        printf("0. 종료\n");
        printf("선택: ");

        scanf("%d", &choice);

        switch (choice) {
            case 1:
                math_calculator();
                break;
            case 2:
                data_analysis_tool();
                break;
            case 3:
                text_crypto_tool();
                break;
            case 0:
                printf("프로그램을 종료합니다.\n");
                break;
            default:
                printf("잘못된 선택입니다.\n");
                break;
        }
    } while (choice != 0);

    return 0;
}
```

## 마무리

반복문은 프로그래밍에서 **반복적인 작업을 효율적으로 처리하는 핵심 도구**입니다. 단순한 카운팅부터 복잡한 알고리즘 구현까지, 반복문을 적절히 활용하면 강력하고 효율적인 프로그램을 작성할 수 있습니다.

**핵심 포인트:**

1. **적절한 반복문 선택**: for vs while vs do-while의 특성과 사용 시기
2. **루프 제어**: break와 continue를 이용한 효과적인 흐름 제어
3. **성능 최적화**: 루프 불변 조건, 강도 축소, 캐시 친화적 접근
4. **무한 루프 방지**: 종료 조건을 명확히 설정
5. **실전 응용**: 수학 계산, 데이터 처리, 텍스트 분석 등 다양한 도메인 활용

**실용적 조언:**

- 반복 횟수가 명확하면 for문, 조건 중심이면 while문을 사용하세요
- 최소 한 번은 실행되어야 하면 do-while문을 고려하세요
- 중첩 루프에서는 성능과 가독성을 함께 고려하세요
- 항상 루프의 종료 조건을 명확히 하여 무한 루프를 방지하세요
- 복잡한 반복문은 함수로 분리하여 가독성을 높이세요

반복문에 대한 깊은 이해는 알고리즘 구현, 데이터 처리, 수치 계산 등 프로그래밍의 핵심 영역에서 필수적이며, 효율적이고 우아한 코드 작성의 기초가 됩니다.