# 3.3 ë¶„ê¸°ë¬¸ (Branch Statements)

## ë¶„ê¸°ë¬¸ì´ë€ ë¬´ì—‡ì¸ê°€?

ë¶„ê¸°ë¬¸ì€ **í”„ë¡œê·¸ë¨ì˜ ì •ìƒì ì¸ ì‹¤í–‰ íë¦„ì„ ë³€ê²½í•˜ì—¬ ë‹¤ë¥¸ ìœ„ì¹˜ë¡œ ì œì–´ë¥¼ ì´ë™ì‹œí‚¤ëŠ” ë¬¸ì¥**ì…ë‹ˆë‹¤. ì´ëŠ” ë‹¨ìˆœíˆ ì¡°ê±´ë¬¸ì´ë‚˜ ë°˜ë³µë¬¸ì˜ ìˆœì°¨ì  íë¦„ì„ ë²—ì–´ë‚˜, í”„ë¡œê·¸ë¨ì˜ ì‹¤í–‰ ê²½ë¡œë¥¼ **ë™ì ìœ¼ë¡œ ì¡°ì‘**í•˜ëŠ” ê°•ë ¥í•œ ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤.

### ë¶„ê¸°ë¬¸ì˜ ë³¸ì§ˆì  ì—­í• 

í”„ë¡œê·¸ë¨ì€ ê¸°ë³¸ì ìœ¼ë¡œ **ìˆœì°¨ ì‹¤í–‰(Sequential Execution)** ì›ì¹™ì„ ë”°ë¦…ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì‹¤ì œ í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ”:

1. **ì˜ˆì™¸ ìƒí™© ì²˜ë¦¬**: ì˜¤ë¥˜ë‚˜ íŠ¹ìˆ˜í•œ ì¡°ê±´ì—ì„œ ì¦‰ì‹œ íƒˆì¶œ
2. **íš¨ìœ¨ì„± í–¥ìƒ**: ë¶ˆí•„ìš”í•œ ê³„ì‚°ì´ë‚˜ ë°˜ë³µ ë°©ì§€
3. **ë³µì¡í•œ ì œì–´ íë¦„**: ë‹¤ì¤‘ ì¤‘ì²© êµ¬ì¡°ì—ì„œì˜ ì •êµí•œ ì œì–´
4. **ìµœì í™”**: ì¡°ê¸° ì¢…ë£Œë¥¼ í†µí•œ ì„±ëŠ¥ ê°œì„ 

ì´ëŸ¬í•œ ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±í•˜ê¸° ìœ„í•´ ë¶„ê¸°ë¬¸ì´ í•„ìš”í•©ë‹ˆë‹¤.

### ë¶„ê¸°ë¬¸ê³¼ êµ¬ì¡°ì  í”„ë¡œê·¸ë˜ë°

êµ¬ì¡°ì  í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” **ì œí•œì ì´ê³  ê·œì¹™ì ì¸ ë¶„ê¸°ë¬¸ ì‚¬ìš©**ì„ ê¶Œì¥í•©ë‹ˆë‹¤:

**ê¶Œì¥ë˜ëŠ” ë¶„ê¸°ë¬¸:**
- `break`: ë£¨í”„ë‚˜ switchë¬¸ì—ì„œ ì •ìƒì ì¸ íƒˆì¶œ
- `continue`: ë£¨í”„ì˜ ë‹¤ìŒ ë°˜ë³µìœ¼ë¡œ ì´ë™
- `return`: í•¨ìˆ˜ì—ì„œ ê°’ì„ ë°˜í™˜í•˜ë©° ì¢…ë£Œ

**ì‹ ì¤‘í•˜ê²Œ ì‚¬ìš©í•´ì•¼ í•  ë¶„ê¸°ë¬¸:**
- `goto`: ì„ì˜ì˜ ìœ„ì¹˜ë¡œ ì í”„ (ìŠ¤íŒŒê²Œí‹° ì½”ë“œì˜ ì›ì¸)

### ë¶„ê¸°ë¬¸ê³¼ í•˜ë“œì›¨ì–´ì˜ ê´€ê³„

ë¶„ê¸°ë¬¸ì€ CPUì˜ **ì í”„(Jump) ëª…ë ¹ì–´**ì™€ ì§ì ‘ ëŒ€ì‘ë©ë‹ˆë‹¤:

```assembly
; ì–´ì…ˆë¸”ë¦¬ ì˜ˆì œ (x86)
JMP  label      ; ë¬´ì¡°ê±´ ì í”„ (gotoì™€ ìœ ì‚¬)
JE   label      ; ê°™ìœ¼ë©´ ì í”„ (break ì¡°ê±´ë¶€)
JNE  label      ; ë‹¤ë¥´ë©´ ì í”„ (continue ì¡°ê±´ë¶€)
CALL function   ; í•¨ìˆ˜ í˜¸ì¶œ (returnê³¼ ì—°ê´€)
RET             ; í•¨ìˆ˜ ë°˜í™˜ (return)
```

í˜„ëŒ€ í”„ë¡œì„¸ì„œëŠ” **ë¶„ê¸° ì˜ˆì¸¡(Branch Prediction)** ê¸°ìˆ ì„ ì‚¬ìš©í•˜ì—¬ ë¶„ê¸°ë¬¸ì˜ ì„±ëŠ¥ì„ ìµœì í™”í•©ë‹ˆë‹¤.

## break ë¬¸

### break ë¬¸ì˜ ê¸°ë³¸ ê°œë…

`break` ë¬¸ì€ í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ **ê°€ì¥ ê°€ê¹Œìš´ ë°˜ë³µë¬¸ì´ë‚˜ switchë¬¸ì„ ì¦‰ì‹œ ì¢…ë£Œ**í•˜ê³ , í•´ë‹¹ êµ¬ë¬¸ ë‹¤ìŒì˜ ì²« ë²ˆì§¸ ë¬¸ì¥ìœ¼ë¡œ ì œì–´ë¥¼ ì´ë™ì‹œí‚µë‹ˆë‹¤.

```c
// breakì˜ ê¸°ë³¸ ë™ì‘
while (condition) {
    statement1;
    if (special_condition) {
        break;  // while ë£¨í”„ ì¦‰ì‹œ ì¢…ë£Œ
    }
    statement2;  // special_conditionì´ ì°¸ì´ë©´ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ
}
// break ì‹œ ì—¬ê¸°ë¡œ ì´ë™
```

### switch ë¬¸ì—ì„œì˜ break

**ê¸°ë³¸ ì‚¬ìš©ë²•:**
```c
#include <stdio.h>

void demonstrate_switch_break() {
    int choice = 2;

    switch (choice) {
        case 1:
            printf("ì„ íƒ 1\n");
            break;  // switchë¬¸ íƒˆì¶œ
        case 2:
            printf("ì„ íƒ 2\n");
            break;  // switchë¬¸ íƒˆì¶œ
        case 3:
            printf("ì„ íƒ 3\n");
            break;  // switchë¬¸ íƒˆì¶œ
        default:
            printf("ê¸°íƒ€ ì„ íƒ\n");
            break;  // ìƒëµ ê°€ëŠ¥í•˜ì§€ë§Œ ì¼ê´€ì„±ì„ ìœ„í•´ ê¶Œì¥
    }
    printf("switch ì¢…ë£Œ í›„\n");
}
```

**break ì—†ëŠ” fall-through í™œìš©:**
```c
#include <stdio.h>

void grade_to_description(char grade) {
    printf("í•™ì  %c: ", grade);

    switch (grade) {
        case 'A':
        case 'a':
            printf("ìš°ìˆ˜ ");
            // fall-through (ì˜ë„ì )
        case 'B':
        case 'b':
            printf("ì–‘í˜¸ ì´ìƒ");
            break;
        case 'C':
        case 'c':
            printf("ë³´í†µ");
            break;
        case 'D':
        case 'd':
            printf("ë¯¸í¡");
            break;
        case 'F':
        case 'f':
            printf("ë‚™ì œ");
            break;
        default:
            printf("ì˜ëª»ëœ í•™ì ");
            break;
    }
    printf("\n");
}
```

### ë°˜ë³µë¬¸ì—ì„œì˜ break

**1. ì¡°ê±´ ë§Œì¡± ì‹œ ì¦‰ì‹œ ì¢…ë£Œ**
```c
#include <stdio.h>

int find_first_negative(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("ê²€ì‚¬ ì¤‘: arr[%d] = %d\n", i, arr[i]);

        if (arr[i] < 0) {
            printf("ì²« ë²ˆì§¸ ìŒìˆ˜ ë°œê²¬: ì¸ë±ìŠ¤ %d\n", i);
            return i;  // í•¨ìˆ˜ ìì²´ ì¢…ë£Œ
        }
    }

    printf("ìŒìˆ˜ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n");
    return -1;
}

// breakë¥¼ ì‚¬ìš©í•œ ë²„ì „
int find_first_negative_with_break(int arr[], int size) {
    int found_index = -1;

    for (int i = 0; i < size; i++) {
        printf("ê²€ì‚¬ ì¤‘: arr[%d] = %d\n", i, arr[i]);

        if (arr[i] < 0) {
            printf("ì²« ë²ˆì§¸ ìŒìˆ˜ ë°œê²¬: ì¸ë±ìŠ¤ %d\n", i);
            found_index = i;
            break;  // ë£¨í”„ë§Œ ì¢…ë£Œ
        }
    }

    if (found_index == -1) {
        printf("ìŒìˆ˜ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n");
    }

    return found_index;
}
```

**2. ì‚¬ìš©ì ì…ë ¥ ê²€ì¦ì—ì„œ break**
```c
#include <stdio.h>
#include <stdbool.h>

int get_valid_choice(int min, int max) {
    int choice;

    while (true) {  // ë¬´í•œ ë£¨í”„
        printf("ì„ íƒí•˜ì„¸ìš” (%d-%d): ", min, max);

        if (scanf("%d", &choice) != 1) {
            printf("ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤. ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”.\n");
            // ì…ë ¥ ë²„í¼ ë¹„ìš°ê¸°
            while (getchar() != '\n');
            continue;
        }

        if (choice >= min && choice <= max) {
            break;  // ìœ íš¨í•œ ì…ë ¥ì´ë©´ ë£¨í”„ íƒˆì¶œ
        }

        printf("ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤. %dë¶€í„° %d ì‚¬ì´ì˜ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”.\n",
               min, max);
    }

    return choice;
}
```

**3. íŒŒì¼ ì²˜ë¦¬ì—ì„œ break**
```c
#include <stdio.h>
#include <string.h>

bool search_in_file(const char *filename, const char *search_term) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: %s\n", filename);
        return false;
    }

    char line[256];
    int line_number = 1;
    bool found = false;

    while (fgets(line, sizeof(line), file) != NULL) {
        if (strstr(line, search_term) != NULL) {
            printf("ë°œê²¬! ë¼ì¸ %d: %s", line_number, line);
            found = true;
            break;  // ì²« ë²ˆì§¸ ë°œê²¬ ì‹œ ì¤‘ë‹¨
        }
        line_number++;
    }

    fclose(file);

    if (!found) {
        printf("'%s'ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n", search_term);
    }

    return found;
}
```

### ì¤‘ì²© ë£¨í”„ì—ì„œì˜ break ì œí•œ

**ë¬¸ì œì : breakëŠ” ê°€ì¥ ê°€ê¹Œìš´ ë£¨í”„ë§Œ ì¢…ë£Œ**
```c
#include <stdio.h>

void demonstrate_nested_break_problem() {
    printf("ì¤‘ì²© ë£¨í”„ì—ì„œ breakì˜ í•œê³„:\n");

    for (int i = 1; i <= 3; i++) {
        printf("ì™¸ë¶€ ë£¨í”„: i = %d\n", i);

        for (int j = 1; j <= 5; j++) {
            printf("  ë‚´ë¶€ ë£¨í”„: j = %d\n", j);

            if (j == 3) {
                printf("  break ì‹¤í–‰!\n");
                break;  // ë‚´ë¶€ ë£¨í”„ë§Œ ì¢…ë£Œ
            }
        }

        printf("ë‚´ë¶€ ë£¨í”„ ì¢…ë£Œ, ì™¸ë¶€ ë£¨í”„ ê³„ì†\n");
    }

    printf("ëª¨ë“  ë£¨í”„ ì¢…ë£Œ\n");
}
```

**í•´ê²° ë°©ë²•ë“¤:**

**1. í”Œë˜ê·¸ ë³€ìˆ˜ ì‚¬ìš©**
```c
#include <stdio.h>
#include <stdbool.h>

void nested_break_with_flag() {
    printf("í”Œë˜ê·¸ë¥¼ ì´ìš©í•œ ë‹¤ì¤‘ ë£¨í”„ íƒˆì¶œ:\n");
    bool should_exit = false;

    for (int i = 1; i <= 3 && !should_exit; i++) {
        printf("ì™¸ë¶€ ë£¨í”„: i = %d\n", i);

        for (int j = 1; j <= 5; j++) {
            printf("  ë‚´ë¶€ ë£¨í”„: j = %d\n", j);

            if (i == 2 && j == 3) {
                printf("  ì¡°ê±´ ë§Œì¡±, ëª¨ë“  ë£¨í”„ íƒˆì¶œ!\n");
                should_exit = true;
                break;
            }
        }
    }

    printf("ëª¨ë“  ë£¨í”„ ì¢…ë£Œ\n");
}
```

**2. í•¨ìˆ˜ë¡œ ë¶„ë¦¬**
```c
#include <stdio.h>

bool process_inner_loop(int i) {
    for (int j = 1; j <= 5; j++) {
        printf("  ë‚´ë¶€ ë£¨í”„: j = %d\n", j);

        if (i == 2 && j == 3) {
            printf("  ì¡°ê±´ ë§Œì¡±, í•¨ìˆ˜ì—ì„œ ë°˜í™˜!\n");
            return true;  // ì¡°ê¸° ì¢…ë£Œ ì‹ í˜¸
        }
    }
    return false;  // ì •ìƒ ì™„ë£Œ
}

void nested_break_with_function() {
    printf("í•¨ìˆ˜ ë¶„ë¦¬ë¥¼ ì´ìš©í•œ ë‹¤ì¤‘ ë£¨í”„ ì œì–´:\n");

    for (int i = 1; i <= 3; i++) {
        printf("ì™¸ë¶€ ë£¨í”„: i = %d\n", i);

        if (process_inner_loop(i)) {
            break;  // ë‚´ë¶€ í•¨ìˆ˜ì—ì„œ ì¡°ê¸° ì¢…ë£Œ ì‹ í˜¸ ë°›ìŒ
        }
    }

    printf("ëª¨ë“  ë£¨í”„ ì¢…ë£Œ\n");
}
```

**3. goto ì‚¬ìš© (ê¶Œì¥í•˜ì§€ ì•ŠìŒ)**
```c
#include <stdio.h>

void nested_break_with_goto() {
    printf("gotoë¥¼ ì´ìš©í•œ ë‹¤ì¤‘ ë£¨í”„ íƒˆì¶œ (ê¶Œì¥í•˜ì§€ ì•ŠìŒ):\n");

    for (int i = 1; i <= 3; i++) {
        printf("ì™¸ë¶€ ë£¨í”„: i = %d\n", i);

        for (int j = 1; j <= 5; j++) {
            printf("  ë‚´ë¶€ ë£¨í”„: j = %d\n", j);

            if (i == 2 && j == 3) {
                printf("  ì¡°ê±´ ë§Œì¡±, gotoë¡œ íƒˆì¶œ!\n");
                goto exit_all;  // ëª¨ë“  ë£¨í”„ íƒˆì¶œ
            }
        }
    }

exit_all:
    printf("ëª¨ë“  ë£¨í”„ ì¢…ë£Œ\n");
}
```

## continue ë¬¸

### continue ë¬¸ì˜ ê¸°ë³¸ ê°œë…

`continue` ë¬¸ì€ **í˜„ì¬ ë°˜ë³µì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ê±´ë„ˆë›°ê³ **, ë°˜ë³µë¬¸ì˜ **ë‹¤ìŒ ë°˜ë³µìœ¼ë¡œ ì¦‰ì‹œ ì´ë™**í•©ë‹ˆë‹¤. ë°˜ë³µë¬¸ ìì²´ëŠ” ì¢…ë£Œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```c
// continueì˜ ê¸°ë³¸ ë™ì‘
for (int i = 0; i < 10; i++) {
    if (condition) {
        continue;  // ì•„ë˜ ì½”ë“œ ê±´ë„ˆë›°ê³  i++ ì‹¤í–‰ í›„ ë‹¤ìŒ ë°˜ë³µ
    }
    // conditionì´ ì°¸ì´ë©´ ì´ ë¶€ë¶„ì€ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ
}
```

### continueì˜ ë°˜ë³µë¬¸ë³„ ë™ì‘

**1. for ë¬¸ì—ì„œì˜ continue**
```c
#include <stdio.h>

void demonstrate_continue_in_for() {
    printf("forë¬¸ì—ì„œ continue:\n");

    for (int i = 1; i <= 10; i++) {
        if (i % 2 == 0) {
            continue;  // ì§ìˆ˜ëŠ” ê±´ë„ˆë›°ê¸°, i++ëŠ” ì‹¤í–‰ë¨
        }
        printf("%d ", i);  // í™€ìˆ˜ë§Œ ì¶œë ¥
    }
    printf("\n");
}
// ì¶œë ¥: 1 3 5 7 9
```

**2. while ë¬¸ì—ì„œì˜ continue**
```c
#include <stdio.h>

void demonstrate_continue_in_while() {
    printf("whileë¬¸ì—ì„œ continue (ì£¼ì˜ì‚¬í•­):\n");

    int i = 0;
    while (i < 10) {
        i++;  // ë°˜ë“œì‹œ continue ì „ì— ì¦ê°€!

        if (i % 2 == 0) {
            continue;  // ì§ìˆ˜ëŠ” ê±´ë„ˆë›°ê¸°
        }
        printf("%d ", i);  // í™€ìˆ˜ë§Œ ì¶œë ¥
    }
    printf("\n");
}

// ì˜ëª»ëœ ì˜ˆì œ (ë¬´í•œ ë£¨í”„ ìœ„í—˜)
void dangerous_continue_in_while() {
    int i = 0;
    while (i < 10) {
        if (i % 2 == 0) {
            continue;  // i++ê°€ ì‹¤í–‰ë˜ì§€ ì•Šì•„ ë¬´í•œ ë£¨í”„!
        }
        printf("%d ", i);
        i++;
    }
}
```

**3. do-while ë¬¸ì—ì„œì˜ continue**
```c
#include <stdio.h>

void demonstrate_continue_in_do_while() {
    printf("do-whileë¬¸ì—ì„œ continue:\n");

    int i = 0;
    do {
        i++;

        if (i % 3 == 0) {
            continue;  // 3ì˜ ë°°ìˆ˜ëŠ” ê±´ë„ˆë›°ê¸°
        }
        printf("%d ", i);
    } while (i < 10);
    printf("\n");
}
// ì¶œë ¥: 1 2 4 5 7 8 10
```

### continueì˜ ì‹¤ìš©ì  í™œìš©

**1. ì¡°ê±´ë¶€ ë°ì´í„° ì²˜ë¦¬**
```c
#include <stdio.h>
#include <ctype.h>
#include <string.h>

void process_valid_characters(const char *input) {
    printf("ì›ë³¸: %s\n", input);
    printf("ì•ŒíŒŒë²³ë§Œ: ");

    for (int i = 0; input[i]; i++) {
        // ì•ŒíŒŒë²³ì´ ì•„ë‹ˆë©´ ê±´ë„ˆë›°ê¸°
        if (!isalpha(input[i])) {
            continue;
        }

        printf("%c", toupper(input[i]));
    }
    printf("\n");
}

void process_numbers_only(const char *input) {
    printf("ì›ë³¸: %s\n", input);
    printf("ìˆ«ìë§Œ: ");

    for (int i = 0; input[i]; i++) {
        // ìˆ«ìê°€ ì•„ë‹ˆë©´ ê±´ë„ˆë›°ê¸°
        if (!isdigit(input[i])) {
            continue;
        }

        printf("%c", input[i]);
    }
    printf("\n");
}
```

**2. ë°°ì—´ì˜ ì¡°ê±´ë¶€ ì²˜ë¦¬**
```c
#include <stdio.h>

double calculate_positive_average(double numbers[], int size) {
    double sum = 0;
    int count = 0;

    for (int i = 0; i < size; i++) {
        // ìŒìˆ˜ë‚˜ 0ì€ ê±´ë„ˆë›°ê¸°
        if (numbers[i] <= 0) {
            continue;
        }

        sum += numbers[i];
        count++;
    }

    return count > 0 ? sum / count : 0.0;
}

void print_valid_scores(int scores[], int size) {
    printf("ìœ íš¨í•œ ì ìˆ˜ë“¤ (0-100):\n");

    for (int i = 0; i < size; i++) {
        // ìœ íš¨í•˜ì§€ ì•Šì€ ì ìˆ˜ëŠ” ê±´ë„ˆë›°ê¸°
        if (scores[i] < 0 || scores[i] > 100) {
            printf("ì ìˆ˜[%d] = %d (ë¬´íš¨)\n", i, scores[i]);
            continue;
        }

        printf("ì ìˆ˜[%d] = %d\n", i, scores[i]);
    }
}
```

**3. íŒŒì¼ ì²˜ë¦¬ì—ì„œ continue**
```c
#include <stdio.h>
#include <string.h>

void process_config_file(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: %s\n", filename);
        return;
    }

    char line[256];
    int line_number = 0;

    while (fgets(line, sizeof(line), file)) {
        line_number++;

        // ë¹ˆ ì¤„ ê±´ë„ˆë›°ê¸°
        if (line[0] == '\n') {
            continue;
        }

        // ì£¼ì„ ì¤„ ê±´ë„ˆë›°ê¸°
        if (line[0] == '#') {
            continue;
        }

        // ê³µë°±ìœ¼ë¡œë§Œ ì´ë£¨ì–´ì§„ ì¤„ ê±´ë„ˆë›°ê¸°
        bool only_spaces = true;
        for (int i = 0; line[i] && line[i] != '\n'; i++) {
            if (line[i] != ' ' && line[i] != '\t') {
                only_spaces = false;
                break;
            }
        }
        if (only_spaces) {
            continue;
        }

        // ìœ íš¨í•œ ì„¤ì • ë¼ì¸ ì²˜ë¦¬
        printf("ë¼ì¸ %d: %s", line_number, line);
    }

    fclose(file);
}
```

**4. ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ì—ì„œ continue**
```c
#include <stdio.h>
#include <stdbool.h>

void interactive_calculator() {
    printf("ê°„ë‹¨í•œ ê³„ì‚°ê¸° (ì¢…ë£Œ: 'q')\n");

    while (true) {
        double a, b;
        char operator;

        printf("ê³„ì‚°ì‹ ì…ë ¥ (ì˜ˆ: 3.5 + 2.1): ");

        // ì¢…ë£Œ ëª…ë ¹ í™•ì¸
        char first_char;
        scanf(" %c", &first_char);
        if (first_char == 'q' || first_char == 'Q') {
            break;
        }

        // ì²« ë²ˆì§¸ ë¬¸ìë¥¼ ë‹¤ì‹œ ì…ë ¥ ìŠ¤íŠ¸ë¦¼ì— ë„£ê¸°
        ungetc(first_char, stdin);

        // ê³„ì‚°ì‹ íŒŒì‹±
        if (scanf("%lf %c %lf", &a, &operator, &b) != 3) {
            printf("ì˜ëª»ëœ í˜•ì‹ì…ë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.\n");
            // ì…ë ¥ ë²„í¼ ë¹„ìš°ê¸°
            while (getchar() != '\n');
            continue;  // ë‹¤ìŒ ë°˜ë³µìœ¼ë¡œ
        }

        double result;
        bool valid = true;

        switch (operator) {
            case '+':
                result = a + b;
                break;
            case '-':
                result = a - b;
                break;
            case '*':
                result = a * b;
                break;
            case '/':
                if (b == 0) {
                    printf("ì˜¤ë¥˜: 0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n");
                    valid = false;
                } else {
                    result = a / b;
                }
                break;
            default:
                printf("ì§€ì›í•˜ì§€ ì•ŠëŠ” ì—°ì‚°ì: %c\n", operator);
                valid = false;
                break;
        }

        if (!valid) {
            continue;  // ì˜¤ë¥˜ ì‹œ ë‹¤ìŒ ë°˜ë³µìœ¼ë¡œ
        }

        printf("ê²°ê³¼: %.2f %c %.2f = %.2f\n", a, operator, b, result);
    }

    printf("ê³„ì‚°ê¸°ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.\n");
}
```

### continueì™€ ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

**1. ì¡°ê±´ ìµœì í™”**
```c
// ë¹„íš¨ìœ¨ì : ë³µì¡í•œ ì¡°ê±´ì„ ë§¤ë²ˆ ê³„ì‚°
for (int i = 0; i < size; i++) {
    if (expensive_condition_check(arr[i])) {
        continue;
    }
    process(arr[i]);
}

// íš¨ìœ¨ì : ì¡°ê±´ì„ ê°„ë‹¨íˆ í•˜ê±°ë‚˜ ìºì‹œ
bool *skip_flags = precompute_skip_flags(arr, size);
for (int i = 0; i < size; i++) {
    if (skip_flags[i]) {
        continue;
    }
    process(arr[i]);
}
```

**2. ë¶„ê¸° ì˜ˆì¸¡ ê³ ë ¤**
```c
// ì˜ˆì¸¡í•˜ê¸° ì–´ë ¤ìš´ íŒ¨í„´
for (int i = 0; i < size; i++) {
    if (random_condition()) {  // ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥
        continue;
    }
    process(arr[i]);
}

// ì˜ˆì¸¡ ê°€ëŠ¥í•œ íŒ¨í„´
for (int i = 0; i < size; i++) {
    if (i % 10 == 0) {  // ê·œì¹™ì ì¸ íŒ¨í„´
        continue;
    }
    process(arr[i]);
}
```

## goto ë¬¸

### goto ë¬¸ì˜ ê¸°ë³¸ ê°œë…

`goto` ë¬¸ì€ í”„ë¡œê·¸ë¨ì˜ **ì„ì˜ì˜ ìœ„ì¹˜ë¡œ ë¬´ì¡°ê±´ ì í”„**í•˜ëŠ” ê°€ì¥ ì›ì‹œì ì¸ ë¶„ê¸°ë¬¸ì…ë‹ˆë‹¤. ë¼ë²¨(label)ë¡œ ì§€ì •ëœ ìœ„ì¹˜ë¡œ ì§ì ‘ ì´ë™í•˜ë©°, ëª¨ë“  êµ¬ì¡°ì  ì œì•½ì„ ë¬´ì‹œí•©ë‹ˆë‹¤.

```c
// gotoì˜ ê¸°ë³¸ ë¬¸ë²•
goto label_name;

// ...ë‹¤ë¥¸ ì½”ë“œë“¤...

label_name:
    // ì—¬ê¸°ë¡œ ì í”„
```

### goto ë¬¸ì˜ ì—­ì‚¬ì  ë°°ê²½

**ì´ˆê¸° í”„ë¡œê·¸ë˜ë° ì‹œëŒ€:**
- ì–´ì…ˆë¸”ë¦¬ì–´ì—ì„œëŠ” ì í”„ê°€ ê¸°ë³¸ì ì¸ ì œì–´ êµ¬ì¡°
- ì´ˆê¸° ê³ ê¸‰ ì–¸ì–´ë“¤ë„ gotoì— í¬ê²Œ ì˜ì¡´
- ë³µì¡í•œ í”„ë¡œê·¸ë¨ì—ì„œ "ìŠ¤íŒŒê²Œí‹° ì½”ë“œ" ë¬¸ì œ ë°œìƒ

**êµ¬ì¡°ì  í”„ë¡œê·¸ë˜ë°ì˜ ë“±ì¥:**
- 1968ë…„ ë‹¤ìµìŠ¤íŠ¸ë¼(Dijkstra)ì˜ "Go To Statement Considered Harmful" ë…¼ë¬¸
- if-else, while, for ë“± êµ¬ì¡°ì  ì œì–´ë¬¸ìœ¼ë¡œ ëŒ€ì²´ ê°€ëŠ¥
- goto ì‚¬ìš©ì„ ìµœì†Œí™”í•˜ëŠ” í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„ í™•ì‚°

### goto ë¬¸ì˜ ì œí•œì  ì‚¬ìš© ì‚¬ë¡€

**1. ë‹¤ì¤‘ ì¤‘ì²© ë£¨í”„ì—ì„œì˜ íƒˆì¶œ**
```c
#include <stdio.h>

// gotoë¥¼ ì‚¬ìš©í•œ ë‹¤ì¤‘ ë£¨í”„ íƒˆì¶œ
void find_in_3d_array_goto(int arr[5][5][5], int target) {
    printf("3ì°¨ì› ë°°ì—´ì—ì„œ %d ì°¾ê¸° (goto ì‚¬ìš©):\n", target);

    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            for (int k = 0; k < 5; k++) {
                printf("ê²€ì‚¬: [%d][%d][%d] = %d\n", i, j, k, arr[i][j][k]);

                if (arr[i][j][k] == target) {
                    printf("ë°œê²¬! ìœ„ì¹˜: [%d][%d][%d]\n", i, j, k);
                    goto found;  // ëª¨ë“  ë£¨í”„ì—ì„œ ì¦‰ì‹œ íƒˆì¶œ
                }
            }
        }
    }

    printf("ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n");
    return;

found:
    printf("ê²€ìƒ‰ ì™„ë£Œ\n");
}

// êµ¬ì¡°ì  ë°©ë²•ìœ¼ë¡œ ê°œì„ 
bool find_in_3d_array_structural(int arr[5][5][5], int target) {
    printf("3ì°¨ì› ë°°ì—´ì—ì„œ %d ì°¾ê¸° (êµ¬ì¡°ì  ë°©ë²•):\n", target);

    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            for (int k = 0; k < 5; k++) {
                printf("ê²€ì‚¬: [%d][%d][%d] = %d\n", i, j, k, arr[i][j][k]);

                if (arr[i][j][k] == target) {
                    printf("ë°œê²¬! ìœ„ì¹˜: [%d][%d][%d]\n", i, j, k);
                    return true;  // í•¨ìˆ˜ ì „ì²´ ì¢…ë£Œ
                }
            }
        }
    }

    printf("ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n");
    return false;
}
```

**2. ì˜¤ë¥˜ ì²˜ë¦¬ ë° ì •ë¦¬ ì½”ë“œ**
```c
#include <stdio.h>
#include <stdlib.h>

// gotoë¥¼ ì‚¬ìš©í•œ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ íŒ¨í„´
int process_file_with_goto(const char *filename) {
    FILE *file = NULL;
    char *buffer = NULL;
    int *data = NULL;
    int result = -1;

    // íŒŒì¼ ì—´ê¸°
    file = fopen(filename, "r");
    if (file == NULL) {
        printf("íŒŒì¼ ì—´ê¸° ì‹¤íŒ¨\n");
        goto cleanup;  // ì •ë¦¬ ì„¹ì…˜ìœ¼ë¡œ ì´ë™
    }

    // ë©”ëª¨ë¦¬ í• ë‹¹
    buffer = malloc(1024);
    if (buffer == NULL) {
        printf("ë²„í¼ í• ë‹¹ ì‹¤íŒ¨\n");
        goto cleanup;
    }

    data = malloc(sizeof(int) * 100);
    if (data == NULL) {
        printf("ë°ì´í„° ë°°ì—´ í• ë‹¹ ì‹¤íŒ¨\n");
        goto cleanup;
    }

    // ì‹¤ì œ íŒŒì¼ ì²˜ë¦¬
    printf("íŒŒì¼ ì²˜ë¦¬ ì¤‘...\n");
    // ... íŒŒì¼ ì²˜ë¦¬ ë¡œì§ ...

    result = 0;  // ì„±ê³µ

cleanup:
    // ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (ìˆœì„œ ì¤‘ìš”)
    if (data) {
        free(data);
        printf("ë°ì´í„° ë°°ì—´ í•´ì œ\n");
    }
    if (buffer) {
        free(buffer);
        printf("ë²„í¼ í•´ì œ\n");
    }
    if (file) {
        fclose(file);
        printf("íŒŒì¼ ë‹«ê¸°\n");
    }

    return result;
}

// êµ¬ì¡°ì  ë°©ë²•ìœ¼ë¡œ ê°œì„  (í•¨ìˆ˜ ë¶„ë¦¬)
int allocate_resources(FILE **file, char **buffer, int **data, const char *filename) {
    *file = fopen(filename, "r");
    if (*file == NULL) return -1;

    *buffer = malloc(1024);
    if (*buffer == NULL) return -2;

    *data = malloc(sizeof(int) * 100);
    if (*data == NULL) return -3;

    return 0;  // ì„±ê³µ
}

void cleanup_resources(FILE *file, char *buffer, int *data) {
    if (data) free(data);
    if (buffer) free(buffer);
    if (file) fclose(file);
}

int process_file_structural(const char *filename) {
    FILE *file;
    char *buffer;
    int *data;

    int alloc_result = allocate_resources(&file, &buffer, &data, filename);
    if (alloc_result != 0) {
        printf("ë¦¬ì†ŒìŠ¤ í• ë‹¹ ì‹¤íŒ¨: %d\n", alloc_result);
        cleanup_resources(file, buffer, data);
        return -1;
    }

    // ì‹¤ì œ íŒŒì¼ ì²˜ë¦¬
    printf("íŒŒì¼ ì²˜ë¦¬ ì¤‘...\n");
    // ... íŒŒì¼ ì²˜ë¦¬ ë¡œì§ ...

    cleanup_resources(file, buffer, data);
    return 0;
}
```

**3. ìƒíƒœ ë¨¸ì‹ ì—ì„œì˜ goto**
```c
#include <stdio.h>
#include <stdbool.h>

typedef enum {
    STATE_START,
    STATE_READING,
    STATE_PROCESSING,
    STATE_WRITING,
    STATE_END,
    STATE_ERROR
} State;

// gotoë¥¼ ì‚¬ìš©í•œ ìƒíƒœ ë¨¸ì‹  (ê¶Œì¥í•˜ì§€ ì•ŠìŒ)
void state_machine_with_goto() {
    int data = 0;
    bool error_occurred = false;

state_start:
    printf("ì‹œì‘ ìƒíƒœ\n");
    data = 10;
    goto state_reading;

state_reading:
    printf("ì½ê¸° ìƒíƒœ\n");
    if (data < 0) {
        error_occurred = true;
        goto state_error;
    }
    data *= 2;
    goto state_processing;

state_processing:
    printf("ì²˜ë¦¬ ìƒíƒœ\n");
    if (data > 100) {
        error_occurred = true;
        goto state_error;
    }
    data += 5;
    goto state_writing;

state_writing:
    printf("ì“°ê¸° ìƒíƒœ\n");
    printf("ìµœì¢… ë°ì´í„°: %d\n", data);
    goto state_end;

state_error:
    printf("ì˜¤ë¥˜ ìƒíƒœ\n");
    printf("ë°ì´í„°: %d\n", data);
    goto state_end;

state_end:
    printf("ì¢…ë£Œ ìƒíƒœ\n");
    return;
}

// êµ¬ì¡°ì  ë°©ë²•ìœ¼ë¡œ ê°œì„ 
void state_machine_structural() {
    State current_state = STATE_START;
    int data = 0;

    while (current_state != STATE_END && current_state != STATE_ERROR) {
        switch (current_state) {
            case STATE_START:
                printf("ì‹œì‘ ìƒíƒœ\n");
                data = 10;
                current_state = STATE_READING;
                break;

            case STATE_READING:
                printf("ì½ê¸° ìƒíƒœ\n");
                if (data < 0) {
                    current_state = STATE_ERROR;
                } else {
                    data *= 2;
                    current_state = STATE_PROCESSING;
                }
                break;

            case STATE_PROCESSING:
                printf("ì²˜ë¦¬ ìƒíƒœ\n");
                if (data > 100) {
                    current_state = STATE_ERROR;
                } else {
                    data += 5;
                    current_state = STATE_WRITING;
                }
                break;

            case STATE_WRITING:
                printf("ì“°ê¸° ìƒíƒœ\n");
                printf("ìµœì¢… ë°ì´í„°: %d\n", data);
                current_state = STATE_END;
                break;

            default:
                current_state = STATE_ERROR;
                break;
        }
    }

    if (current_state == STATE_ERROR) {
        printf("ì˜¤ë¥˜ ìƒíƒœ\n");
        printf("ë°ì´í„°: %d\n", data);
    }

    printf("ì¢…ë£Œ ìƒíƒœ\n");
}
```

### goto ì‚¬ìš© ì‹œ ì£¼ì˜ì‚¬í•­

**1. ë³€ìˆ˜ ì´ˆê¸°í™” ë¬¸ì œ**
```c
#include <stdio.h>

void dangerous_goto_example() {
    int choice = 1;

    if (choice == 1) {
        goto skip_initialization;  // ìœ„í—˜!
    }

    int important_var = 100;  // ì´ ì´ˆê¸°í™”ê°€ ê±´ë„ˆë›°ì–´ì§
    printf("ì •ìƒ ì´ˆê¸°í™”: %d\n", important_var);

skip_initialization:
    printf("important_var ì‚¬ìš©: %d\n", important_var);  // ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ê°’!
}

// ì•ˆì „í•œ ë°©ë²•
void safe_example() {
    int choice = 1;
    int important_var;  // ì„ ì–¸ì€ ìœ„ì—ì„œ

    if (choice == 1) {
        important_var = 200;  // ëª…ì‹œì  ì´ˆê¸°í™”
        goto process;
    }

    important_var = 100;  // ë‹¤ë¥¸ ê²½ë¡œì˜ ì´ˆê¸°í™”

process:
    printf("important_var ì‚¬ìš©: %d\n", important_var);  // ì•ˆì „
}
```

**2. ìŠ¤ì½”í”„ ë¬¸ì œ**
```c
void scope_problem_example() {
    goto inner_scope;  // ë¸”ë¡ ë‚´ë¶€ë¡œ ì í”„

    {
        int local_var = 42;
inner_scope:
        printf("local_var: %d\n", local_var);  // ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘!
    }
}
```

**3. ìŠ¤íŒŒê²Œí‹° ì½”ë“œ ìœ„í—˜**
```c
// í”¼í•´ì•¼ í•  ìŠ¤íŒŒê²Œí‹° ì½”ë“œ ì˜ˆì œ
void spaghetti_code_example() {
    int i = 0;

start:
    if (i > 10) goto end;
    if (i % 2 == 0) goto even;
    goto odd;

even:
    printf("ì§ìˆ˜: %d\n", i);
    i++;
    if (i < 5) goto start;
    goto middle;

odd:
    printf("í™€ìˆ˜: %d\n", i);
    i++;
    goto start;

middle:
    printf("ì¤‘ê°„ ì²˜ë¦¬\n");
    if (i < 8) goto start;

end:
    printf("ì¢…ë£Œ\n");
}
```

### gotoì˜ ëŒ€ì•ˆë“¤

**1. í”Œë˜ê·¸ ë³€ìˆ˜**
```c
#include <stdbool.h>

void alternative_with_flag() {
    bool should_continue = true;
    bool found = false;

    for (int i = 0; i < 10 && should_continue; i++) {
        for (int j = 0; j < 10 && should_continue; j++) {
            if (some_condition(i, j)) {
                found = true;
                should_continue = false;  // ëª¨ë“  ë£¨í”„ ì¢…ë£Œ
            }
        }
    }

    if (found) {
        // ì²˜ë¦¬ ë¡œì§
    }
}
```

**2. í•¨ìˆ˜ ë¶„ë¦¬**
```c
bool search_in_matrix(int matrix[10][10]) {
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            if (some_condition(i, j)) {
                return true;  // ì¦‰ì‹œ ë°˜í™˜
            }
        }
    }
    return false;
}

void alternative_with_function() {
    int matrix[10][10];
    // ë§¤íŠ¸ë¦­ìŠ¤ ì´ˆê¸°í™”...

    if (search_in_matrix(matrix)) {
        // ì°¾ì•˜ì„ ë•Œì˜ ì²˜ë¦¬
    } else {
        // ëª» ì°¾ì•˜ì„ ë•Œì˜ ì²˜ë¦¬
    }
}
```

**3. do-while(0) ë§¤í¬ë¡œ íŒ¨í„´**
```c
#define PROCESS_WITH_CLEANUP(condition) do { \
    if (allocate_resource1() != 0) break; \
    if (allocate_resource2() != 0) break; \
    if (!(condition)) break; \
    perform_operation(); \
} while(0); \
cleanup_resources()

void alternative_with_macro() {
    PROCESS_WITH_CLEANUP(some_condition());
}
```

## ë¶„ê¸°ë¬¸ í™œìš© ì‹¤ìŠµ

### ì‹¤ìŠµ 1: ê³ ê¸‰ íŒŒì¼ ì²˜ë¦¬ ì‹œìŠ¤í…œ

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

#define MAX_LINE_LENGTH 1024
#define MAX_FILENAME_LENGTH 256

typedef enum {
    RESULT_SUCCESS = 0,
    RESULT_FILE_ERROR = -1,
    RESULT_MEMORY_ERROR = -2,
    RESULT_FORMAT_ERROR = -3,
    RESULT_USER_ABORT = -4
} ProcessResult;

typedef struct {
    char **lines;
    int count;
    int capacity;
} TextBuffer;

// í…ìŠ¤íŠ¸ ë²„í¼ ì´ˆê¸°í™”
TextBuffer* create_text_buffer(int initial_capacity) {
    TextBuffer *buffer = malloc(sizeof(TextBuffer));
    if (buffer == NULL) return NULL;

    buffer->lines = malloc(sizeof(char*) * initial_capacity);
    if (buffer->lines == NULL) {
        free(buffer);
        return NULL;
    }

    buffer->count = 0;
    buffer->capacity = initial_capacity;
    return buffer;
}

// í…ìŠ¤íŠ¸ ë²„í¼ ì •ë¦¬
void free_text_buffer(TextBuffer *buffer) {
    if (buffer == NULL) return;

    for (int i = 0; i < buffer->count; i++) {
        free(buffer->lines[i]);
    }
    free(buffer->lines);
    free(buffer);
}

// ë¼ì¸ ì¶”ê°€ (ë™ì  í™•ì¥)
bool add_line_to_buffer(TextBuffer *buffer, const char *line) {
    if (buffer->count >= buffer->capacity) {
        // ìš©ëŸ‰ 2ë°° í™•ì¥
        int new_capacity = buffer->capacity * 2;
        char **new_lines = realloc(buffer->lines, sizeof(char*) * new_capacity);
        if (new_lines == NULL) return false;

        buffer->lines = new_lines;
        buffer->capacity = new_capacity;
    }

    buffer->lines[buffer->count] = malloc(strlen(line) + 1);
    if (buffer->lines[buffer->count] == NULL) return false;

    strcpy(buffer->lines[buffer->count], line);
    buffer->count++;
    return true;
}

// íŒŒì¼ ì½ê¸° (ì—ëŸ¬ ì²˜ë¦¬ì™€ ì •ë¦¬ ì½”ë“œ í¬í•¨)
ProcessResult read_file_with_filter(const char *filename, TextBuffer **result,
                                   bool (*filter_func)(const char *line)) {
    FILE *file = NULL;
    TextBuffer *buffer = NULL;
    char *line_buffer = NULL;
    ProcessResult retval = RESULT_FILE_ERROR;

    // ë¦¬ì†ŒìŠ¤ í• ë‹¹
    file = fopen(filename, "r");
    if (file == NULL) {
        printf("íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: %s\n", filename);
        goto cleanup;  // ì •ë¦¬ ì„¹ì…˜ìœ¼ë¡œ ì´ë™
    }

    buffer = create_text_buffer(100);
    if (buffer == NULL) {
        printf("í…ìŠ¤íŠ¸ ë²„í¼ ìƒì„± ì‹¤íŒ¨\n");
        retval = RESULT_MEMORY_ERROR;
        goto cleanup;
    }

    line_buffer = malloc(MAX_LINE_LENGTH);
    if (line_buffer == NULL) {
        printf("ë¼ì¸ ë²„í¼ í• ë‹¹ ì‹¤íŒ¨\n");
        retval = RESULT_MEMORY_ERROR;
        goto cleanup;
    }

    // íŒŒì¼ ì½ê¸° ë° í•„í„°ë§
    int line_number = 0;
    while (fgets(line_buffer, MAX_LINE_LENGTH, file) != NULL) {
        line_number++;

        // ê°œí–‰ ë¬¸ì ì œê±°
        line_buffer[strcspn(line_buffer, "\n")] = 0;

        // ë¹ˆ ì¤„ì€ ê±´ë„ˆë›°ê¸°
        if (strlen(line_buffer) == 0) {
            continue;
        }

        // ì£¼ì„ ì¤„ì€ ê±´ë„ˆë›°ê¸°
        if (line_buffer[0] == '#') {
            continue;
        }

        // ì‚¬ìš©ì ì •ì˜ í•„í„° ì ìš©
        if (filter_func && !filter_func(line_buffer)) {
            continue;
        }

        // ë²„í¼ì— ì¶”ê°€
        if (!add_line_to_buffer(buffer, line_buffer)) {
            printf("ë¼ì¸ %d ì¶”ê°€ ì‹¤íŒ¨\n", line_number);
            retval = RESULT_MEMORY_ERROR;
            goto cleanup;
        }

        // ì§„í–‰ ìƒí™© í‘œì‹œ (100ì¤„ë§ˆë‹¤)
        if (line_number % 100 == 0) {
            printf("ì²˜ë¦¬ ì¤‘: %dì¤„\n", line_number);
        }
    }

    printf("ì´ %dì¤„ ì½ìŒ, %dì¤„ í•„í„°ë§ë¨\n", line_number, buffer->count);
    *result = buffer;
    retval = RESULT_SUCCESS;
    buffer = NULL;  // ì†Œìœ ê¶Œ ì´ì „, cleanupì—ì„œ í•´ì œë˜ì§€ ì•Šë„ë¡

cleanup:
    // ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (ì—­ìˆœ)
    if (line_buffer) {
        free(line_buffer);
    }
    if (buffer) {
        free_text_buffer(buffer);
    }
    if (file) {
        fclose(file);
    }

    return retval;
}

// í•„í„° í•¨ìˆ˜ë“¤
bool filter_contains_keyword(const char *line) {
    return strstr(line, "ERROR") != NULL || strstr(line, "WARNING") != NULL;
}

bool filter_alphanumeric_only(const char *line) {
    for (int i = 0; line[i]; i++) {
        if (!isalnum(line[i]) && !isspace(line[i])) {
            return false;
        }
    }
    return true;
}

bool filter_min_length(const char *line) {
    return strlen(line) >= 10;
}

// ëŒ€í™”í˜• íŒŒì¼ ì²˜ë¦¬
void interactive_file_processor() {
    char filename[MAX_FILENAME_LENGTH];
    TextBuffer *result = NULL;
    bool (*current_filter)(const char*) = NULL;

    printf("=== ê³ ê¸‰ íŒŒì¼ ì²˜ë¦¬ ì‹œìŠ¤í…œ ===\n");

    while (true) {
        printf("\në©”ë‰´:\n");
        printf("1. íŒŒì¼ ì„ íƒ\n");
        printf("2. í•„í„° ì„¤ì •\n");
        printf("3. íŒŒì¼ ì²˜ë¦¬\n");
        printf("4. ê²°ê³¼ ë³´ê¸°\n");
        printf("5. ê²°ê³¼ ì €ì¥\n");
        printf("0. ì¢…ë£Œ\n");
        printf("ì„ íƒ: ");

        int choice;
        if (scanf("%d", &choice) != 1) {
            printf("ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤.\n");
            while (getchar() != '\n');
            continue;
        }

        switch (choice) {
            case 1:
                printf("íŒŒì¼ëª… ì…ë ¥: ");
                scanf("%255s", filename);
                printf("ì„ íƒëœ íŒŒì¼: %s\n", filename);
                break;

            case 2: {
                printf("í•„í„° ì„ íƒ:\n");
                printf("1. ì—†ìŒ\n");
                printf("2. ERROR/WARNING í¬í•¨ ì¤„ë§Œ\n");
                printf("3. ì˜ìˆ«ìë§Œ í¬í•¨ ì¤„ë§Œ\n");
                printf("4. 10ì ì´ìƒ ì¤„ë§Œ\n");
                printf("ì„ íƒ: ");

                int filter_choice;
                if (scanf("%d", &filter_choice) != 1) {
                    printf("ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤.\n");
                    while (getchar() != '\n');
                    continue;
                }

                switch (filter_choice) {
                    case 1: current_filter = NULL; break;
                    case 2: current_filter = filter_contains_keyword; break;
                    case 3: current_filter = filter_alphanumeric_only; break;
                    case 4: current_filter = filter_min_length; break;
                    default:
                        printf("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤.\n");
                        continue;
                }

                printf("í•„í„°ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.\n");
                break;
            }

            case 3:
                if (strlen(filename) == 0) {
                    printf("ë¨¼ì € íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.\n");
                    continue;
                }

                // ê¸°ì¡´ ê²°ê³¼ ì •ë¦¬
                if (result) {
                    free_text_buffer(result);
                    result = NULL;
                }

                printf("íŒŒì¼ ì²˜ë¦¬ ì¤‘...\n");
                ProcessResult proc_result = read_file_with_filter(filename, &result, current_filter);

                switch (proc_result) {
                    case RESULT_SUCCESS:
                        printf("íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ!\n");
                        break;
                    case RESULT_FILE_ERROR:
                        printf("íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨: íŒŒì¼ ì˜¤ë¥˜\n");
                        continue;
                    case RESULT_MEMORY_ERROR:
                        printf("íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨: ë©”ëª¨ë¦¬ ë¶€ì¡±\n");
                        continue;
                    case RESULT_FORMAT_ERROR:
                        printf("íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨: í˜•ì‹ ì˜¤ë¥˜\n");
                        continue;
                    default:
                        printf("ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜\n");
                        continue;
                }
                break;

            case 4:
                if (result == NULL) {
                    printf("ì²˜ë¦¬ëœ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.\n");
                    continue;
                }

                printf("ì²˜ë¦¬ ê²°ê³¼ (%dì¤„):\n", result->count);
                printf("ëª‡ ì¤„ê¹Œì§€ ë³´ì‹œê² ìŠµë‹ˆê¹Œ? (0=ì „ì²´): ");

                int display_count;
                if (scanf("%d", &display_count) != 1) {
                    printf("ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤.\n");
                    while (getchar() != '\n');
                    continue;
                }

                if (display_count == 0 || display_count > result->count) {
                    display_count = result->count;
                }

                for (int i = 0; i < display_count; i++) {
                    printf("%4d: %s\n", i + 1, result->lines[i]);

                    // 10ì¤„ë§ˆë‹¤ ê³„ì† ì—¬ë¶€ í™•ì¸
                    if ((i + 1) % 10 == 0 && i + 1 < display_count) {
                        printf("ê³„ì† ë³´ì‹œê² ìŠµë‹ˆê¹Œ? (y/n): ");
                        char cont;
                        scanf(" %c", &cont);
                        if (cont != 'y' && cont != 'Y') {
                            break;
                        }
                    }
                }
                break;

            case 5:
                if (result == NULL) {
                    printf("ì €ì¥í•  ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.\n");
                    continue;
                }

                printf("ì €ì¥í•  íŒŒì¼ëª… ì…ë ¥: ");
                char output_filename[MAX_FILENAME_LENGTH];
                scanf("%255s", output_filename);

                FILE *output_file = fopen(output_filename, "w");
                if (output_file == NULL) {
                    printf("ì¶œë ¥ íŒŒì¼ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n");
                    continue;
                }

                for (int i = 0; i < result->count; i++) {
                    fprintf(output_file, "%s\n", result->lines[i]);
                }

                fclose(output_file);
                printf("ê²°ê³¼ê°€ %sì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.\n", output_filename);
                break;

            case 0:
                printf("í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.\n");
                goto exit_program;  // ë‹¤ì¤‘ ë£¨í”„ íƒˆì¶œ

            default:
                printf("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤.\n");
                break;
        }
    }

exit_program:
    // ì •ë¦¬
    if (result) {
        free_text_buffer(result);
    }
}
```

### ì‹¤ìŠµ 2: ê²Œì„ ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œ

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

typedef enum {
    GAME_STATE_MENU,
    GAME_STATE_PLAYING,
    GAME_STATE_PAUSED,
    GAME_STATE_GAME_OVER,
    GAME_STATE_EXIT
} GameState;

typedef struct {
    int score;
    int level;
    int lives;
    int time_remaining;
    bool power_up_active;
} GameData;

typedef struct {
    GameState current_state;
    GameState previous_state;
    GameData data;
    bool debug_mode;
} GameContext;

// ê²Œì„ ì´ˆê¸°í™”
void init_game(GameContext *ctx) {
    ctx->current_state = GAME_STATE_MENU;
    ctx->previous_state = GAME_STATE_MENU;
    ctx->data.score = 0;
    ctx->data.level = 1;
    ctx->data.lives = 3;
    ctx->data.time_remaining = 60;
    ctx->data.power_up_active = false;
    ctx->debug_mode = false;
}

// ìƒíƒœ ì „í™˜
void change_state(GameContext *ctx, GameState new_state) {
    if (ctx->debug_mode) {
        printf("[DEBUG] ìƒíƒœ ë³€ê²½: %d -> %d\n", ctx->current_state, new_state);
    }
    ctx->previous_state = ctx->current_state;
    ctx->current_state = new_state;
}

// ë©”ë‰´ ìƒíƒœ ì²˜ë¦¬
GameState handle_menu_state(GameContext *ctx) {
    printf("\n=== ê²Œì„ ë©”ë‰´ ===\n");
    printf("1. ê²Œì„ ì‹œì‘\n");
    printf("2. ê²Œì„ ì´ì–´í•˜ê¸°\n");
    printf("3. ë””ë²„ê·¸ ëª¨ë“œ í† ê¸€\n");
    printf("4. ì¢…ë£Œ\n");
    printf("ì„ íƒ: ");

    int choice;
    if (scanf("%d", &choice) != 1) {
        printf("ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤.\n");
        while (getchar() != '\n');
        return GAME_STATE_MENU;
    }

    switch (choice) {
        case 1:
            // ìƒˆ ê²Œì„ ì‹œì‘
            ctx->data.score = 0;
            ctx->data.level = 1;
            ctx->data.lives = 3;
            ctx->data.time_remaining = 60;
            ctx->data.power_up_active = false;
            printf("ìƒˆ ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤!\n");
            return GAME_STATE_PLAYING;

        case 2:
            if (ctx->previous_state == GAME_STATE_PLAYING ||
                ctx->previous_state == GAME_STATE_PAUSED) {
                printf("ê²Œì„ì„ ì´ì–´ê°‘ë‹ˆë‹¤!\n");
                return GAME_STATE_PLAYING;
            } else {
                printf("ì´ì–´ê°ˆ ê²Œì„ì´ ì—†ìŠµë‹ˆë‹¤.\n");
                return GAME_STATE_MENU;
            }

        case 3:
            ctx->debug_mode = !ctx->debug_mode;
            printf("ë””ë²„ê·¸ ëª¨ë“œ: %s\n", ctx->debug_mode ? "ON" : "OFF");
            return GAME_STATE_MENU;

        case 4:
            printf("ê²Œì„ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.\n");
            return GAME_STATE_EXIT;

        default:
            printf("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤.\n");
            return GAME_STATE_MENU;
    }
}

// ê²Œì„ í”Œë ˆì´ ì‹œë®¬ë ˆì´ì…˜
bool simulate_game_action(GameContext *ctx) {
    // ëœë¤ ì´ë²¤íŠ¸ ìƒì„±
    int event = rand() % 100;

    if (event < 20) {
        // ì ìˆ˜ íšë“
        int points = (rand() % 10 + 1) * ctx->data.level;
        ctx->data.score += points;
        printf("ì ìˆ˜ íšë“! +%d (ì´ì : %d)\n", points, ctx->data.score);
    } else if (event < 30) {
        // íŒŒì›Œì—… íšë“
        ctx->data.power_up_active = true;
        printf("íŒŒì›Œì—… íšë“!\n");
    } else if (event < 35) {
        // ìƒëª… ìƒìŒ
        ctx->data.lives--;
        printf("ìƒëª… ìƒìŒ! (ë‚¨ì€ ìƒëª…: %d)\n", ctx->data.lives);
        if (ctx->data.lives <= 0) {
            return false;  // ê²Œì„ ì˜¤ë²„
        }
    } else if (event < 40) {
        // ë ˆë²¨ ì—…
        ctx->data.level++;
        ctx->data.time_remaining += 30;  // ì‹œê°„ ë³´ë„ˆìŠ¤
        printf("ë ˆë²¨ ì—…! ë ˆë²¨ %d (ì‹œê°„ +30ì´ˆ)\n", ctx->data.level);
    }

    // ì‹œê°„ ê°ì†Œ
    ctx->data.time_remaining--;
    if (ctx->data.time_remaining <= 0) {
        printf("ì‹œê°„ ì´ˆê³¼!\n");
        return false;
    }

    return true;  // ê²Œì„ ê³„ì†
}

// ê²Œì„ í”Œë ˆì´ ìƒíƒœ ì²˜ë¦¬
GameState handle_playing_state(GameContext *ctx) {
    printf("\n=== ê²Œì„ ì¤‘ ===\n");
    printf("ì ìˆ˜: %d | ë ˆë²¨: %d | ìƒëª…: %d | ì‹œê°„: %dì´ˆ\n",
           ctx->data.score, ctx->data.level, ctx->data.lives, ctx->data.time_remaining);

    if (ctx->data.power_up_active) {
        printf("âš¡ íŒŒì›Œì—… í™œì„±í™”!\n");
    }

    printf("\n1. ê²Œì„ ì§„í–‰\n");
    printf("2. ì¼ì‹œì •ì§€\n");
    printf("3. ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°\n");
    printf("ì„ íƒ: ");

    int choice;
    if (scanf("%d", &choice) != 1) {
        printf("ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤.\n");
        while (getchar() != '\n');
        return GAME_STATE_PLAYING;
    }

    switch (choice) {
        case 1: {
            // ê²Œì„ ì•¡ì…˜ ì‹œë®¬ë ˆì´ì…˜
            bool game_continues = true;

            for (int i = 0; i < 3 && game_continues; i++) {  // 3ë²ˆì˜ ì•¡ì…˜
                printf("\n--- ì•¡ì…˜ %d ---\n", i + 1);
                game_continues = simulate_game_action(ctx);

                if (!game_continues) {
                    break;  // ê²Œì„ ì˜¤ë²„ ì¡°ê±´
                }

                // íŒŒì›Œì—… ì§€ì†ì‹œê°„ ê°ì†Œ
                if (ctx->data.power_up_active && rand() % 3 == 0) {
                    ctx->data.power_up_active = false;
                    printf("íŒŒì›Œì—… ì¢…ë£Œ\n");
                }
            }

            if (!game_continues) {
                return GAME_STATE_GAME_OVER;
            }

            return GAME_STATE_PLAYING;
        }

        case 2:
            printf("ê²Œì„ì´ ì¼ì‹œì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.\n");
            return GAME_STATE_PAUSED;

        case 3:
            printf("ë©”ë‰´ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.\n");
            return GAME_STATE_MENU;

        default:
            printf("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤.\n");
            return GAME_STATE_PLAYING;
    }
}

// ì¼ì‹œì •ì§€ ìƒíƒœ ì²˜ë¦¬
GameState handle_paused_state(GameContext *ctx) {
    printf("\n=== ê²Œì„ ì¼ì‹œì •ì§€ ===\n");
    printf("í˜„ì¬ ìƒíƒœ - ì ìˆ˜: %d | ë ˆë²¨: %d | ìƒëª…: %d | ì‹œê°„: %dì´ˆ\n",
           ctx->data.score, ctx->data.level, ctx->data.lives, ctx->data.time_remaining);

    printf("\n1. ê²Œì„ ì¬ê°œ\n");
    printf("2. ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°\n");
    printf("ì„ íƒ: ");

    int choice;
    if (scanf("%d", &choice) != 1) {
        printf("ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤.\n");
        while (getchar() != '\n');
        return GAME_STATE_PAUSED;
    }

    switch (choice) {
        case 1:
            printf("ê²Œì„ì„ ì¬ê°œí•©ë‹ˆë‹¤.\n");
            return GAME_STATE_PLAYING;

        case 2:
            printf("ë©”ë‰´ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.\n");
            return GAME_STATE_MENU;

        default:
            printf("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤.\n");
            return GAME_STATE_PAUSED;
    }
}

// ê²Œì„ ì˜¤ë²„ ìƒíƒœ ì²˜ë¦¬
GameState handle_game_over_state(GameContext *ctx) {
    printf("\n=== ê²Œì„ ì˜¤ë²„ ===\n");
    printf("ìµœì¢… ì ìˆ˜: %d\n", ctx->data.score);
    printf("ë„ë‹¬ ë ˆë²¨: %d\n", ctx->data.level);

    // ì ìˆ˜ì— ë”°ë¥¸ í‰ê°€
    if (ctx->data.score >= 1000) {
        printf("ğŸ† í›Œë¥­í•©ë‹ˆë‹¤! ê³ ë“ì  ë‹¬ì„±!\n");
    } else if (ctx->data.score >= 500) {
        printf("ğŸ‘ ì¢‹ì€ ì ìˆ˜ì…ë‹ˆë‹¤!\n");
    } else {
        printf("ğŸ’ª ë‹¤ìŒì—ëŠ” ë” ì˜í•  ìˆ˜ ìˆì„ ê±°ì˜ˆìš”!\n");
    }

    printf("\n1. ë‹¤ì‹œ í•˜ê¸°\n");
    printf("2. ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°\n");
    printf("3. ì¢…ë£Œ\n");
    printf("ì„ íƒ: ");

    int choice;
    if (scanf("%d", &choice) != 1) {
        printf("ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤.\n");
        while (getchar() != '\n');
        return GAME_STATE_GAME_OVER;
    }

    switch (choice) {
        case 1:
            // ê²Œì„ ë°ì´í„° ì´ˆê¸°í™”
            ctx->data.score = 0;
            ctx->data.level = 1;
            ctx->data.lives = 3;
            ctx->data.time_remaining = 60;
            ctx->data.power_up_active = false;
            printf("ìƒˆ ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤!\n");
            return GAME_STATE_PLAYING;

        case 2:
            return GAME_STATE_MENU;

        case 3:
            return GAME_STATE_EXIT;

        default:
            printf("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤.\n");
            return GAME_STATE_GAME_OVER;
    }
}

// ë©”ì¸ ê²Œì„ ë£¨í”„
void run_game() {
    GameContext ctx;
    init_game(&ctx);
    srand(time(NULL));

    printf("=== ë¸Œëœì¹˜ ì œì–´ ê²Œì„ ì‹œìŠ¤í…œ ===\n");

    // ìƒíƒœ ë¨¸ì‹  ë£¨í”„
    while (ctx.current_state != GAME_STATE_EXIT) {
        GameState next_state;

        switch (ctx.current_state) {
            case GAME_STATE_MENU:
                next_state = handle_menu_state(&ctx);
                break;

            case GAME_STATE_PLAYING:
                next_state = handle_playing_state(&ctx);
                break;

            case GAME_STATE_PAUSED:
                next_state = handle_paused_state(&ctx);
                break;

            case GAME_STATE_GAME_OVER:
                next_state = handle_game_over_state(&ctx);
                break;

            default:
                printf("ì•Œ ìˆ˜ ì—†ëŠ” ìƒíƒœì…ë‹ˆë‹¤. ë©”ë‰´ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.\n");
                next_state = GAME_STATE_MENU;
                break;
        }

        // ìƒíƒœ ì „í™˜
        if (next_state != ctx.current_state) {
            change_state(&ctx, next_state);
        }

        // ê¸´ê¸‰ íƒˆì¶œ (Ctrl+C ì‹œë®¬ë ˆì´ì…˜)
        if (ctx.debug_mode) {
            printf("[DEBUG] ê¸´ê¸‰ ì¢…ë£Œí•˜ë ¤ë©´ 'q' ì…ë ¥: ");
            char emergency;
            if (scanf(" %c", &emergency) == 1 && emergency == 'q') {
                printf("ê¸´ê¸‰ ì¢…ë£Œ!\n");
                break;  // ê²Œì„ ë£¨í”„ íƒˆì¶œ
            }
        }
    }

    printf("ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ê°ì‚¬í•©ë‹ˆë‹¤!\n");
}
```

### ì‹¤ìŠµ 3: ë³µì¡í•œ íŒŒì‹± ì‹œìŠ¤í…œ

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

#define MAX_TOKEN_LENGTH 256
#define MAX_TOKENS 1000

typedef enum {
    TOKEN_NUMBER,
    TOKEN_STRING,
    TOKEN_IDENTIFIER,
    TOKEN_OPERATOR,
    TOKEN_DELIMITER,
    TOKEN_KEYWORD,
    TOKEN_COMMENT,
    TOKEN_UNKNOWN,
    TOKEN_EOF
} TokenType;

typedef struct {
    TokenType type;
    char value[MAX_TOKEN_LENGTH];
    int line;
    int column;
} Token;

typedef struct {
    const char *input;
    int position;
    int line;
    int column;
    Token tokens[MAX_TOKENS];
    int token_count;
} Lexer;

// í‚¤ì›Œë“œ ëª©ë¡
const char *keywords[] = {
    "if", "else", "while", "for", "do", "break", "continue", "return",
    "int", "float", "double", "char", "void", "struct", "typedef",
    NULL
};

// í‚¤ì›Œë“œ í™•ì¸
bool is_keyword(const char *word) {
    for (int i = 0; keywords[i] != NULL; i++) {
        if (strcmp(word, keywords[i]) == 0) {
            return true;
        }
    }
    return false;
}

// ë¬¸ì ë¶„ë¥˜ í•¨ìˆ˜ë“¤
bool is_operator_char(char c) {
    return strchr("+-*/%=!<>&|^~", c) != NULL;
}

bool is_delimiter_char(char c) {
    return strchr("(){}[];,.", c) != NULL;
}

// ê³µë°± ê±´ë„ˆë›°ê¸°
void skip_whitespace(Lexer *lexer) {
    while (lexer->position < strlen(lexer->input)) {
        char c = lexer->input[lexer->position];

        if (c == ' ' || c == '\t') {
            lexer->position++;
            lexer->column++;
            continue;  // ê³µë°± ê³„ì† ê±´ë„ˆë›°ê¸°
        }

        if (c == '\n') {
            lexer->position++;
            lexer->line++;
            lexer->column = 1;
            continue;  // ê°œí–‰ ì²˜ë¦¬ í›„ ê³„ì†
        }

        break;  // ê³µë°±ì´ ì•„ë‹Œ ë¬¸ì ë°œê²¬
    }
}

// ìˆ«ì í† í° íŒŒì‹±
bool parse_number(Lexer *lexer, Token *token) {
    int start_pos = lexer->position;
    bool has_dot = false;

    // ìˆ«ìì™€ ì†Œìˆ˜ì  ì²˜ë¦¬
    while (lexer->position < strlen(lexer->input)) {
        char c = lexer->input[lexer->position];

        if (isdigit(c)) {
            lexer->position++;
            lexer->column++;
            continue;
        }

        if (c == '.' && !has_dot) {
            has_dot = true;
            lexer->position++;
            lexer->column++;
            continue;
        }

        break;  // ìˆ«ìê°€ ì•„ë‹Œ ë¬¸ì ë°œê²¬
    }

    // í† í° ìƒì„±
    int length = lexer->position - start_pos;
    if (length >= MAX_TOKEN_LENGTH) {
        printf("ì˜¤ë¥˜: ìˆ«ìê°€ ë„ˆë¬´ ê¹ë‹ˆë‹¤ (ë¼ì¸ %d)\n", lexer->line);
        return false;
    }

    strncpy(token->value, lexer->input + start_pos, length);
    token->value[length] = '\0';
    token->type = TOKEN_NUMBER;

    return true;
}

// ë¬¸ìì—´ í† í° íŒŒì‹±
bool parse_string(Lexer *lexer, Token *token) {
    char quote_char = lexer->input[lexer->position];  // ' ë˜ëŠ” "
    lexer->position++;  // ì‹œì‘ ë”°ì˜´í‘œ ê±´ë„ˆë›°ê¸°
    lexer->column++;

    int value_pos = 0;

    while (lexer->position < strlen(lexer->input)) {
        char c = lexer->input[lexer->position];

        // ì¢…ë£Œ ë”°ì˜´í‘œ ë°œê²¬
        if (c == quote_char) {
            lexer->position++;
            lexer->column++;
            break;
        }

        // ì´ìŠ¤ì¼€ì´í”„ ì‹œí€€ìŠ¤ ì²˜ë¦¬
        if (c == '\\') {
            lexer->position++;
            lexer->column++;

            if (lexer->position >= strlen(lexer->input)) {
                printf("ì˜¤ë¥˜: ë¬¸ìì—´ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤ (ë¼ì¸ %d)\n", lexer->line);
                return false;
            }

            char escaped = lexer->input[lexer->position];
            switch (escaped) {
                case 'n': token->value[value_pos++] = '\n'; break;
                case 't': token->value[value_pos++] = '\t'; break;
                case 'r': token->value[value_pos++] = '\r'; break;
                case '\\': token->value[value_pos++] = '\\'; break;
                case '\'': token->value[value_pos++] = '\''; break;
                case '\"': token->value[value_pos++] = '\"'; break;
                default:
                    // ì•Œ ìˆ˜ ì—†ëŠ” ì´ìŠ¤ì¼€ì´í”„ ì‹œí€€ìŠ¤
                    token->value[value_pos++] = escaped;
                    break;
            }

            lexer->position++;
            lexer->column++;
            continue;
        }

        // ê°œí–‰ ë¬¸ì ì²˜ë¦¬
        if (c == '\n') {
            printf("ê²½ê³ : ë¬¸ìì—´ ë‚´ ê°œí–‰ (ë¼ì¸ %d)\n", lexer->line);
            lexer->line++;
            lexer->column = 1;
        } else {
            lexer->column++;
        }

        // ë²„í¼ ì˜¤ë²„í”Œë¡œìš° í™•ì¸
        if (value_pos >= MAX_TOKEN_LENGTH - 1) {
            printf("ì˜¤ë¥˜: ë¬¸ìì—´ì´ ë„ˆë¬´ ê¹ë‹ˆë‹¤ (ë¼ì¸ %d)\n", lexer->line);
            return false;
        }

        token->value[value_pos++] = c;
        lexer->position++;
    }

    token->value[value_pos] = '\0';
    token->type = TOKEN_STRING;

    return true;
}

// ì‹ë³„ì/í‚¤ì›Œë“œ í† í° íŒŒì‹±
bool parse_identifier(Lexer *lexer, Token *token) {
    int start_pos = lexer->position;

    // ì²« ë²ˆì§¸ ë¬¸ìëŠ” ì•ŒíŒŒë²³ì´ë‚˜ ì–¸ë”ìŠ¤ì½”ì–´
    if (!isalpha(lexer->input[lexer->position]) && lexer->input[lexer->position] != '_') {
        return false;
    }

    // ë‚˜ë¨¸ì§€ ë¬¸ìë“¤ì€ ì•ŒíŒŒë²³, ìˆ«ì, ì–¸ë”ìŠ¤ì½”ì–´
    while (lexer->position < strlen(lexer->input)) {
        char c = lexer->input[lexer->position];

        if (isalnum(c) || c == '_') {
            lexer->position++;
            lexer->column++;
            continue;
        }

        break;  // ì‹ë³„ìê°€ ì•„ë‹Œ ë¬¸ì ë°œê²¬
    }

    // í† í° ìƒì„±
    int length = lexer->position - start_pos;
    if (length >= MAX_TOKEN_LENGTH) {
        printf("ì˜¤ë¥˜: ì‹ë³„ìê°€ ë„ˆë¬´ ê¹ë‹ˆë‹¤ (ë¼ì¸ %d)\n", lexer->line);
        return false;
    }

    strncpy(token->value, lexer->input + start_pos, length);
    token->value[length] = '\0';

    // í‚¤ì›Œë“œ í™•ì¸
    if (is_keyword(token->value)) {
        token->type = TOKEN_KEYWORD;
    } else {
        token->type = TOKEN_IDENTIFIER;
    }

    return true;
}

// ì£¼ì„ ì²˜ë¦¬
bool skip_comment(Lexer *lexer) {
    if (lexer->position + 1 >= strlen(lexer->input)) {
        return false;
    }

    // í•œ ì¤„ ì£¼ì„ (//)
    if (lexer->input[lexer->position] == '/' &&
        lexer->input[lexer->position + 1] == '/') {

        lexer->position += 2;
        lexer->column += 2;

        // ì¤„ ëê¹Œì§€ ê±´ë„ˆë›°ê¸°
        while (lexer->position < strlen(lexer->input) &&
               lexer->input[lexer->position] != '\n') {
            lexer->position++;
            lexer->column++;
        }

        return true;
    }

    // ë¸”ë¡ ì£¼ì„ (/*)
    if (lexer->input[lexer->position] == '/' &&
        lexer->input[lexer->position + 1] == '*') {

        lexer->position += 2;
        lexer->column += 2;

        // */ ì°¾ì„ ë•Œê¹Œì§€ ê±´ë„ˆë›°ê¸°
        while (lexer->position + 1 < strlen(lexer->input)) {
            if (lexer->input[lexer->position] == '*' &&
                lexer->input[lexer->position + 1] == '/') {
                lexer->position += 2;
                lexer->column += 2;
                return true;
            }

            if (lexer->input[lexer->position] == '\n') {
                lexer->line++;
                lexer->column = 1;
            } else {
                lexer->column++;
            }

            lexer->position++;
        }

        printf("ì˜¤ë¥˜: ë¸”ë¡ ì£¼ì„ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤ (ë¼ì¸ %d)\n", lexer->line);
        return false;
    }

    return false;
}

// ë‹¤ìŒ í† í° ê°€ì ¸ì˜¤ê¸°
bool get_next_token(Lexer *lexer, Token *token) {
    // í† í° ì´ˆê¸°í™”
    token->line = lexer->line;
    token->column = lexer->column;
    token->value[0] = '\0';

    while (lexer->position < strlen(lexer->input)) {
        // ê³µë°± ê±´ë„ˆë›°ê¸°
        skip_whitespace(lexer);

        if (lexer->position >= strlen(lexer->input)) {
            break;  // ì…ë ¥ ë
        }

        char c = lexer->input[lexer->position];

        // ì£¼ì„ í™•ì¸ ë° ê±´ë„ˆë›°ê¸°
        if (c == '/') {
            if (skip_comment(lexer)) {
                continue;  // ì£¼ì„ ê±´ë„ˆë›°ê³  ë‹¤ìŒ í† í° ì°¾ê¸°
            }
        }

        // ìˆ«ì
        if (isdigit(c)) {
            return parse_number(lexer, token);
        }

        // ë¬¸ìì—´
        if (c == '"' || c == '\'') {
            return parse_string(lexer, token);
        }

        // ì‹ë³„ì/í‚¤ì›Œë“œ
        if (isalpha(c) || c == '_') {
            return parse_identifier(lexer, token);
        }

        // ì—°ì‚°ì
        if (is_operator_char(c)) {
            token->value[0] = c;
            token->value[1] = '\0';
            token->type = TOKEN_OPERATOR;

            // ë‘ ë¬¸ì ì—°ì‚°ì í™•ì¸
            if (lexer->position + 1 < strlen(lexer->input)) {
                char next_c = lexer->input[lexer->position + 1];

                // ==, !=, <=, >=, &&, ||, ++, --, <<, >> ë“±
                if ((c == '=' && next_c == '=') ||
                    (c == '!' && next_c == '=') ||
                    (c == '<' && next_c == '=') ||
                    (c == '>' && next_c == '=') ||
                    (c == '&' && next_c == '&') ||
                    (c == '|' && next_c == '|') ||
                    (c == '+' && next_c == '+') ||
                    (c == '-' && next_c == '-') ||
                    (c == '<' && next_c == '<') ||
                    (c == '>' && next_c == '>')) {

                    token->value[1] = next_c;
                    token->value[2] = '\0';
                    lexer->position += 2;
                    lexer->column += 2;
                    return true;
                }
            }

            lexer->position++;
            lexer->column++;
            return true;
        }

        // êµ¬ë¶„ì
        if (is_delimiter_char(c)) {
            token->value[0] = c;
            token->value[1] = '\0';
            token->type = TOKEN_DELIMITER;
            lexer->position++;
            lexer->column++;
            return true;
        }

        // ì•Œ ìˆ˜ ì—†ëŠ” ë¬¸ì
        printf("ê²½ê³ : ì•Œ ìˆ˜ ì—†ëŠ” ë¬¸ì '%c' (ë¼ì¸ %d, ì—´ %d)\n",
               c, lexer->line, lexer->column);
        token->value[0] = c;
        token->value[1] = '\0';
        token->type = TOKEN_UNKNOWN;
        lexer->position++;
        lexer->column++;
        return true;
    }

    // ì…ë ¥ ë
    token->type = TOKEN_EOF;
    strcpy(token->value, "EOF");
    return true;
}

// ì „ì²´ ì…ë ¥ í† í°í™”
bool tokenize(Lexer *lexer, const char *input) {
    lexer->input = input;
    lexer->position = 0;
    lexer->line = 1;
    lexer->column = 1;
    lexer->token_count = 0;

    Token token;

    while (lexer->token_count < MAX_TOKENS) {
        if (!get_next_token(lexer, &token)) {
            printf("í† í°í™” ì‹¤íŒ¨\n");
            return false;
        }

        if (token.type == TOKEN_EOF) {
            break;  // ì…ë ¥ ë
        }

        // í† í° ì €ì¥
        lexer->tokens[lexer->token_count] = token;
        lexer->token_count++;
    }

    return true;
}

// í† í° íƒ€ì… ì´ë¦„ ë°˜í™˜
const char* token_type_name(TokenType type) {
    switch (type) {
        case TOKEN_NUMBER: return "NUMBER";
        case TOKEN_STRING: return "STRING";
        case TOKEN_IDENTIFIER: return "IDENTIFIER";
        case TOKEN_OPERATOR: return "OPERATOR";
        case TOKEN_DELIMITER: return "DELIMITER";
        case TOKEN_KEYWORD: return "KEYWORD";
        case TOKEN_COMMENT: return "COMMENT";
        case TOKEN_UNKNOWN: return "UNKNOWN";
        case TOKEN_EOF: return "EOF";
        default: return "INVALID";
    }
}

// í† í° ì¶œë ¥
void print_tokens(Lexer *lexer) {
    printf("\n=== í† í° ë¶„ì„ ê²°ê³¼ ===\n");
    printf("ì´ %dê°œì˜ í† í°\n\n", lexer->token_count);

    for (int i = 0; i < lexer->token_count; i++) {
        Token *token = &lexer->tokens[i];
        printf("%3d: %-12s '%s' (ë¼ì¸ %d, ì—´ %d)\n",
               i + 1, token_type_name(token->type), token->value,
               token->line, token->column);
    }
}

// ëŒ€í™”í˜• íŒŒì„œ í…ŒìŠ¤íŠ¸
void interactive_parser() {
    char input[4096];
    Lexer lexer;

    printf("=== C ì½”ë“œ íŒŒì„œ í…ŒìŠ¤íŠ¸ ===\n");
    printf("ì¢…ë£Œí•˜ë ¤ë©´ 'exit' ì…ë ¥\n\n");

    while (true) {
        printf("C ì½”ë“œ ì…ë ¥> ");

        // ì—¬ëŸ¬ ì¤„ ì…ë ¥ ì²˜ë¦¬
        if (fgets(input, sizeof(input), stdin) == NULL) {
            break;
        }

        // ì¢…ë£Œ ëª…ë ¹ í™•ì¸
        if (strncmp(input, "exit", 4) == 0) {
            printf("íŒŒì„œë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.\n");
            break;
        }

        // ë¹ˆ ì…ë ¥ ê±´ë„ˆë›°ê¸°
        if (strlen(input) <= 1) {
            continue;
        }

        // í† í°í™” ìˆ˜í–‰
        if (tokenize(&lexer, input)) {
            print_tokens(&lexer);

            // í†µê³„ ì¶œë ¥
            int counts[TOKEN_EOF + 1] = {0};
            for (int i = 0; i < lexer.token_count; i++) {
                counts[lexer.tokens[i].type]++;
            }

            printf("\n--- í† í° í†µê³„ ---\n");
            for (int i = 0; i <= TOKEN_EOF; i++) {
                if (counts[i] > 0) {
                    printf("%-12s: %dê°œ\n", token_type_name(i), counts[i]);
                }
            }
        } else {
            printf("í† í°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\n");
        }

        printf("\n");
    }
}

int main() {
    int choice;

    do {
        printf("\n=== ë¶„ê¸°ë¬¸ ì‹¤ìŠµ í”„ë¡œê·¸ë¨ ===\n");
        printf("1. ê³ ê¸‰ íŒŒì¼ ì²˜ë¦¬ ì‹œìŠ¤í…œ\n");
        printf("2. ê²Œì„ ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œ\n");
        printf("3. ë³µì¡í•œ íŒŒì‹± ì‹œìŠ¤í…œ\n");
        printf("0. ì¢…ë£Œ\n");
        printf("ì„ íƒ: ");

        if (scanf("%d", &choice) != 1) {
            printf("ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤.\n");
            while (getchar() != '\n');
            continue;
        }

        switch (choice) {
            case 1:
                interactive_file_processor();
                break;
            case 2:
                run_game();
                break;
            case 3:
                interactive_parser();
                break;
            case 0:
                printf("í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.\n");
                break;
            default:
                printf("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤.\n");
                break;
        }
    } while (choice != 0);

    return 0;
}
```

## ë§ˆë¬´ë¦¬

ë¶„ê¸°ë¬¸ì€ í”„ë¡œê·¸ë¨ì˜ **ì‹¤í–‰ íë¦„ì„ ì •ë°€í•˜ê²Œ ì œì–´í•˜ëŠ” ê°•ë ¥í•œ ë„êµ¬**ì…ë‹ˆë‹¤. ì ì ˆíˆ ì‚¬ìš©í•˜ë©´ íš¨ìœ¨ì ì´ê³  ëª…í™•í•œ í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•  ìˆ˜ ìˆì§€ë§Œ, ë‚¨ìš©í•˜ë©´ ë³µì¡í•˜ê³  ìœ ì§€ë³´ìˆ˜í•˜ê¸° ì–´ë ¤ìš´ ì½”ë“œê°€ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**í•µì‹¬ í¬ì¸íŠ¸:**

1. **breakì™€ continueì˜ ì ì ˆí•œ í™œìš©**: ë°˜ë³µë¬¸ì—ì„œ íš¨ìœ¨ì ì¸ ì œì–´ íë¦„ êµ¬í˜„
2. **gotoì˜ ì œí•œì  ì‚¬ìš©**: ë¦¬ì†ŒìŠ¤ ì •ë¦¬ë‚˜ ë‹¤ì¤‘ ë£¨í”„ íƒˆì¶œ ë“± íŠ¹ìˆ˜í•œ ê²½ìš°ì—ë§Œ ì‹ ì¤‘íˆ ì‚¬ìš©
3. **êµ¬ì¡°ì  ëŒ€ì•ˆ ì„ í˜¸**: ê°€ëŠ¥í•œ ê²½ìš° í•¨ìˆ˜ ë¶„ë¦¬, í”Œë˜ê·¸ ë³€ìˆ˜ ë“±ìœ¼ë¡œ ëŒ€ì²´
4. **ëª…í™•í•œ ì œì–´ íë¦„**: ë¶„ê¸°ë¬¸ ì‚¬ìš© ì‹œ ì½”ë“œì˜ ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„± ê³ ë ¤
5. **ì˜¤ë¥˜ ì²˜ë¦¬ íŒ¨í„´**: ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ì™€ ì˜ˆì™¸ ìƒí™© ì²˜ë¦¬ì—ì„œ ë¶„ê¸°ë¬¸ì˜ íš¨ê³¼ì  í™œìš©

**ì‹¤ìš©ì  ì¡°ì–¸:**

- ë°˜ë³µë¬¸ì—ì„œ ì¡°ê±´ ë§Œì¡± ì‹œ ì¦‰ì‹œ íƒˆì¶œí•˜ë ¤ë©´ breakë¥¼ ì‚¬ìš©í•˜ì„¸ìš”
- íŠ¹ì • ì¡°ê±´ì˜ ë°ì´í„°ë§Œ ì²˜ë¦¬í•˜ë ¤ë©´ continueë¥¼ í™œìš©í•˜ì„¸ìš”
- gotoëŠ” ê°€ëŠ¥í•œ í”¼í•˜ê³ , ê¼­ í•„ìš”í•œ ê²½ìš°ì—ë§Œ ì œí•œì ìœ¼ë¡œ ì‚¬ìš©í•˜ì„¸ìš”
- ë³µì¡í•œ ì œì–´ íë¦„ì€ í•¨ìˆ˜ë¡œ ë¶„ë¦¬í•˜ì—¬ ë‹¨ìˆœí™”í•˜ì„¸ìš”
- í•­ìƒ ì½”ë“œì˜ ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ ìµœìš°ì„ ìœ¼ë¡œ ê³ ë ¤í•˜ì„¸ìš”

ë¶„ê¸°ë¬¸ì— ëŒ€í•œ ê¹Šì€ ì´í•´ëŠ” ë³µì¡í•œ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„, ì˜¤ë¥˜ ì²˜ë¦¬, ìƒíƒœ ê´€ë¦¬ ë“±ì—ì„œ í•µì‹¬ì ì¸ ì—­í• ì„ í•˜ë©°, ê²¬ê³ í•˜ê³  íš¨ìœ¨ì ì¸ í”„ë¡œê·¸ë¨ ì‘ì„±ì˜ ê¸°ì´ˆê°€ ë©ë‹ˆë‹¤.