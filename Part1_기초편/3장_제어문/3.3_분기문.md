# 3.3 분기문 (Branch Statements)

## 분기문이란 무엇인가?

분기문은 **프로그램의 정상적인 실행 흐름을 변경하여 다른 위치로 제어를 이동시키는 문장**입니다. 이는 단순히 조건문이나 반복문의 순차적 흐름을 벗어나, 프로그램의 실행 경로를 **동적으로 조작**하는 강력한 메커니즘입니다.

### 분기문의 본질적 역할

프로그램은 기본적으로 **순차 실행(Sequential Execution)** 원칙을 따릅니다. 그러나 실제 프로그래밍에서는:

1. **예외 상황 처리**: 오류나 특수한 조건에서 즉시 탈출
2. **효율성 향상**: 불필요한 계산이나 반복 방지
3. **복잡한 제어 흐름**: 다중 중첩 구조에서의 정교한 제어
4. **최적화**: 조기 종료를 통한 성능 개선

이러한 요구사항을 충족하기 위해 분기문이 필요합니다.

### 분기문과 구조적 프로그래밍

구조적 프로그래밍에서는 **제한적이고 규칙적인 분기문 사용**을 권장합니다:

**권장되는 분기문:**
- `break`: 루프나 switch문에서 정상적인 탈출
- `continue`: 루프의 다음 반복으로 이동
- `return`: 함수에서 값을 반환하며 종료

**신중하게 사용해야 할 분기문:**
- `goto`: 임의의 위치로 점프 (스파게티 코드의 원인)

### 분기문과 하드웨어의 관계

분기문은 CPU의 **점프(Jump) 명령어**와 직접 대응됩니다:

```assembly
; 어셈블리 예제 (x86)
JMP  label      ; 무조건 점프 (goto와 유사)
JE   label      ; 같으면 점프 (break 조건부)
JNE  label      ; 다르면 점프 (continue 조건부)
CALL function   ; 함수 호출 (return과 연관)
RET             ; 함수 반환 (return)
```

현대 프로세서는 **분기 예측(Branch Prediction)** 기술을 사용하여 분기문의 성능을 최적화합니다.

## break 문

### break 문의 기본 개념

`break` 문은 현재 실행 중인 **가장 가까운 반복문이나 switch문을 즉시 종료**하고, 해당 구문 다음의 첫 번째 문장으로 제어를 이동시킵니다.

```c
// break의 기본 동작
while (condition) {
    statement1;
    if (special_condition) {
        break;  // while 루프 즉시 종료
    }
    statement2;  // special_condition이 참이면 실행되지 않음
}
// break 시 여기로 이동
```

### switch 문에서의 break

**기본 사용법:**
```c
#include <stdio.h>

void demonstrate_switch_break() {
    int choice = 2;

    switch (choice) {
        case 1:
            printf("선택 1\n");
            break;  // switch문 탈출
        case 2:
            printf("선택 2\n");
            break;  // switch문 탈출
        case 3:
            printf("선택 3\n");
            break;  // switch문 탈출
        default:
            printf("기타 선택\n");
            break;  // 생략 가능하지만 일관성을 위해 권장
    }
    printf("switch 종료 후\n");
}
```

**break 없는 fall-through 활용:**
```c
#include <stdio.h>

void grade_to_description(char grade) {
    printf("학점 %c: ", grade);

    switch (grade) {
        case 'A':
        case 'a':
            printf("우수 ");
            // fall-through (의도적)
        case 'B':
        case 'b':
            printf("양호 이상");
            break;
        case 'C':
        case 'c':
            printf("보통");
            break;
        case 'D':
        case 'd':
            printf("미흡");
            break;
        case 'F':
        case 'f':
            printf("낙제");
            break;
        default:
            printf("잘못된 학점");
            break;
    }
    printf("\n");
}
```

### 반복문에서의 break

**1. 조건 만족 시 즉시 종료**
```c
#include <stdio.h>

int find_first_negative(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("검사 중: arr[%d] = %d\n", i, arr[i]);

        if (arr[i] < 0) {
            printf("첫 번째 음수 발견: 인덱스 %d\n", i);
            return i;  // 함수 자체 종료
        }
    }

    printf("음수를 찾지 못했습니다.\n");
    return -1;
}

// break를 사용한 버전
int find_first_negative_with_break(int arr[], int size) {
    int found_index = -1;

    for (int i = 0; i < size; i++) {
        printf("검사 중: arr[%d] = %d\n", i, arr[i]);

        if (arr[i] < 0) {
            printf("첫 번째 음수 발견: 인덱스 %d\n", i);
            found_index = i;
            break;  // 루프만 종료
        }
    }

    if (found_index == -1) {
        printf("음수를 찾지 못했습니다.\n");
    }

    return found_index;
}
```

**2. 사용자 입력 검증에서 break**
```c
#include <stdio.h>
#include <stdbool.h>

int get_valid_choice(int min, int max) {
    int choice;

    while (true) {  // 무한 루프
        printf("선택하세요 (%d-%d): ", min, max);

        if (scanf("%d", &choice) != 1) {
            printf("잘못된 입력입니다. 숫자를 입력하세요.\n");
            // 입력 버퍼 비우기
            while (getchar() != '\n');
            continue;
        }

        if (choice >= min && choice <= max) {
            break;  // 유효한 입력이면 루프 탈출
        }

        printf("범위를 벗어났습니다. %d부터 %d 사이의 값을 입력하세요.\n",
               min, max);
    }

    return choice;
}
```

**3. 파일 처리에서 break**
```c
#include <stdio.h>
#include <string.h>

bool search_in_file(const char *filename, const char *search_term) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("파일을 열 수 없습니다: %s\n", filename);
        return false;
    }

    char line[256];
    int line_number = 1;
    bool found = false;

    while (fgets(line, sizeof(line), file) != NULL) {
        if (strstr(line, search_term) != NULL) {
            printf("발견! 라인 %d: %s", line_number, line);
            found = true;
            break;  // 첫 번째 발견 시 중단
        }
        line_number++;
    }

    fclose(file);

    if (!found) {
        printf("'%s'를 찾지 못했습니다.\n", search_term);
    }

    return found;
}
```

### 중첩 루프에서의 break 제한

**문제점: break는 가장 가까운 루프만 종료**
```c
#include <stdio.h>

void demonstrate_nested_break_problem() {
    printf("중첩 루프에서 break의 한계:\n");

    for (int i = 1; i <= 3; i++) {
        printf("외부 루프: i = %d\n", i);

        for (int j = 1; j <= 5; j++) {
            printf("  내부 루프: j = %d\n", j);

            if (j == 3) {
                printf("  break 실행!\n");
                break;  // 내부 루프만 종료
            }
        }

        printf("내부 루프 종료, 외부 루프 계속\n");
    }

    printf("모든 루프 종료\n");
}
```

**해결 방법들:**

**1. 플래그 변수 사용**
```c
#include <stdio.h>
#include <stdbool.h>

void nested_break_with_flag() {
    printf("플래그를 이용한 다중 루프 탈출:\n");
    bool should_exit = false;

    for (int i = 1; i <= 3 && !should_exit; i++) {
        printf("외부 루프: i = %d\n", i);

        for (int j = 1; j <= 5; j++) {
            printf("  내부 루프: j = %d\n", j);

            if (i == 2 && j == 3) {
                printf("  조건 만족, 모든 루프 탈출!\n");
                should_exit = true;
                break;
            }
        }
    }

    printf("모든 루프 종료\n");
}
```

**2. 함수로 분리**
```c
#include <stdio.h>

bool process_inner_loop(int i) {
    for (int j = 1; j <= 5; j++) {
        printf("  내부 루프: j = %d\n", j);

        if (i == 2 && j == 3) {
            printf("  조건 만족, 함수에서 반환!\n");
            return true;  // 조기 종료 신호
        }
    }
    return false;  // 정상 완료
}

void nested_break_with_function() {
    printf("함수 분리를 이용한 다중 루프 제어:\n");

    for (int i = 1; i <= 3; i++) {
        printf("외부 루프: i = %d\n", i);

        if (process_inner_loop(i)) {
            break;  // 내부 함수에서 조기 종료 신호 받음
        }
    }

    printf("모든 루프 종료\n");
}
```

**3. goto 사용 (권장하지 않음)**
```c
#include <stdio.h>

void nested_break_with_goto() {
    printf("goto를 이용한 다중 루프 탈출 (권장하지 않음):\n");

    for (int i = 1; i <= 3; i++) {
        printf("외부 루프: i = %d\n", i);

        for (int j = 1; j <= 5; j++) {
            printf("  내부 루프: j = %d\n", j);

            if (i == 2 && j == 3) {
                printf("  조건 만족, goto로 탈출!\n");
                goto exit_all;  // 모든 루프 탈출
            }
        }
    }

exit_all:
    printf("모든 루프 종료\n");
}
```

## continue 문

### continue 문의 기본 개념

`continue` 문은 **현재 반복의 나머지 부분을 건너뛰고**, 반복문의 **다음 반복으로 즉시 이동**합니다. 반복문 자체는 종료되지 않습니다.

```c
// continue의 기본 동작
for (int i = 0; i < 10; i++) {
    if (condition) {
        continue;  // 아래 코드 건너뛰고 i++ 실행 후 다음 반복
    }
    // condition이 참이면 이 부분은 실행되지 않음
}
```

### continue의 반복문별 동작

**1. for 문에서의 continue**
```c
#include <stdio.h>

void demonstrate_continue_in_for() {
    printf("for문에서 continue:\n");

    for (int i = 1; i <= 10; i++) {
        if (i % 2 == 0) {
            continue;  // 짝수는 건너뛰기, i++는 실행됨
        }
        printf("%d ", i);  // 홀수만 출력
    }
    printf("\n");
}
// 출력: 1 3 5 7 9
```

**2. while 문에서의 continue**
```c
#include <stdio.h>

void demonstrate_continue_in_while() {
    printf("while문에서 continue (주의사항):\n");

    int i = 0;
    while (i < 10) {
        i++;  // 반드시 continue 전에 증가!

        if (i % 2 == 0) {
            continue;  // 짝수는 건너뛰기
        }
        printf("%d ", i);  // 홀수만 출력
    }
    printf("\n");
}

// 잘못된 예제 (무한 루프 위험)
void dangerous_continue_in_while() {
    int i = 0;
    while (i < 10) {
        if (i % 2 == 0) {
            continue;  // i++가 실행되지 않아 무한 루프!
        }
        printf("%d ", i);
        i++;
    }
}
```

**3. do-while 문에서의 continue**
```c
#include <stdio.h>

void demonstrate_continue_in_do_while() {
    printf("do-while문에서 continue:\n");

    int i = 0;
    do {
        i++;

        if (i % 3 == 0) {
            continue;  // 3의 배수는 건너뛰기
        }
        printf("%d ", i);
    } while (i < 10);
    printf("\n");
}
// 출력: 1 2 4 5 7 8 10
```

### continue의 실용적 활용

**1. 조건부 데이터 처리**
```c
#include <stdio.h>
#include <ctype.h>
#include <string.h>

void process_valid_characters(const char *input) {
    printf("원본: %s\n", input);
    printf("알파벳만: ");

    for (int i = 0; input[i]; i++) {
        // 알파벳이 아니면 건너뛰기
        if (!isalpha(input[i])) {
            continue;
        }

        printf("%c", toupper(input[i]));
    }
    printf("\n");
}

void process_numbers_only(const char *input) {
    printf("원본: %s\n", input);
    printf("숫자만: ");

    for (int i = 0; input[i]; i++) {
        // 숫자가 아니면 건너뛰기
        if (!isdigit(input[i])) {
            continue;
        }

        printf("%c", input[i]);
    }
    printf("\n");
}
```

**2. 배열의 조건부 처리**
```c
#include <stdio.h>

double calculate_positive_average(double numbers[], int size) {
    double sum = 0;
    int count = 0;

    for (int i = 0; i < size; i++) {
        // 음수나 0은 건너뛰기
        if (numbers[i] <= 0) {
            continue;
        }

        sum += numbers[i];
        count++;
    }

    return count > 0 ? sum / count : 0.0;
}

void print_valid_scores(int scores[], int size) {
    printf("유효한 점수들 (0-100):\n");

    for (int i = 0; i < size; i++) {
        // 유효하지 않은 점수는 건너뛰기
        if (scores[i] < 0 || scores[i] > 100) {
            printf("점수[%d] = %d (무효)\n", i, scores[i]);
            continue;
        }

        printf("점수[%d] = %d\n", i, scores[i]);
    }
}
```

**3. 파일 처리에서 continue**
```c
#include <stdio.h>
#include <string.h>

void process_config_file(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("파일을 열 수 없습니다: %s\n", filename);
        return;
    }

    char line[256];
    int line_number = 0;

    while (fgets(line, sizeof(line), file)) {
        line_number++;

        // 빈 줄 건너뛰기
        if (line[0] == '\n') {
            continue;
        }

        // 주석 줄 건너뛰기
        if (line[0] == '#') {
            continue;
        }

        // 공백으로만 이루어진 줄 건너뛰기
        bool only_spaces = true;
        for (int i = 0; line[i] && line[i] != '\n'; i++) {
            if (line[i] != ' ' && line[i] != '\t') {
                only_spaces = false;
                break;
            }
        }
        if (only_spaces) {
            continue;
        }

        // 유효한 설정 라인 처리
        printf("라인 %d: %s", line_number, line);
    }

    fclose(file);
}
```

**4. 사용자 인터페이스에서 continue**
```c
#include <stdio.h>
#include <stdbool.h>

void interactive_calculator() {
    printf("간단한 계산기 (종료: 'q')\n");

    while (true) {
        double a, b;
        char operator;

        printf("계산식 입력 (예: 3.5 + 2.1): ");

        // 종료 명령 확인
        char first_char;
        scanf(" %c", &first_char);
        if (first_char == 'q' || first_char == 'Q') {
            break;
        }

        // 첫 번째 문자를 다시 입력 스트림에 넣기
        ungetc(first_char, stdin);

        // 계산식 파싱
        if (scanf("%lf %c %lf", &a, &operator, &b) != 3) {
            printf("잘못된 형식입니다. 다시 시도하세요.\n");
            // 입력 버퍼 비우기
            while (getchar() != '\n');
            continue;  // 다음 반복으로
        }

        double result;
        bool valid = true;

        switch (operator) {
            case '+':
                result = a + b;
                break;
            case '-':
                result = a - b;
                break;
            case '*':
                result = a * b;
                break;
            case '/':
                if (b == 0) {
                    printf("오류: 0으로 나눌 수 없습니다.\n");
                    valid = false;
                } else {
                    result = a / b;
                }
                break;
            default:
                printf("지원하지 않는 연산자: %c\n", operator);
                valid = false;
                break;
        }

        if (!valid) {
            continue;  // 오류 시 다음 반복으로
        }

        printf("결과: %.2f %c %.2f = %.2f\n", a, operator, b, result);
    }

    printf("계산기를 종료합니다.\n");
}
```

### continue와 성능 고려사항

**1. 조건 최적화**
```c
// 비효율적: 복잡한 조건을 매번 계산
for (int i = 0; i < size; i++) {
    if (expensive_condition_check(arr[i])) {
        continue;
    }
    process(arr[i]);
}

// 효율적: 조건을 간단히 하거나 캐시
bool *skip_flags = precompute_skip_flags(arr, size);
for (int i = 0; i < size; i++) {
    if (skip_flags[i]) {
        continue;
    }
    process(arr[i]);
}
```

**2. 분기 예측 고려**
```c
// 예측하기 어려운 패턴
for (int i = 0; i < size; i++) {
    if (random_condition()) {  // 예측 불가능
        continue;
    }
    process(arr[i]);
}

// 예측 가능한 패턴
for (int i = 0; i < size; i++) {
    if (i % 10 == 0) {  // 규칙적인 패턴
        continue;
    }
    process(arr[i]);
}
```

## goto 문

### goto 문의 기본 개념

`goto` 문은 프로그램의 **임의의 위치로 무조건 점프**하는 가장 원시적인 분기문입니다. 라벨(label)로 지정된 위치로 직접 이동하며, 모든 구조적 제약을 무시합니다.

```c
// goto의 기본 문법
goto label_name;

// ...다른 코드들...

label_name:
    // 여기로 점프
```

### goto 문의 역사적 배경

**초기 프로그래밍 시대:**
- 어셈블리어에서는 점프가 기본적인 제어 구조
- 초기 고급 언어들도 goto에 크게 의존
- 복잡한 프로그램에서 "스파게티 코드" 문제 발생

**구조적 프로그래밍의 등장:**
- 1968년 다익스트라(Dijkstra)의 "Go To Statement Considered Harmful" 논문
- if-else, while, for 등 구조적 제어문으로 대체 가능
- goto 사용을 최소화하는 프로그래밍 패러다임 확산

### goto 문의 제한적 사용 사례

**1. 다중 중첩 루프에서의 탈출**
```c
#include <stdio.h>

// goto를 사용한 다중 루프 탈출
void find_in_3d_array_goto(int arr[5][5][5], int target) {
    printf("3차원 배열에서 %d 찾기 (goto 사용):\n", target);

    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            for (int k = 0; k < 5; k++) {
                printf("검사: [%d][%d][%d] = %d\n", i, j, k, arr[i][j][k]);

                if (arr[i][j][k] == target) {
                    printf("발견! 위치: [%d][%d][%d]\n", i, j, k);
                    goto found;  // 모든 루프에서 즉시 탈출
                }
            }
        }
    }

    printf("찾지 못했습니다.\n");
    return;

found:
    printf("검색 완료\n");
}

// 구조적 방법으로 개선
bool find_in_3d_array_structural(int arr[5][5][5], int target) {
    printf("3차원 배열에서 %d 찾기 (구조적 방법):\n", target);

    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            for (int k = 0; k < 5; k++) {
                printf("검사: [%d][%d][%d] = %d\n", i, j, k, arr[i][j][k]);

                if (arr[i][j][k] == target) {
                    printf("발견! 위치: [%d][%d][%d]\n", i, j, k);
                    return true;  // 함수 전체 종료
                }
            }
        }
    }

    printf("찾지 못했습니다.\n");
    return false;
}
```

**2. 오류 처리 및 정리 코드**
```c
#include <stdio.h>
#include <stdlib.h>

// goto를 사용한 리소스 정리 패턴
int process_file_with_goto(const char *filename) {
    FILE *file = NULL;
    char *buffer = NULL;
    int *data = NULL;
    int result = -1;

    // 파일 열기
    file = fopen(filename, "r");
    if (file == NULL) {
        printf("파일 열기 실패\n");
        goto cleanup;  // 정리 섹션으로 이동
    }

    // 메모리 할당
    buffer = malloc(1024);
    if (buffer == NULL) {
        printf("버퍼 할당 실패\n");
        goto cleanup;
    }

    data = malloc(sizeof(int) * 100);
    if (data == NULL) {
        printf("데이터 배열 할당 실패\n");
        goto cleanup;
    }

    // 실제 파일 처리
    printf("파일 처리 중...\n");
    // ... 파일 처리 로직 ...

    result = 0;  // 성공

cleanup:
    // 리소스 정리 (순서 중요)
    if (data) {
        free(data);
        printf("데이터 배열 해제\n");
    }
    if (buffer) {
        free(buffer);
        printf("버퍼 해제\n");
    }
    if (file) {
        fclose(file);
        printf("파일 닫기\n");
    }

    return result;
}

// 구조적 방법으로 개선 (함수 분리)
int allocate_resources(FILE **file, char **buffer, int **data, const char *filename) {
    *file = fopen(filename, "r");
    if (*file == NULL) return -1;

    *buffer = malloc(1024);
    if (*buffer == NULL) return -2;

    *data = malloc(sizeof(int) * 100);
    if (*data == NULL) return -3;

    return 0;  // 성공
}

void cleanup_resources(FILE *file, char *buffer, int *data) {
    if (data) free(data);
    if (buffer) free(buffer);
    if (file) fclose(file);
}

int process_file_structural(const char *filename) {
    FILE *file;
    char *buffer;
    int *data;

    int alloc_result = allocate_resources(&file, &buffer, &data, filename);
    if (alloc_result != 0) {
        printf("리소스 할당 실패: %d\n", alloc_result);
        cleanup_resources(file, buffer, data);
        return -1;
    }

    // 실제 파일 처리
    printf("파일 처리 중...\n");
    // ... 파일 처리 로직 ...

    cleanup_resources(file, buffer, data);
    return 0;
}
```

**3. 상태 머신에서의 goto**
```c
#include <stdio.h>
#include <stdbool.h>

typedef enum {
    STATE_START,
    STATE_READING,
    STATE_PROCESSING,
    STATE_WRITING,
    STATE_END,
    STATE_ERROR
} State;

// goto를 사용한 상태 머신 (권장하지 않음)
void state_machine_with_goto() {
    int data = 0;
    bool error_occurred = false;

state_start:
    printf("시작 상태\n");
    data = 10;
    goto state_reading;

state_reading:
    printf("읽기 상태\n");
    if (data < 0) {
        error_occurred = true;
        goto state_error;
    }
    data *= 2;
    goto state_processing;

state_processing:
    printf("처리 상태\n");
    if (data > 100) {
        error_occurred = true;
        goto state_error;
    }
    data += 5;
    goto state_writing;

state_writing:
    printf("쓰기 상태\n");
    printf("최종 데이터: %d\n", data);
    goto state_end;

state_error:
    printf("오류 상태\n");
    printf("데이터: %d\n", data);
    goto state_end;

state_end:
    printf("종료 상태\n");
    return;
}

// 구조적 방법으로 개선
void state_machine_structural() {
    State current_state = STATE_START;
    int data = 0;

    while (current_state != STATE_END && current_state != STATE_ERROR) {
        switch (current_state) {
            case STATE_START:
                printf("시작 상태\n");
                data = 10;
                current_state = STATE_READING;
                break;

            case STATE_READING:
                printf("읽기 상태\n");
                if (data < 0) {
                    current_state = STATE_ERROR;
                } else {
                    data *= 2;
                    current_state = STATE_PROCESSING;
                }
                break;

            case STATE_PROCESSING:
                printf("처리 상태\n");
                if (data > 100) {
                    current_state = STATE_ERROR;
                } else {
                    data += 5;
                    current_state = STATE_WRITING;
                }
                break;

            case STATE_WRITING:
                printf("쓰기 상태\n");
                printf("최종 데이터: %d\n", data);
                current_state = STATE_END;
                break;

            default:
                current_state = STATE_ERROR;
                break;
        }
    }

    if (current_state == STATE_ERROR) {
        printf("오류 상태\n");
        printf("데이터: %d\n", data);
    }

    printf("종료 상태\n");
}
```

### goto 사용 시 주의사항

**1. 변수 초기화 문제**
```c
#include <stdio.h>

void dangerous_goto_example() {
    int choice = 1;

    if (choice == 1) {
        goto skip_initialization;  // 위험!
    }

    int important_var = 100;  // 이 초기화가 건너뛰어짐
    printf("정상 초기화: %d\n", important_var);

skip_initialization:
    printf("important_var 사용: %d\n", important_var);  // 초기화되지 않은 값!
}

// 안전한 방법
void safe_example() {
    int choice = 1;
    int important_var;  // 선언은 위에서

    if (choice == 1) {
        important_var = 200;  // 명시적 초기화
        goto process;
    }

    important_var = 100;  // 다른 경로의 초기화

process:
    printf("important_var 사용: %d\n", important_var);  // 안전
}
```

**2. 스코프 문제**
```c
void scope_problem_example() {
    goto inner_scope;  // 블록 내부로 점프

    {
        int local_var = 42;
inner_scope:
        printf("local_var: %d\n", local_var);  // 정의되지 않은 동작!
    }
}
```

**3. 스파게티 코드 위험**
```c
// 피해야 할 스파게티 코드 예제
void spaghetti_code_example() {
    int i = 0;

start:
    if (i > 10) goto end;
    if (i % 2 == 0) goto even;
    goto odd;

even:
    printf("짝수: %d\n", i);
    i++;
    if (i < 5) goto start;
    goto middle;

odd:
    printf("홀수: %d\n", i);
    i++;
    goto start;

middle:
    printf("중간 처리\n");
    if (i < 8) goto start;

end:
    printf("종료\n");
}
```

### goto의 대안들

**1. 플래그 변수**
```c
#include <stdbool.h>

void alternative_with_flag() {
    bool should_continue = true;
    bool found = false;

    for (int i = 0; i < 10 && should_continue; i++) {
        for (int j = 0; j < 10 && should_continue; j++) {
            if (some_condition(i, j)) {
                found = true;
                should_continue = false;  // 모든 루프 종료
            }
        }
    }

    if (found) {
        // 처리 로직
    }
}
```

**2. 함수 분리**
```c
bool search_in_matrix(int matrix[10][10]) {
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            if (some_condition(i, j)) {
                return true;  // 즉시 반환
            }
        }
    }
    return false;
}

void alternative_with_function() {
    int matrix[10][10];
    // 매트릭스 초기화...

    if (search_in_matrix(matrix)) {
        // 찾았을 때의 처리
    } else {
        // 못 찾았을 때의 처리
    }
}
```

**3. do-while(0) 매크로 패턴**
```c
#define PROCESS_WITH_CLEANUP(condition) do { \
    if (allocate_resource1() != 0) break; \
    if (allocate_resource2() != 0) break; \
    if (!(condition)) break; \
    perform_operation(); \
} while(0); \
cleanup_resources()

void alternative_with_macro() {
    PROCESS_WITH_CLEANUP(some_condition());
}
```

## 분기문 활용 실습

### 실습 1: 고급 파일 처리 시스템

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

#define MAX_LINE_LENGTH 1024
#define MAX_FILENAME_LENGTH 256

typedef enum {
    RESULT_SUCCESS = 0,
    RESULT_FILE_ERROR = -1,
    RESULT_MEMORY_ERROR = -2,
    RESULT_FORMAT_ERROR = -3,
    RESULT_USER_ABORT = -4
} ProcessResult;

typedef struct {
    char **lines;
    int count;
    int capacity;
} TextBuffer;

// 텍스트 버퍼 초기화
TextBuffer* create_text_buffer(int initial_capacity) {
    TextBuffer *buffer = malloc(sizeof(TextBuffer));
    if (buffer == NULL) return NULL;

    buffer->lines = malloc(sizeof(char*) * initial_capacity);
    if (buffer->lines == NULL) {
        free(buffer);
        return NULL;
    }

    buffer->count = 0;
    buffer->capacity = initial_capacity;
    return buffer;
}

// 텍스트 버퍼 정리
void free_text_buffer(TextBuffer *buffer) {
    if (buffer == NULL) return;

    for (int i = 0; i < buffer->count; i++) {
        free(buffer->lines[i]);
    }
    free(buffer->lines);
    free(buffer);
}

// 라인 추가 (동적 확장)
bool add_line_to_buffer(TextBuffer *buffer, const char *line) {
    if (buffer->count >= buffer->capacity) {
        // 용량 2배 확장
        int new_capacity = buffer->capacity * 2;
        char **new_lines = realloc(buffer->lines, sizeof(char*) * new_capacity);
        if (new_lines == NULL) return false;

        buffer->lines = new_lines;
        buffer->capacity = new_capacity;
    }

    buffer->lines[buffer->count] = malloc(strlen(line) + 1);
    if (buffer->lines[buffer->count] == NULL) return false;

    strcpy(buffer->lines[buffer->count], line);
    buffer->count++;
    return true;
}

// 파일 읽기 (에러 처리와 정리 코드 포함)
ProcessResult read_file_with_filter(const char *filename, TextBuffer **result,
                                   bool (*filter_func)(const char *line)) {
    FILE *file = NULL;
    TextBuffer *buffer = NULL;
    char *line_buffer = NULL;
    ProcessResult retval = RESULT_FILE_ERROR;

    // 리소스 할당
    file = fopen(filename, "r");
    if (file == NULL) {
        printf("파일을 열 수 없습니다: %s\n", filename);
        goto cleanup;  // 정리 섹션으로 이동
    }

    buffer = create_text_buffer(100);
    if (buffer == NULL) {
        printf("텍스트 버퍼 생성 실패\n");
        retval = RESULT_MEMORY_ERROR;
        goto cleanup;
    }

    line_buffer = malloc(MAX_LINE_LENGTH);
    if (line_buffer == NULL) {
        printf("라인 버퍼 할당 실패\n");
        retval = RESULT_MEMORY_ERROR;
        goto cleanup;
    }

    // 파일 읽기 및 필터링
    int line_number = 0;
    while (fgets(line_buffer, MAX_LINE_LENGTH, file) != NULL) {
        line_number++;

        // 개행 문자 제거
        line_buffer[strcspn(line_buffer, "\n")] = 0;

        // 빈 줄은 건너뛰기
        if (strlen(line_buffer) == 0) {
            continue;
        }

        // 주석 줄은 건너뛰기
        if (line_buffer[0] == '#') {
            continue;
        }

        // 사용자 정의 필터 적용
        if (filter_func && !filter_func(line_buffer)) {
            continue;
        }

        // 버퍼에 추가
        if (!add_line_to_buffer(buffer, line_buffer)) {
            printf("라인 %d 추가 실패\n", line_number);
            retval = RESULT_MEMORY_ERROR;
            goto cleanup;
        }

        // 진행 상황 표시 (100줄마다)
        if (line_number % 100 == 0) {
            printf("처리 중: %d줄\n", line_number);
        }
    }

    printf("총 %d줄 읽음, %d줄 필터링됨\n", line_number, buffer->count);
    *result = buffer;
    retval = RESULT_SUCCESS;
    buffer = NULL;  // 소유권 이전, cleanup에서 해제되지 않도록

cleanup:
    // 리소스 정리 (역순)
    if (line_buffer) {
        free(line_buffer);
    }
    if (buffer) {
        free_text_buffer(buffer);
    }
    if (file) {
        fclose(file);
    }

    return retval;
}

// 필터 함수들
bool filter_contains_keyword(const char *line) {
    return strstr(line, "ERROR") != NULL || strstr(line, "WARNING") != NULL;
}

bool filter_alphanumeric_only(const char *line) {
    for (int i = 0; line[i]; i++) {
        if (!isalnum(line[i]) && !isspace(line[i])) {
            return false;
        }
    }
    return true;
}

bool filter_min_length(const char *line) {
    return strlen(line) >= 10;
}

// 대화형 파일 처리
void interactive_file_processor() {
    char filename[MAX_FILENAME_LENGTH];
    TextBuffer *result = NULL;
    bool (*current_filter)(const char*) = NULL;

    printf("=== 고급 파일 처리 시스템 ===\n");

    while (true) {
        printf("\n메뉴:\n");
        printf("1. 파일 선택\n");
        printf("2. 필터 설정\n");
        printf("3. 파일 처리\n");
        printf("4. 결과 보기\n");
        printf("5. 결과 저장\n");
        printf("0. 종료\n");
        printf("선택: ");

        int choice;
        if (scanf("%d", &choice) != 1) {
            printf("잘못된 입력입니다.\n");
            while (getchar() != '\n');
            continue;
        }

        switch (choice) {
            case 1:
                printf("파일명 입력: ");
                scanf("%255s", filename);
                printf("선택된 파일: %s\n", filename);
                break;

            case 2: {
                printf("필터 선택:\n");
                printf("1. 없음\n");
                printf("2. ERROR/WARNING 포함 줄만\n");
                printf("3. 영숫자만 포함 줄만\n");
                printf("4. 10자 이상 줄만\n");
                printf("선택: ");

                int filter_choice;
                if (scanf("%d", &filter_choice) != 1) {
                    printf("잘못된 입력입니다.\n");
                    while (getchar() != '\n');
                    continue;
                }

                switch (filter_choice) {
                    case 1: current_filter = NULL; break;
                    case 2: current_filter = filter_contains_keyword; break;
                    case 3: current_filter = filter_alphanumeric_only; break;
                    case 4: current_filter = filter_min_length; break;
                    default:
                        printf("잘못된 선택입니다.\n");
                        continue;
                }

                printf("필터가 설정되었습니다.\n");
                break;
            }

            case 3:
                if (strlen(filename) == 0) {
                    printf("먼저 파일을 선택하세요.\n");
                    continue;
                }

                // 기존 결과 정리
                if (result) {
                    free_text_buffer(result);
                    result = NULL;
                }

                printf("파일 처리 중...\n");
                ProcessResult proc_result = read_file_with_filter(filename, &result, current_filter);

                switch (proc_result) {
                    case RESULT_SUCCESS:
                        printf("파일 처리 완료!\n");
                        break;
                    case RESULT_FILE_ERROR:
                        printf("파일 처리 실패: 파일 오류\n");
                        continue;
                    case RESULT_MEMORY_ERROR:
                        printf("파일 처리 실패: 메모리 부족\n");
                        continue;
                    case RESULT_FORMAT_ERROR:
                        printf("파일 처리 실패: 형식 오류\n");
                        continue;
                    default:
                        printf("알 수 없는 오류\n");
                        continue;
                }
                break;

            case 4:
                if (result == NULL) {
                    printf("처리된 결과가 없습니다.\n");
                    continue;
                }

                printf("처리 결과 (%d줄):\n", result->count);
                printf("몇 줄까지 보시겠습니까? (0=전체): ");

                int display_count;
                if (scanf("%d", &display_count) != 1) {
                    printf("잘못된 입력입니다.\n");
                    while (getchar() != '\n');
                    continue;
                }

                if (display_count == 0 || display_count > result->count) {
                    display_count = result->count;
                }

                for (int i = 0; i < display_count; i++) {
                    printf("%4d: %s\n", i + 1, result->lines[i]);

                    // 10줄마다 계속 여부 확인
                    if ((i + 1) % 10 == 0 && i + 1 < display_count) {
                        printf("계속 보시겠습니까? (y/n): ");
                        char cont;
                        scanf(" %c", &cont);
                        if (cont != 'y' && cont != 'Y') {
                            break;
                        }
                    }
                }
                break;

            case 5:
                if (result == NULL) {
                    printf("저장할 결과가 없습니다.\n");
                    continue;
                }

                printf("저장할 파일명 입력: ");
                char output_filename[MAX_FILENAME_LENGTH];
                scanf("%255s", output_filename);

                FILE *output_file = fopen(output_filename, "w");
                if (output_file == NULL) {
                    printf("출력 파일을 생성할 수 없습니다.\n");
                    continue;
                }

                for (int i = 0; i < result->count; i++) {
                    fprintf(output_file, "%s\n", result->lines[i]);
                }

                fclose(output_file);
                printf("결과가 %s에 저장되었습니다.\n", output_filename);
                break;

            case 0:
                printf("프로그램을 종료합니다.\n");
                goto exit_program;  // 다중 루프 탈출

            default:
                printf("잘못된 선택입니다.\n");
                break;
        }
    }

exit_program:
    // 정리
    if (result) {
        free_text_buffer(result);
    }
}
```

### 실습 2: 게임 상태 관리 시스템

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

typedef enum {
    GAME_STATE_MENU,
    GAME_STATE_PLAYING,
    GAME_STATE_PAUSED,
    GAME_STATE_GAME_OVER,
    GAME_STATE_EXIT
} GameState;

typedef struct {
    int score;
    int level;
    int lives;
    int time_remaining;
    bool power_up_active;
} GameData;

typedef struct {
    GameState current_state;
    GameState previous_state;
    GameData data;
    bool debug_mode;
} GameContext;

// 게임 초기화
void init_game(GameContext *ctx) {
    ctx->current_state = GAME_STATE_MENU;
    ctx->previous_state = GAME_STATE_MENU;
    ctx->data.score = 0;
    ctx->data.level = 1;
    ctx->data.lives = 3;
    ctx->data.time_remaining = 60;
    ctx->data.power_up_active = false;
    ctx->debug_mode = false;
}

// 상태 전환
void change_state(GameContext *ctx, GameState new_state) {
    if (ctx->debug_mode) {
        printf("[DEBUG] 상태 변경: %d -> %d\n", ctx->current_state, new_state);
    }
    ctx->previous_state = ctx->current_state;
    ctx->current_state = new_state;
}

// 메뉴 상태 처리
GameState handle_menu_state(GameContext *ctx) {
    printf("\n=== 게임 메뉴 ===\n");
    printf("1. 게임 시작\n");
    printf("2. 게임 이어하기\n");
    printf("3. 디버그 모드 토글\n");
    printf("4. 종료\n");
    printf("선택: ");

    int choice;
    if (scanf("%d", &choice) != 1) {
        printf("잘못된 입력입니다.\n");
        while (getchar() != '\n');
        return GAME_STATE_MENU;
    }

    switch (choice) {
        case 1:
            // 새 게임 시작
            ctx->data.score = 0;
            ctx->data.level = 1;
            ctx->data.lives = 3;
            ctx->data.time_remaining = 60;
            ctx->data.power_up_active = false;
            printf("새 게임을 시작합니다!\n");
            return GAME_STATE_PLAYING;

        case 2:
            if (ctx->previous_state == GAME_STATE_PLAYING ||
                ctx->previous_state == GAME_STATE_PAUSED) {
                printf("게임을 이어갑니다!\n");
                return GAME_STATE_PLAYING;
            } else {
                printf("이어갈 게임이 없습니다.\n");
                return GAME_STATE_MENU;
            }

        case 3:
            ctx->debug_mode = !ctx->debug_mode;
            printf("디버그 모드: %s\n", ctx->debug_mode ? "ON" : "OFF");
            return GAME_STATE_MENU;

        case 4:
            printf("게임을 종료합니다.\n");
            return GAME_STATE_EXIT;

        default:
            printf("잘못된 선택입니다.\n");
            return GAME_STATE_MENU;
    }
}

// 게임 플레이 시뮬레이션
bool simulate_game_action(GameContext *ctx) {
    // 랜덤 이벤트 생성
    int event = rand() % 100;

    if (event < 20) {
        // 점수 획득
        int points = (rand() % 10 + 1) * ctx->data.level;
        ctx->data.score += points;
        printf("점수 획득! +%d (총점: %d)\n", points, ctx->data.score);
    } else if (event < 30) {
        // 파워업 획득
        ctx->data.power_up_active = true;
        printf("파워업 획득!\n");
    } else if (event < 35) {
        // 생명 잃음
        ctx->data.lives--;
        printf("생명 잃음! (남은 생명: %d)\n", ctx->data.lives);
        if (ctx->data.lives <= 0) {
            return false;  // 게임 오버
        }
    } else if (event < 40) {
        // 레벨 업
        ctx->data.level++;
        ctx->data.time_remaining += 30;  // 시간 보너스
        printf("레벨 업! 레벨 %d (시간 +30초)\n", ctx->data.level);
    }

    // 시간 감소
    ctx->data.time_remaining--;
    if (ctx->data.time_remaining <= 0) {
        printf("시간 초과!\n");
        return false;
    }

    return true;  // 게임 계속
}

// 게임 플레이 상태 처리
GameState handle_playing_state(GameContext *ctx) {
    printf("\n=== 게임 중 ===\n");
    printf("점수: %d | 레벨: %d | 생명: %d | 시간: %d초\n",
           ctx->data.score, ctx->data.level, ctx->data.lives, ctx->data.time_remaining);

    if (ctx->data.power_up_active) {
        printf("⚡ 파워업 활성화!\n");
    }

    printf("\n1. 게임 진행\n");
    printf("2. 일시정지\n");
    printf("3. 메뉴로 돌아가기\n");
    printf("선택: ");

    int choice;
    if (scanf("%d", &choice) != 1) {
        printf("잘못된 입력입니다.\n");
        while (getchar() != '\n');
        return GAME_STATE_PLAYING;
    }

    switch (choice) {
        case 1: {
            // 게임 액션 시뮬레이션
            bool game_continues = true;

            for (int i = 0; i < 3 && game_continues; i++) {  // 3번의 액션
                printf("\n--- 액션 %d ---\n", i + 1);
                game_continues = simulate_game_action(ctx);

                if (!game_continues) {
                    break;  // 게임 오버 조건
                }

                // 파워업 지속시간 감소
                if (ctx->data.power_up_active && rand() % 3 == 0) {
                    ctx->data.power_up_active = false;
                    printf("파워업 종료\n");
                }
            }

            if (!game_continues) {
                return GAME_STATE_GAME_OVER;
            }

            return GAME_STATE_PLAYING;
        }

        case 2:
            printf("게임이 일시정지되었습니다.\n");
            return GAME_STATE_PAUSED;

        case 3:
            printf("메뉴로 돌아갑니다.\n");
            return GAME_STATE_MENU;

        default:
            printf("잘못된 선택입니다.\n");
            return GAME_STATE_PLAYING;
    }
}

// 일시정지 상태 처리
GameState handle_paused_state(GameContext *ctx) {
    printf("\n=== 게임 일시정지 ===\n");
    printf("현재 상태 - 점수: %d | 레벨: %d | 생명: %d | 시간: %d초\n",
           ctx->data.score, ctx->data.level, ctx->data.lives, ctx->data.time_remaining);

    printf("\n1. 게임 재개\n");
    printf("2. 메뉴로 돌아가기\n");
    printf("선택: ");

    int choice;
    if (scanf("%d", &choice) != 1) {
        printf("잘못된 입력입니다.\n");
        while (getchar() != '\n');
        return GAME_STATE_PAUSED;
    }

    switch (choice) {
        case 1:
            printf("게임을 재개합니다.\n");
            return GAME_STATE_PLAYING;

        case 2:
            printf("메뉴로 돌아갑니다.\n");
            return GAME_STATE_MENU;

        default:
            printf("잘못된 선택입니다.\n");
            return GAME_STATE_PAUSED;
    }
}

// 게임 오버 상태 처리
GameState handle_game_over_state(GameContext *ctx) {
    printf("\n=== 게임 오버 ===\n");
    printf("최종 점수: %d\n", ctx->data.score);
    printf("도달 레벨: %d\n", ctx->data.level);

    // 점수에 따른 평가
    if (ctx->data.score >= 1000) {
        printf("🏆 훌륭합니다! 고득점 달성!\n");
    } else if (ctx->data.score >= 500) {
        printf("👍 좋은 점수입니다!\n");
    } else {
        printf("💪 다음에는 더 잘할 수 있을 거예요!\n");
    }

    printf("\n1. 다시 하기\n");
    printf("2. 메뉴로 돌아가기\n");
    printf("3. 종료\n");
    printf("선택: ");

    int choice;
    if (scanf("%d", &choice) != 1) {
        printf("잘못된 입력입니다.\n");
        while (getchar() != '\n');
        return GAME_STATE_GAME_OVER;
    }

    switch (choice) {
        case 1:
            // 게임 데이터 초기화
            ctx->data.score = 0;
            ctx->data.level = 1;
            ctx->data.lives = 3;
            ctx->data.time_remaining = 60;
            ctx->data.power_up_active = false;
            printf("새 게임을 시작합니다!\n");
            return GAME_STATE_PLAYING;

        case 2:
            return GAME_STATE_MENU;

        case 3:
            return GAME_STATE_EXIT;

        default:
            printf("잘못된 선택입니다.\n");
            return GAME_STATE_GAME_OVER;
    }
}

// 메인 게임 루프
void run_game() {
    GameContext ctx;
    init_game(&ctx);
    srand(time(NULL));

    printf("=== 브랜치 제어 게임 시스템 ===\n");

    // 상태 머신 루프
    while (ctx.current_state != GAME_STATE_EXIT) {
        GameState next_state;

        switch (ctx.current_state) {
            case GAME_STATE_MENU:
                next_state = handle_menu_state(&ctx);
                break;

            case GAME_STATE_PLAYING:
                next_state = handle_playing_state(&ctx);
                break;

            case GAME_STATE_PAUSED:
                next_state = handle_paused_state(&ctx);
                break;

            case GAME_STATE_GAME_OVER:
                next_state = handle_game_over_state(&ctx);
                break;

            default:
                printf("알 수 없는 상태입니다. 메뉴로 돌아갑니다.\n");
                next_state = GAME_STATE_MENU;
                break;
        }

        // 상태 전환
        if (next_state != ctx.current_state) {
            change_state(&ctx, next_state);
        }

        // 긴급 탈출 (Ctrl+C 시뮬레이션)
        if (ctx.debug_mode) {
            printf("[DEBUG] 긴급 종료하려면 'q' 입력: ");
            char emergency;
            if (scanf(" %c", &emergency) == 1 && emergency == 'q') {
                printf("긴급 종료!\n");
                break;  // 게임 루프 탈출
            }
        }
    }

    printf("게임이 종료되었습니다. 감사합니다!\n");
}
```

### 실습 3: 복잡한 파싱 시스템

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

#define MAX_TOKEN_LENGTH 256
#define MAX_TOKENS 1000

typedef enum {
    TOKEN_NUMBER,
    TOKEN_STRING,
    TOKEN_IDENTIFIER,
    TOKEN_OPERATOR,
    TOKEN_DELIMITER,
    TOKEN_KEYWORD,
    TOKEN_COMMENT,
    TOKEN_UNKNOWN,
    TOKEN_EOF
} TokenType;

typedef struct {
    TokenType type;
    char value[MAX_TOKEN_LENGTH];
    int line;
    int column;
} Token;

typedef struct {
    const char *input;
    int position;
    int line;
    int column;
    Token tokens[MAX_TOKENS];
    int token_count;
} Lexer;

// 키워드 목록
const char *keywords[] = {
    "if", "else", "while", "for", "do", "break", "continue", "return",
    "int", "float", "double", "char", "void", "struct", "typedef",
    NULL
};

// 키워드 확인
bool is_keyword(const char *word) {
    for (int i = 0; keywords[i] != NULL; i++) {
        if (strcmp(word, keywords[i]) == 0) {
            return true;
        }
    }
    return false;
}

// 문자 분류 함수들
bool is_operator_char(char c) {
    return strchr("+-*/%=!<>&|^~", c) != NULL;
}

bool is_delimiter_char(char c) {
    return strchr("(){}[];,.", c) != NULL;
}

// 공백 건너뛰기
void skip_whitespace(Lexer *lexer) {
    while (lexer->position < strlen(lexer->input)) {
        char c = lexer->input[lexer->position];

        if (c == ' ' || c == '\t') {
            lexer->position++;
            lexer->column++;
            continue;  // 공백 계속 건너뛰기
        }

        if (c == '\n') {
            lexer->position++;
            lexer->line++;
            lexer->column = 1;
            continue;  // 개행 처리 후 계속
        }

        break;  // 공백이 아닌 문자 발견
    }
}

// 숫자 토큰 파싱
bool parse_number(Lexer *lexer, Token *token) {
    int start_pos = lexer->position;
    bool has_dot = false;

    // 숫자와 소수점 처리
    while (lexer->position < strlen(lexer->input)) {
        char c = lexer->input[lexer->position];

        if (isdigit(c)) {
            lexer->position++;
            lexer->column++;
            continue;
        }

        if (c == '.' && !has_dot) {
            has_dot = true;
            lexer->position++;
            lexer->column++;
            continue;
        }

        break;  // 숫자가 아닌 문자 발견
    }

    // 토큰 생성
    int length = lexer->position - start_pos;
    if (length >= MAX_TOKEN_LENGTH) {
        printf("오류: 숫자가 너무 깁니다 (라인 %d)\n", lexer->line);
        return false;
    }

    strncpy(token->value, lexer->input + start_pos, length);
    token->value[length] = '\0';
    token->type = TOKEN_NUMBER;

    return true;
}

// 문자열 토큰 파싱
bool parse_string(Lexer *lexer, Token *token) {
    char quote_char = lexer->input[lexer->position];  // ' 또는 "
    lexer->position++;  // 시작 따옴표 건너뛰기
    lexer->column++;

    int value_pos = 0;

    while (lexer->position < strlen(lexer->input)) {
        char c = lexer->input[lexer->position];

        // 종료 따옴표 발견
        if (c == quote_char) {
            lexer->position++;
            lexer->column++;
            break;
        }

        // 이스케이프 시퀀스 처리
        if (c == '\\') {
            lexer->position++;
            lexer->column++;

            if (lexer->position >= strlen(lexer->input)) {
                printf("오류: 문자열이 완료되지 않았습니다 (라인 %d)\n", lexer->line);
                return false;
            }

            char escaped = lexer->input[lexer->position];
            switch (escaped) {
                case 'n': token->value[value_pos++] = '\n'; break;
                case 't': token->value[value_pos++] = '\t'; break;
                case 'r': token->value[value_pos++] = '\r'; break;
                case '\\': token->value[value_pos++] = '\\'; break;
                case '\'': token->value[value_pos++] = '\''; break;
                case '\"': token->value[value_pos++] = '\"'; break;
                default:
                    // 알 수 없는 이스케이프 시퀀스
                    token->value[value_pos++] = escaped;
                    break;
            }

            lexer->position++;
            lexer->column++;
            continue;
        }

        // 개행 문자 처리
        if (c == '\n') {
            printf("경고: 문자열 내 개행 (라인 %d)\n", lexer->line);
            lexer->line++;
            lexer->column = 1;
        } else {
            lexer->column++;
        }

        // 버퍼 오버플로우 확인
        if (value_pos >= MAX_TOKEN_LENGTH - 1) {
            printf("오류: 문자열이 너무 깁니다 (라인 %d)\n", lexer->line);
            return false;
        }

        token->value[value_pos++] = c;
        lexer->position++;
    }

    token->value[value_pos] = '\0';
    token->type = TOKEN_STRING;

    return true;
}

// 식별자/키워드 토큰 파싱
bool parse_identifier(Lexer *lexer, Token *token) {
    int start_pos = lexer->position;

    // 첫 번째 문자는 알파벳이나 언더스코어
    if (!isalpha(lexer->input[lexer->position]) && lexer->input[lexer->position] != '_') {
        return false;
    }

    // 나머지 문자들은 알파벳, 숫자, 언더스코어
    while (lexer->position < strlen(lexer->input)) {
        char c = lexer->input[lexer->position];

        if (isalnum(c) || c == '_') {
            lexer->position++;
            lexer->column++;
            continue;
        }

        break;  // 식별자가 아닌 문자 발견
    }

    // 토큰 생성
    int length = lexer->position - start_pos;
    if (length >= MAX_TOKEN_LENGTH) {
        printf("오류: 식별자가 너무 깁니다 (라인 %d)\n", lexer->line);
        return false;
    }

    strncpy(token->value, lexer->input + start_pos, length);
    token->value[length] = '\0';

    // 키워드 확인
    if (is_keyword(token->value)) {
        token->type = TOKEN_KEYWORD;
    } else {
        token->type = TOKEN_IDENTIFIER;
    }

    return true;
}

// 주석 처리
bool skip_comment(Lexer *lexer) {
    if (lexer->position + 1 >= strlen(lexer->input)) {
        return false;
    }

    // 한 줄 주석 (//)
    if (lexer->input[lexer->position] == '/' &&
        lexer->input[lexer->position + 1] == '/') {

        lexer->position += 2;
        lexer->column += 2;

        // 줄 끝까지 건너뛰기
        while (lexer->position < strlen(lexer->input) &&
               lexer->input[lexer->position] != '\n') {
            lexer->position++;
            lexer->column++;
        }

        return true;
    }

    // 블록 주석 (/*)
    if (lexer->input[lexer->position] == '/' &&
        lexer->input[lexer->position + 1] == '*') {

        lexer->position += 2;
        lexer->column += 2;

        // */ 찾을 때까지 건너뛰기
        while (lexer->position + 1 < strlen(lexer->input)) {
            if (lexer->input[lexer->position] == '*' &&
                lexer->input[lexer->position + 1] == '/') {
                lexer->position += 2;
                lexer->column += 2;
                return true;
            }

            if (lexer->input[lexer->position] == '\n') {
                lexer->line++;
                lexer->column = 1;
            } else {
                lexer->column++;
            }

            lexer->position++;
        }

        printf("오류: 블록 주석이 완료되지 않았습니다 (라인 %d)\n", lexer->line);
        return false;
    }

    return false;
}

// 다음 토큰 가져오기
bool get_next_token(Lexer *lexer, Token *token) {
    // 토큰 초기화
    token->line = lexer->line;
    token->column = lexer->column;
    token->value[0] = '\0';

    while (lexer->position < strlen(lexer->input)) {
        // 공백 건너뛰기
        skip_whitespace(lexer);

        if (lexer->position >= strlen(lexer->input)) {
            break;  // 입력 끝
        }

        char c = lexer->input[lexer->position];

        // 주석 확인 및 건너뛰기
        if (c == '/') {
            if (skip_comment(lexer)) {
                continue;  // 주석 건너뛰고 다음 토큰 찾기
            }
        }

        // 숫자
        if (isdigit(c)) {
            return parse_number(lexer, token);
        }

        // 문자열
        if (c == '"' || c == '\'') {
            return parse_string(lexer, token);
        }

        // 식별자/키워드
        if (isalpha(c) || c == '_') {
            return parse_identifier(lexer, token);
        }

        // 연산자
        if (is_operator_char(c)) {
            token->value[0] = c;
            token->value[1] = '\0';
            token->type = TOKEN_OPERATOR;

            // 두 문자 연산자 확인
            if (lexer->position + 1 < strlen(lexer->input)) {
                char next_c = lexer->input[lexer->position + 1];

                // ==, !=, <=, >=, &&, ||, ++, --, <<, >> 등
                if ((c == '=' && next_c == '=') ||
                    (c == '!' && next_c == '=') ||
                    (c == '<' && next_c == '=') ||
                    (c == '>' && next_c == '=') ||
                    (c == '&' && next_c == '&') ||
                    (c == '|' && next_c == '|') ||
                    (c == '+' && next_c == '+') ||
                    (c == '-' && next_c == '-') ||
                    (c == '<' && next_c == '<') ||
                    (c == '>' && next_c == '>')) {

                    token->value[1] = next_c;
                    token->value[2] = '\0';
                    lexer->position += 2;
                    lexer->column += 2;
                    return true;
                }
            }

            lexer->position++;
            lexer->column++;
            return true;
        }

        // 구분자
        if (is_delimiter_char(c)) {
            token->value[0] = c;
            token->value[1] = '\0';
            token->type = TOKEN_DELIMITER;
            lexer->position++;
            lexer->column++;
            return true;
        }

        // 알 수 없는 문자
        printf("경고: 알 수 없는 문자 '%c' (라인 %d, 열 %d)\n",
               c, lexer->line, lexer->column);
        token->value[0] = c;
        token->value[1] = '\0';
        token->type = TOKEN_UNKNOWN;
        lexer->position++;
        lexer->column++;
        return true;
    }

    // 입력 끝
    token->type = TOKEN_EOF;
    strcpy(token->value, "EOF");
    return true;
}

// 전체 입력 토큰화
bool tokenize(Lexer *lexer, const char *input) {
    lexer->input = input;
    lexer->position = 0;
    lexer->line = 1;
    lexer->column = 1;
    lexer->token_count = 0;

    Token token;

    while (lexer->token_count < MAX_TOKENS) {
        if (!get_next_token(lexer, &token)) {
            printf("토큰화 실패\n");
            return false;
        }

        if (token.type == TOKEN_EOF) {
            break;  // 입력 끝
        }

        // 토큰 저장
        lexer->tokens[lexer->token_count] = token;
        lexer->token_count++;
    }

    return true;
}

// 토큰 타입 이름 반환
const char* token_type_name(TokenType type) {
    switch (type) {
        case TOKEN_NUMBER: return "NUMBER";
        case TOKEN_STRING: return "STRING";
        case TOKEN_IDENTIFIER: return "IDENTIFIER";
        case TOKEN_OPERATOR: return "OPERATOR";
        case TOKEN_DELIMITER: return "DELIMITER";
        case TOKEN_KEYWORD: return "KEYWORD";
        case TOKEN_COMMENT: return "COMMENT";
        case TOKEN_UNKNOWN: return "UNKNOWN";
        case TOKEN_EOF: return "EOF";
        default: return "INVALID";
    }
}

// 토큰 출력
void print_tokens(Lexer *lexer) {
    printf("\n=== 토큰 분석 결과 ===\n");
    printf("총 %d개의 토큰\n\n", lexer->token_count);

    for (int i = 0; i < lexer->token_count; i++) {
        Token *token = &lexer->tokens[i];
        printf("%3d: %-12s '%s' (라인 %d, 열 %d)\n",
               i + 1, token_type_name(token->type), token->value,
               token->line, token->column);
    }
}

// 대화형 파서 테스트
void interactive_parser() {
    char input[4096];
    Lexer lexer;

    printf("=== C 코드 파서 테스트 ===\n");
    printf("종료하려면 'exit' 입력\n\n");

    while (true) {
        printf("C 코드 입력> ");

        // 여러 줄 입력 처리
        if (fgets(input, sizeof(input), stdin) == NULL) {
            break;
        }

        // 종료 명령 확인
        if (strncmp(input, "exit", 4) == 0) {
            printf("파서를 종료합니다.\n");
            break;
        }

        // 빈 입력 건너뛰기
        if (strlen(input) <= 1) {
            continue;
        }

        // 토큰화 수행
        if (tokenize(&lexer, input)) {
            print_tokens(&lexer);

            // 통계 출력
            int counts[TOKEN_EOF + 1] = {0};
            for (int i = 0; i < lexer.token_count; i++) {
                counts[lexer.tokens[i].type]++;
            }

            printf("\n--- 토큰 통계 ---\n");
            for (int i = 0; i <= TOKEN_EOF; i++) {
                if (counts[i] > 0) {
                    printf("%-12s: %d개\n", token_type_name(i), counts[i]);
                }
            }
        } else {
            printf("토큰화에 실패했습니다.\n");
        }

        printf("\n");
    }
}

int main() {
    int choice;

    do {
        printf("\n=== 분기문 실습 프로그램 ===\n");
        printf("1. 고급 파일 처리 시스템\n");
        printf("2. 게임 상태 관리 시스템\n");
        printf("3. 복잡한 파싱 시스템\n");
        printf("0. 종료\n");
        printf("선택: ");

        if (scanf("%d", &choice) != 1) {
            printf("잘못된 입력입니다.\n");
            while (getchar() != '\n');
            continue;
        }

        switch (choice) {
            case 1:
                interactive_file_processor();
                break;
            case 2:
                run_game();
                break;
            case 3:
                interactive_parser();
                break;
            case 0:
                printf("프로그램을 종료합니다.\n");
                break;
            default:
                printf("잘못된 선택입니다.\n");
                break;
        }
    } while (choice != 0);

    return 0;
}
```

## 마무리

분기문은 프로그램의 **실행 흐름을 정밀하게 제어하는 강력한 도구**입니다. 적절히 사용하면 효율적이고 명확한 프로그램을 작성할 수 있지만, 남용하면 복잡하고 유지보수하기 어려운 코드가 될 수 있습니다.

**핵심 포인트:**

1. **break와 continue의 적절한 활용**: 반복문에서 효율적인 제어 흐름 구현
2. **goto의 제한적 사용**: 리소스 정리나 다중 루프 탈출 등 특수한 경우에만 신중히 사용
3. **구조적 대안 선호**: 가능한 경우 함수 분리, 플래그 변수 등으로 대체
4. **명확한 제어 흐름**: 분기문 사용 시 코드의 가독성과 유지보수성 고려
5. **오류 처리 패턴**: 리소스 관리와 예외 상황 처리에서 분기문의 효과적 활용

**실용적 조언:**

- 반복문에서 조건 만족 시 즉시 탈출하려면 break를 사용하세요
- 특정 조건의 데이터만 처리하려면 continue를 활용하세요
- goto는 가능한 피하고, 꼭 필요한 경우에만 제한적으로 사용하세요
- 복잡한 제어 흐름은 함수로 분리하여 단순화하세요
- 항상 코드의 가독성과 유지보수성을 최우선으로 고려하세요

분기문에 대한 깊은 이해는 복잡한 알고리즘 구현, 오류 처리, 상태 관리 등에서 핵심적인 역할을 하며, 견고하고 효율적인 프로그램 작성의 기초가 됩니다.