# 3.3 분기문 (Jump Statements)

## 분기문의 개념과 본질

### 흐름 제어란 무엇인가?

분기문은 프로그램의 **정상적인 실행 흐름을 의도적으로 변경하는 제어 구조**입니다. 마치 길을 걷다가 갑자기 방향을 바꾸거나, 지름길로 이동하거나, 특정 구간을 건너뛰는 것과 같습니다.

일반적으로 프로그램은 위에서 아래로 순차적으로 실행되지만, 때로는 이 흐름을 바꿔야 하는 상황이 발생합니다. 이때 분기문을 사용하여 프로그램의 제어권을 원하는 위치로 이동시킬 수 있습니다.

### 분기문의 필요성

프로그래밍에서 분기문이 필요한 상황들:

- 특정 조건에서 반복을 중단하고 싶을 때
- 현재 반복을 건너뛰고 다음 반복으로 넘어가고 싶을 때
- 오류가 발생했을 때 즉시 특정 위치로 이동하고 싶을 때
- 복잡한 중첩 구조에서 한 번에 빠져나가고 싶을 때

### 분기문의 종류와 특성

C언어에는 세 가지 주요 분기문이 있습니다:

- **break**: 현재 반복문이나 switch문에서 즉시 탈출
- **continue**: 현재 반복의 나머지를 건너뛰고 다음 반복으로 진행
- **goto**: 프로그램 내의 특정 레이블로 무조건 점프

각각은 서로 다른 목적과 사용 범위를 가지고 있습니다.

## break문 - 즉시 탈출하기

### break문의 원리

break문은 **"지금 즉시 여기서 나가겠다"**는 의미를 가진 분기문입니다. 현재 실행 중인 반복문(for, while, do-while)이나 switch문에서 즉시 벗어나 다음 코드로 진행합니다.

마치 건물에서 비상구를 통해 즉시 밖으로 나가는 것과 같습니다.

### break문의 동작 원리

```c
while (조건) {
    // 코드1
    if (특별한_조건) {
        break;  // 여기서 while문을 즉시 종료
    }
    // 코드2 (break 실행시 건너뜀)
}
// break문 실행시 여기로 이동
```

**실행 과정:**
1. 반복문 또는 switch문 내에서 break 만남
2. 즉시 해당 구문을 종료
3. 해당 구문 다음의 코드로 제어권 이동

### break문이 적합한 상황

- 특정 조건에서 반복을 조기 종료해야 할 때
- 무한루프에서 탈출 조건을 만들 때
- switch문에서 case 간의 구분을 위해
- 중첩 반복문에서 내부 반복문만 종료하고 싶을 때

### 예제: 숫자 찾기 프로그램

```c
#include <stdio.h>

int main() {
    int numbers[] = {3, 7, 2, 9, 1, 5, 4};
    int target = 9;
    int found = 0;

    printf("배열에서 %d를 찾는 중...\n", target);

    for (int i = 0; i < 7; i++) {
        printf("인덱스 %d: %d 확인\n", i, numbers[i]);

        if (numbers[i] == target) {
            printf("찾았습니다! 인덱스 %d에 있습니다.\n", i);
            found = 1;
            break;  // 찾았으니 더 이상 검색하지 않음
        }
    }

    if (!found) {
        printf("찾지 못했습니다.\n");
    }

    return 0;
}
```

## continue문 - 건너뛰고 계속하기

### continue문의 원리

continue문은 **"이번 회차는 건너뛰고 다음으로 넘어가겠다"**는 의미를 가진 분기문입니다. 현재 반복의 나머지 코드를 건너뛰고 다음 반복으로 즉시 진행합니다.

마치 달리기를 하다가 장애물을 만났을 때, 그 장애물만 피해가고 계속 달리는 것과 같습니다.

### continue문의 동작 원리

```c
for (int i = 0; i < 10; i++) {
    // 코드1
    if (건너뛸_조건) {
        continue;  // 코드2를 건너뛰고 다음 반복으로
    }
    // 코드2 (continue 실행시 건너뜀)
}
```

**실행 과정:**
1. 반복문 내에서 continue 만남
2. 현재 반복의 나머지 코드를 건너뜀
3. 반복문의 갱신 부분으로 이동하여 다음 반복 시작

### continue문이 적합한 상황

- 특정 조건의 데이터만 처리하고 나머지는 건너뛰고 싶을 때
- 오류 데이터나 예외 상황을 무시하고 계속 진행하고 싶을 때
- 필터링 로직을 구현할 때
- 복잡한 조건문 대신 간단한 예외 처리를 할 때

### 예제: 짝수만 출력하기

```c
#include <stdio.h>

int main() {
    printf("1부터 10까지의 짝수만 출력:\n");

    for (int i = 1; i <= 10; i++) {
        if (i % 2 != 0) {
            continue;  // 홀수는 건너뛰기
        }

        printf("%d ", i);  // 짝수만 출력
    }

    printf("\n");
    return 0;
}
```

## goto문 - 무조건 점프하기

### goto문의 원리와 논란

goto문은 **프로그램 내의 특정 위치로 무조건 점프**하는 분기문입니다. 매우 강력하지만 동시에 가장 논란이 많은 제어 구조이기도 합니다.

goto문은 "구조적 프로그래밍"의 원칙에 어긋나기 때문에 현대 프로그래밍에서는 사용을 권장하지 않습니다. 하지만 특정 상황에서는 여전히 유용할 수 있습니다.

### goto문의 구조

```c
// 레이블 정의
label_name:
    // 코드

// goto로 점프
goto label_name;
```

### goto문이 적합한 상황 (제한적)

- 깊게 중첩된 반복문에서 한 번에 탈출해야 할 때
- 오류 처리에서 정리 코드로 이동할 때
- 시스템 프로그래밍의 특수한 경우
- 기존 C 코드의 유지보수 시

### 예제: 중첩 반복문 탈출

```c
#include <stdio.h>

int main() {
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 0, 6},
        {7, 8, 9}
    };

    printf("0을 찾는 중...\n");

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("검사: [%d][%d] = %d\n", i, j, matrix[i][j]);

            if (matrix[i][j] == 0) {
                printf("0을 찾았습니다! 위치: [%d][%d]\n", i, j);
                goto found;  // 중첩 반복문을 한 번에 탈출
            }
        }
    }

    printf("0을 찾지 못했습니다.\n");

found:
    printf("검색 완료\n");
    return 0;
}
```

### goto문 사용 시 주의사항

1. **가독성 저하**: 코드의 흐름을 따라가기 어려워짐
2. **디버깅 어려움**: 프로그램의 실행 경로를 추적하기 어려움
3. **유지보수 문제**: 코드 수정 시 예상치 못한 부작용 발생 가능
4. **대안 존재**: 대부분의 경우 다른 제어 구조로 대체 가능

## 분기문 사용의 지혜

### 언제 어떤 분기문을 사용할까?

**break문을 선택하는 경우:**
- 조건을 만족했을 때 반복을 즉시 중단하고 싶을 때
- switch문에서 각 case를 구분할 때
- 무한루프에서 탈출 조건을 구현할 때

**continue문을 선택하는 경우:**
- 특정 조건의 항목만 처리하고 싶을 때
- 예외적인 데이터를 건너뛰고 싶을 때
- 복잡한 조건문을 간단히 만들고 싶을 때

**goto문을 선택하는 경우:**
- 정말 특별한 경우에만 사용
- 다른 방법으로 해결이 어려운 중첩 탈출
- 레거시 코드 유지보수 시

### 분기문 사용의 원칙

1. **명확한 목적**: 왜 분기가 필요한지 명확한 이유가 있어야 함
2. **최소한 사용**: 가능한 한 구조적 프로그래밍 원칙을 따름
3. **대안 검토**: break, continue로 해결 가능한지 먼저 검토
4. **주석 추가**: 분기의 이유와 목적을 명확히 기술

## 실전 예제

### 예제 1: 입력 검증 프로그램

```c
#include <stdio.h>

int main() {
    int number;
    int attempts = 0;
    const int MAX_ATTEMPTS = 3;

    while (attempts < MAX_ATTEMPTS) {
        printf("1부터 100 사이의 정수를 입력하세요: ");
        scanf("%d", &number);
        attempts++;

        if (number < 1 || number > 100) {
            printf("잘못된 입력입니다. ");
            if (attempts >= MAX_ATTEMPTS) {
                printf("시도 횟수를 초과했습니다.\n");
                break;  // 최대 시도 횟수 초과시 종료
            }
            printf("다시 시도하세요.\n");
            continue;  // 잘못된 입력이면 다시 입력받기
        }

        printf("올바른 입력입니다: %d\n", number);
        break;  // 올바른 입력이면 프로그램 종료
    }

    return 0;
}
```

### 예제 2: 메뉴 시스템

```c
#include <stdio.h>

int main() {
    int choice;

    while (1) {  // 무한루프
        printf("\n=== 간단한 계산기 ===\n");
        printf("1. 덧셈\n");
        printf("2. 뺄셈\n");
        printf("3. 곱셈\n");
        printf("4. 나눗셈\n");
        printf("0. 종료\n");
        printf("선택: ");
        scanf("%d", &choice);

        if (choice == 0) {
            printf("프로그램을 종료합니다.\n");
            break;  // 무한루프 탈출
        }

        if (choice < 1 || choice > 4) {
            printf("잘못된 선택입니다.\n");
            continue;  // 잘못된 선택이면 메뉴로 돌아가기
        }

        double a, b, result;
        printf("두 수를 입력하세요: ");
        scanf("%lf %lf", &a, &b);

        switch (choice) {
            case 1:
                result = a + b;
                printf("%.2lf + %.2lf = %.2lf\n", a, b, result);
                break;
            case 2:
                result = a - b;
                printf("%.2lf - %.2lf = %.2lf\n", a, b, result);
                break;
            case 3:
                result = a * b;
                printf("%.2lf * %.2lf = %.2lf\n", a, b, result);
                break;
            case 4:
                if (b != 0) {
                    result = a / b;
                    printf("%.2lf / %.2lf = %.2lf\n", a, b, result);
                } else {
                    printf("0으로 나눌 수 없습니다.\n");
                }
                break;
        }
    }

    return 0;
}
```

## 마무리

분기문은 프로그램의 흐름을 제어하는 **강력한 도구**이지만, **신중하게 사용**해야 하는 기능입니다. 특히 goto문의 경우 가능한 한 사용을 피하고, break와 continue는 코드의 가독성과 유지보수성을 고려하여 적절히 사용하는 것이 좋습니다.

**핵심 기억사항:**
- break: 현재 반복문/switch문에서 즉시 탈출
- continue: 현재 반복의 나머지를 건너뛰고 다음 반복으로
- goto: 특정 레이블로 무조건 점프 (신중하게 사용)

분기문을 올바르게 사용하면 더욱 효율적이고 유연한 프로그램을 작성할 수 있습니다.