# 3.1 조건문 (Conditional Statements)

## 조건문의 핵심 개념

조건문은 **"만약 ~라면"**이라는 일상의 논리적 사고를 코드로 구현하는 핵심 제어문입니다.

### 조건문이 필요한 이유

실생활에서 우리는 끊임없이 조건에 따른 선택을 합니다:

- 비가 오면 → 우산을 챙긴다
- 시험 점수가 90점 이상이면 → A학점을 받는다
- 돈이 충분하면 → 물건을 구입한다

프로그램도 마찬가지로 **상황에 따라 다른 동작**을 해야 하므로 조건문이 필수적입니다.

### 조건문의 동작 원리

조건문의 핵심은 **조건 평가**입니다:

1. **조건 검사** → 주어진 조건이 참(true)인지 거짓(false)인지 판단
2. **분기 실행** → 조건 결과에 따라 서로 다른 코드 실행
3. **흐름 제어** → 프로그램의 실행 순서를 동적으로 변경

### 일상 예시로 이해하는 조건문

**ATM에서 돈을 인출할 때:**

```
만약 (계좌 잔액 >= 인출 금액)이면
    돈을 지급한다
그렇지 않으면
    "잔액 부족" 메시지를 출력한다
```

이것이 바로 조건문의 기본 구조입니다!

## C언어에서 참과 거짓

### 핵심 규칙: 0은 거짓, 나머지는 참

C언어는 간단한 규칙을 사용합니다:

- **0 = 거짓(false)**
- **0이 아닌 모든 값 = 참(true)**

```c
if (1)    // 참 - 실행됨
if (-5)   // 참 - 실행됨
if (0)    // 거짓 - 실행되지 않음
```

### 조건식의 결과

비교 연산의 결과도 0 또는 1입니다:

```c
int a = 5, b = 3;
printf("%d\n", a > b);   // 출력: 1 (참)
printf("%d\n", a < b);   // 출력: 0 (거짓)
```

### 실용적인 조건식 패턴

**1. 변수 값 확인**

```c
int count = 5;
if (count) {          // count가 0이 아니면 실행
    printf("%d개의 항목\n", count);
}
```

**2. 안전한 포인터 검사**

```c
char *name = get_name();
if (name) {           // NULL이 아니면 실행
    printf("이름: %s\n", name);
}
```

**3. 여러 조건 조합**

```c
int age = 25, score = 85;
if (age >= 18 && score >= 80) {  // 둘 다 만족해야 함
    printf("합격!\n");
}
```

### 자주 하는 실수와 해결법

**실수 1: = 와 == 헷갈리기**

```c
int x = 5;

// ❌ 잘못됨 - 대입 연산
if (x = 0) {     // x에 0을 대입, 결과는 거짓
    // 실행되지 않음
}

// ✅ 올바름 - 비교 연산
if (x == 0) {    // x와 0을 비교
    printf("x는 0\n");
}
```

**실수 2: 포인터 검사 없이 사용**

```c
char *name = get_input();

// ❌ 위험함 - NULL일 수 있음
if (strlen(name) > 0) {  // 크래시 가능성
}

// ✅ 안전함 - NULL 검사 먼저
if (name && strlen(name) > 0) {
    printf("이름: %s\n", name);
}
```

## if 문 - 가장 기본적인 조건문

### if 문의 구조

```c
if (조건) {
    // 조건이 참일 때만 실행
}
```

### 간단한 예제

**나이 확인 프로그램**

```c
#include <stdio.h>

int main() {
    int age = 20;

    if (age >= 18) {
        printf("성인입니다\n");
    }

    return 0;
}
```

**점수 등급 표시**

```c
int score = 95;

if (score >= 90) {
    printf("A등급\n");
}

if (score >= 80) {
    printf("B등급 이상\n");
}
```

### if 문 활용 예시

**입력 값 검증**

```c
int number;
scanf("%d", &number);

if (number < 0) {
    printf("음수는 처리할 수 없습니다\n");
    return -1;
}
```

**파일 오류 처리**

```c
FILE *file = fopen("data.txt", "r");

if (file == NULL) {
    printf("파일을 열 수 없습니다\n");
    return -1;
}
```

**권한 확인**

```c
bool is_admin = check_admin_rights();

if (is_admin) {
    printf("관리자 메뉴에 접근 가능\n");
    show_admin_menu();
}
```

## if-else 문 - 양자택일

### if-else 문의 구조

```c
if (조건) {
    // 조건이 참일 때
} else {
    // 조건이 거짓일 때
}
```

**"둘 중 하나"** 상황에서 사용합니다.

### 기본 예제

**짝수/홀수 판별**

```c
int number = 7;

if (number % 2 == 0) {
    printf("짝수\n");
} else {
    printf("홀수\n");
}
```

**성적 판정**

```c
int score = 75;

if (score >= 60) {
    printf("합격\n");
} else {
    printf("불합격\n");
}
```

**더 큰 수 찾기**

```c
int a = 10, b = 20;
int max;

if (a > b) {
    max = a;
} else {
    max = b;
}

printf("더 큰 수: %d\n", max);
```

### else if - 다중 조건 처리

**여러 조건을 순차적으로 검사**할 때 사용합니다:

```c
if (조건1) {
    // 조건1이 참
} else if (조건2) {
    // 조건1은 거짓, 조건2는 참
} else {
    // 모든 조건이 거짓
}
```

### 실용적인 예제

**학점 계산**

```c
int score = 85;

if (score >= 90) {
    printf("A학점\n");
} else if (score >= 80) {
    printf("B학점\n");
} else if (score >= 70) {
    printf("C학점\n");
} else if (score >= 60) {
    printf("D학점\n");
} else {
    printf("F학점\n");
}
```

**계절 판별**

```c
int month = 7;

if (month >= 3 && month <= 5) {
    printf("봄\n");
} else if (month >= 6 && month <= 8) {
    printf("여름\n");
} else if (month >= 9 && month <= 11) {
    printf("가을\n");
} else {
    printf("겨울\n");
}
```

**나이대 분류**

```c
int age = 25;

if (age < 13) {
    printf("어린이\n");
} else if (age < 20) {
    printf("청소년\n");
} else if (age < 65) {
    printf("성인\n");
} else {
    printf("노인\n");
}
```

### 효율적인 조건문 작성 팁

**팁 1: 자주 발생하는 조건을 먼저**

```c
// ✅ 좋음 - 일반적인 경우부터
if (score >= 60) {      // 대부분이 합격
    printf("합격\n");
} else {
    printf("불합격\n");
}
```

**팁 2: 오류 조건을 먼저 확인**

```c
// ✅ 좋음 - 오류를 먼저 처리
if (data == NULL) {
    return ERROR;
}

if (size == 0) {
    return ERROR;
}

// 정상 처리 로직
process_data(data, size);
```

**팁 3: 복잡한 조건은 변수로 분리**

```c
// ✅ 읽기 쉬움
bool is_adult = (age >= 18);
bool has_license = check_driving_license();

if (is_adult && has_license) {
    printf("운전 가능\n");
}
```

## switch 문

### switch 문의 기본 개념

switch 문은 **하나의 변수나 표현식을 여러 상수값과 비교**하여 분기하는 제어문입니다. 연속된 if-else 문보다 효율적이고 가독성이 좋습니다.

```c
switch (표현식) {
    case 상수1:
        // 표현식 == 상수1일 때 실행
        break;
    case 상수2:
        // 표현식 == 상수2일 때 실행
        break;
    default:
        // 일치하는 case가 없을 때 실행
        break;
}
```

### switch 문의 특징과 제약사항

**1. 정수형 표현식만 사용 가능**

```c
int choice = 1;
char grade = 'A';
enum Color {RED, GREEN, BLUE} color = RED;

// 가능한 switch 표현식
switch (choice) { /* ... */ }      // int
switch (grade) { /* ... */ }       // char (정수로 취급)
switch (color) { /* ... */ }       // enum

// 불가능한 switch 표현식
// switch (3.14) { /* ... */ }     // 오류: 부동소수점
// switch ("hello") { /* ... */ }  // 오류: 문자열
```

**2. case 레이블은 컴파일 타임 상수**

```c
const int VALUE = 10;
#define MACRO_VALUE 20

int variable = 30;

switch (choice) {
    case 1:           // OK: 리터럴 상수
    case VALUE:       // OK: const 변수
    case MACRO_VALUE: // OK: 매크로 상수
    // case variable: // 오류: 변수는 불가
        break;
}
```

**3. fall-through 동작**
break 문이 없으면 다음 case로 계속 실행됩니다:

```c
int day = 2;

switch (day) {
    case 1:
        printf("월요일\n");
        // break 없음!
    case 2:
        printf("화요일\n");
        // break 없음!
    case 3:
        printf("수요일\n");
        break;
}
// day가 2일 때 출력: "화요일\n수요일\n"
```

### switch 문의 기본 사용법

**1. 요일 출력기**

```c
#include <stdio.h>

void print_day_name(int day) {
    switch (day) {
        case 1:
            printf("월요일\n");
            break;
        case 2:
            printf("화요일\n");
            break;
        case 3:
            printf("수요일\n");
            break;
        case 4:
            printf("목요일\n");
            break;
        case 5:
            printf("금요일\n");
            break;
        case 6:
            printf("토요일\n");
            break;
        case 7:
            printf("일요일\n");
            break;
        default:
            printf("잘못된 요일입니다 (1-7 입력)\n");
            break;
    }
}
```

**2. 계산기 구현**

```c
#include <stdio.h>

double calculate(double a, double b, char operator) {
    double result = 0.0;

    switch (operator) {
        case '+':
            result = a + b;
            break;
        case '-':
            result = a - b;
            break;
        case '*':
            result = a * b;
            break;
        case '/':
            if (b != 0) {
                result = a / b;
            } else {
                printf("오류: 0으로 나눌 수 없습니다.\n");
                return 0.0;
            }
            break;
        case '%':
            if (b != 0) {
                result = (int)a % (int)b;  // 정수 나머지 연산
            } else {
                printf("오류: 0으로 나눌 수 없습니다.\n");
                return 0.0;
            }
            break;
        default:
            printf("지원하지 않는 연산자: %c\n", operator);
            return 0.0;
    }

    return result;
}
```

### fall-through의 활용

의도적인 fall-through는 유용한 프로그래밍 패턴입니다:

**1. 그룹핑 (여러 case를 하나로 처리)**

```c
#include <ctype.h>

void classify_character(char ch) {
    switch (ch) {
        case 'a':
        case 'e':
        case 'i':
        case 'o':
        case 'u':
        case 'A':
        case 'E':
        case 'I':
        case 'O':
        case 'U':
            printf("모음입니다.\n");
            break;

        case ' ':
        case '\t':
        case '\n':
            printf("공백 문자입니다.\n");
            break;

        default:
            if (isalpha(ch)) {
                printf("자음입니다.\n");
            } else if (isdigit(ch)) {
                printf("숫자입니다.\n");
            } else {
                printf("특수 문자입니다.\n");
            }
            break;
    }
}
```

**2. 순차적 처리 (누적 효과)**

```c
void process_security_level(int level) {
    printf("보안 레벨 %d: ", level);

    switch (level) {
        case 4:
            printf("핵심 기밀 접근 + ");
            // fall through
        case 3:
            printf("관리자 권한 + ");
            // fall through
        case 2:
            printf("사용자 데이터 접근 + ");
            // fall through
        case 1:
            printf("기본 접근");
            break;
        case 0:
            printf("접근 거부");
            break;
        default:
            printf("잘못된 보안 레벨");
            break;
    }
    printf("\n");
}
```

### switch 문의 고급 활용

**1. 함수 포인터 테이블과 조합**

```c
#include <stdio.h>

// 연산 함수들
double add(double a, double b) { return a + b; }
double subtract(double a, double b) { return a - b; }
double multiply(double a, double b) { return a * b; }
double divide(double a, double b) { return b != 0 ? a / b : 0; }

// 함수 포인터를 반환하는 함수
double (*get_operation(char op))(double, double) {
    switch (op) {
        case '+': return add;
        case '-': return subtract;
        case '*': return multiply;
        case '/': return divide;
        default:  return NULL;
    }
}

// 사용 예
void advanced_calculator() {
    double a = 10.0, b = 5.0;
    char operators[] = {'+', '-', '*', '/'};

    for (int i = 0; i < 4; i++) {
        double (*operation)(double, double) = get_operation(operators[i]);
        if (operation != NULL) {
            printf("%.1f %c %.1f = %.1f\n",
                   a, operators[i], b, operation(a, b));
        }
    }
}
```

**2. 상태 머신 구현**

```c
#include <stdio.h>
#include <stdbool.h>

typedef enum {
    STATE_IDLE,
    STATE_RUNNING,
    STATE_PAUSED,
    STATE_STOPPED,
    STATE_ERROR
} SystemState;

typedef enum {
    EVENT_START,
    EVENT_PAUSE,
    EVENT_RESUME,
    EVENT_STOP,
    EVENT_ERROR,
    EVENT_RESET
} SystemEvent;

SystemState process_event(SystemState current_state, SystemEvent event) {
    switch (current_state) {
        case STATE_IDLE:
            switch (event) {
                case EVENT_START:
                    printf("시스템 시작\n");
                    return STATE_RUNNING;
                default:
                    printf("유효하지 않은 이벤트\n");
                    return current_state;
            }

        case STATE_RUNNING:
            switch (event) {
                case EVENT_PAUSE:
                    printf("시스템 일시정지\n");
                    return STATE_PAUSED;
                case EVENT_STOP:
                    printf("시스템 정지\n");
                    return STATE_STOPPED;
                case EVENT_ERROR:
                    printf("시스템 오류 발생\n");
                    return STATE_ERROR;
                default:
                    return current_state;
            }

        case STATE_PAUSED:
            switch (event) {
                case EVENT_RESUME:
                    printf("시스템 재개\n");
                    return STATE_RUNNING;
                case EVENT_STOP:
                    printf("시스템 정지\n");
                    return STATE_STOPPED;
                default:
                    return current_state;
            }

        case STATE_STOPPED:
            switch (event) {
                case EVENT_RESET:
                    printf("시스템 초기화\n");
                    return STATE_IDLE;
                default:
                    return current_state;
            }

        case STATE_ERROR:
            switch (event) {
                case EVENT_RESET:
                    printf("오류 복구 및 초기화\n");
                    return STATE_IDLE;
                default:
                    printf("오류 상태에서는 리셋만 가능합니다\n");
                    return current_state;
            }

        default:
            return STATE_ERROR;
    }
}
```

**3. 메뉴 시스템과 입력 처리**

```c
#include <stdio.h>
#include <stdlib.h>

typedef enum {
    MENU_MAIN,
    MENU_FILE,
    MENU_EDIT,
    MENU_VIEW,
    MENU_EXIT
} MenuType;

void display_main_menu() {
    printf("\n=== 메인 메뉴 ===\n");
    printf("1. 파일\n");
    printf("2. 편집\n");
    printf("3. 보기\n");
    printf("0. 종료\n");
    printf("선택: ");
}

void display_file_menu() {
    printf("\n=== 파일 메뉴 ===\n");
    printf("1. 새로 만들기\n");
    printf("2. 열기\n");
    printf("3. 저장\n");
    printf("0. 메인 메뉴로\n");
    printf("선택: ");
}

MenuType process_main_menu(int choice) {
    switch (choice) {
        case 1:
            return MENU_FILE;
        case 2:
            return MENU_EDIT;
        case 3:
            return MENU_VIEW;
        case 0:
            return MENU_EXIT;
        default:
            printf("잘못된 선택입니다.\n");
            return MENU_MAIN;
    }
}

MenuType process_file_menu(int choice) {
    switch (choice) {
        case 1:
            printf("새 파일을 만듭니다.\n");
            break;
        case 2:
            printf("파일을 엽니다.\n");
            break;
        case 3:
            printf("파일을 저장합니다.\n");
            break;
        case 0:
            return MENU_MAIN;
        default:
            printf("잘못된 선택입니다.\n");
            break;
    }
    return MENU_FILE;
}

void menu_system() {
    MenuType current_menu = MENU_MAIN;
    int choice;

    while (current_menu != MENU_EXIT) {
        switch (current_menu) {
            case MENU_MAIN:
                display_main_menu();
                scanf("%d", &choice);
                current_menu = process_main_menu(choice);
                break;

            case MENU_FILE:
                display_file_menu();
                scanf("%d", &choice);
                current_menu = process_file_menu(choice);
                break;

            case MENU_EDIT:
                printf("편집 메뉴 (구현 예정)\n");
                current_menu = MENU_MAIN;
                break;

            case MENU_VIEW:
                printf("보기 메뉴 (구현 예정)\n");
                current_menu = MENU_MAIN;
                break;

            default:
                current_menu = MENU_MAIN;
                break;
        }
    }

    printf("프로그램을 종료합니다.\n");
}
```

### switch vs if-else 성능 비교

**switch 문의 최적화:**

컴파일러는 switch 문을 다양한 방법으로 최적화합니다:

**1. 점프 테이블 (Jump Table)**

```c
// case 값들이 연속적이고 밀집되어 있을 때
switch (value) {  // value: 0-4
    case 0: return "zero";
    case 1: return "one";
    case 2: return "two";
    case 3: return "three";
    case 4: return "four";
}
// 컴파일러가 점프 테이블로 최적화 → O(1) 시간
```

**2. 이진 검색 트리**

```c
// case 값들이 큰 범위에 분산되어 있을 때
switch (value) {
    case 1: return "one";
    case 100: return "hundred";
    case 1000: return "thousand";
    case 10000: return "ten thousand";
}
// 컴파일러가 이진 검색으로 최적화 → O(log n) 시간
```

**성능 테스트 예제:**

```c
#include <time.h>

// switch 버전
int test_switch(int value) {
    switch (value) {
        case 1: return 10;
        case 2: return 20;
        case 3: return 30;
        case 4: return 40;
        case 5: return 50;
        default: return 0;
    }
}

// if-else 버전
int test_if_else(int value) {
    if (value == 1) return 10;
    else if (value == 2) return 20;
    else if (value == 3) return 30;
    else if (value == 4) return 40;
    else if (value == 5) return 50;
    else return 0;
}

void performance_comparison() {
    const int ITERATIONS = 10000000;
    clock_t start, end;

    // switch 테스트
    start = clock();
    for (int i = 0; i < ITERATIONS; i++) {
        test_switch(i % 5 + 1);
    }
    end = clock();
    printf("Switch: %.3f초\n",
           ((double)(end - start)) / CLOCKS_PER_SEC);

    // if-else 테스트
    start = clock();
    for (int i = 0; i < ITERATIONS; i++) {
        test_if_else(i % 5 + 1);
    }
    end = clock();
    printf("If-else: %.3f초\n",
           ((double)(end - start)) / CLOCKS_PER_SEC);
}
```

## 조건문 활용 실습

### 실습 1: 윤년 판별 프로그램

```c
#include <stdio.h>
#include <stdbool.h>

bool is_leap_year(int year) {
    // 윤년 규칙:
    // 1. 4로 나누어떨어지면 윤년
    // 2. 단, 100으로 나누어떨어지면 평년
    // 3. 단, 400으로 나누어떨어지면 윤년

    if (year % 400 == 0) {
        return true;   // 400의 배수는 윤년
    } else if (year % 100 == 0) {
        return false;  // 100의 배수(400 제외)는 평년
    } else if (year % 4 == 0) {
        return true;   // 4의 배수(100 제외)는 윤년
    } else {
        return false;  // 나머지는 평년
    }
}

int days_in_month(int year, int month) {
    switch (month) {
        case 1: case 3: case 5: case 7:
        case 8: case 10: case 12:
            return 31;
        case 4: case 6: case 9: case 11:
            return 30;
        case 2:
            return is_leap_year(year) ? 29 : 28;
        default:
            return -1;  // 잘못된 월
    }
}

void print_calendar_info(int year, int month) {
    if (month < 1 || month > 12) {
        printf("잘못된 월입니다 (1-12 입력)\n");
        return;
    }

    const char* month_names[] = {
        "", "1월", "2월", "3월", "4월", "5월", "6월",
        "7월", "8월", "9월", "10월", "11월", "12월"
    };

    int days = days_in_month(year, month);

    printf("\n=== %d년 %s 정보 ===\n", year, month_names[month]);
    printf("일 수: %d일\n", days);

    if (month == 2) {
        if (is_leap_year(year)) {
            printf("윤년입니다 (2월이 29일까지 있습니다)\n");
        } else {
            printf("평년입니다 (2월이 28일까지 있습니다)\n");
        }
    }
}

int main() {
    int year, month;

    printf("연도와 월을 입력하세요: ");
    if (scanf("%d %d", &year, &month) != 2) {
        printf("잘못된 입력입니다.\n");
        return 1;
    }

    print_calendar_info(year, month);

    return 0;
}
```

### 실습 2: 학생 성적 관리 시스템

```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

typedef struct {
    char name[50];
    int korean;
    int english;
    int math;
    double average;
    char grade;
} Student;

char calculate_grade(double average) {
    if (average >= 90) return 'A';
    else if (average >= 80) return 'B';
    else if (average >= 70) return 'C';
    else if (average >= 60) return 'D';
    else return 'F';
}

const char* get_grade_description(char grade) {
    switch (grade) {
        case 'A': return "우수";
        case 'B': return "양호";
        case 'C': return "보통";
        case 'D': return "미흡";
        case 'F': return "낙제";
        default:  return "알 수 없음";
    }
}

bool is_pass(char grade) {
    return grade != 'F';
}

void calculate_student_info(Student *student) {
    student->average = (student->korean + student->english + student->math) / 3.0;
    student->grade = calculate_grade(student->average);
}

void print_student_info(const Student *student) {
    printf("\n=== 학생 정보 ===\n");
    printf("이름: %s\n", student->name);
    printf("국어: %d점\n", student->korean);
    printf("영어: %d점\n", student->english);
    printf("수학: %d점\n", student->math);
    printf("평균: %.1f점\n", student->average);
    printf("학점: %c (%s)\n", student->grade, get_grade_description(student->grade));

    if (is_pass(student->grade)) {
        printf("결과: 합격\n");

        if (student->grade == 'A') {
            printf("축하합니다! 우수한 성적입니다.\n");
        } else if (student->grade == 'B') {
            printf("좋은 성적입니다.\n");
        }
    } else {
        printf("결과: 불합격\n");
        printf("더 열심히 공부하세요.\n");
    }

    // 과목별 조언
    printf("\n=== 과목별 분석 ===\n");

    int scores[] = {student->korean, student->english, student->math};
    const char* subjects[] = {"국어", "영어", "수학"};

    for (int i = 0; i < 3; i++) {
        printf("%s: ", subjects[i]);

        if (scores[i] >= 90) {
            printf("매우 우수\n");
        } else if (scores[i] >= 80) {
            printf("우수\n");
        } else if (scores[i] >= 70) {
            printf("보통\n");
        } else if (scores[i] >= 60) {
            printf("미흡\n");
        } else {
            printf("매우 미흡 - 보충 학습 필요\n");
        }
    }
}

bool input_student_info(Student *student) {
    printf("학생 이름: ");
    if (scanf("%49s", student->name) != 1) {
        return false;
    }

    printf("국어 점수 (0-100): ");
    if (scanf("%d", &student->korean) != 1 ||
        student->korean < 0 || student->korean > 100) {
        printf("잘못된 국어 점수입니다.\n");
        return false;
    }

    printf("영어 점수 (0-100): ");
    if (scanf("%d", &student->english) != 1 ||
        student->english < 0 || student->english > 100) {
        printf("잘못된 영어 점수입니다.\n");
        return false;
    }

    printf("수학 점수 (0-100): ");
    if (scanf("%d", &student->math) != 1 ||
        student->math < 0 || student->math > 100) {
        printf("잘못된 수학 점수입니다.\n");
        return false;
    }

    return true;
}

int main() {
    Student student;

    printf("=== 학생 성적 관리 시스템 ===\n");

    if (!input_student_info(&student)) {
        printf("입력 오류가 발생했습니다.\n");
        return 1;
    }

    calculate_student_info(&student);
    print_student_info(&student);

    return 0;
}
```

### 실습 3: 간단한 텍스트 어드벤처 게임

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

typedef struct {
    int health;
    int attack;
    int gold;
    bool has_sword;
    bool has_shield;
} Player;

typedef enum {
    LOCATION_START,
    LOCATION_FOREST,
    LOCATION_CAVE,
    LOCATION_TREASURE,
    LOCATION_MONSTER,
    LOCATION_SHOP,
    LOCATION_END
} Location;

void init_player(Player *player) {
    player->health = 100;
    player->attack = 10;
    player->gold = 50;
    player->has_sword = false;
    player->has_shield = false;
}

void print_player_status(const Player *player) {
    printf("\n=== 플레이어 상태 ===\n");
    printf("체력: %d\n", player->health);
    printf("공격력: %d\n", player->attack);
    printf("골드: %d\n", player->gold);
    printf("장비: ");

    if (player->has_sword && player->has_shield) {
        printf("검, 방패\n");
    } else if (player->has_sword) {
        printf("검\n");
    } else if (player->has_shield) {
        printf("방패\n");
    } else {
        printf("없음\n");
    }
}

Location process_start_location() {
    int choice;

    printf("\n=== 모험의 시작 ===\n");
    printf("당신은 작은 마을 앞에 서 있습니다.\n");
    printf("어디로 가시겠습니까?\n");
    printf("1. 숲으로 가기\n");
    printf("2. 동굴로 가기\n");
    printf("3. 상점으로 가기\n");
    printf("선택: ");

    scanf("%d", &choice);

    switch (choice) {
        case 1: return LOCATION_FOREST;
        case 2: return LOCATION_CAVE;
        case 3: return LOCATION_SHOP;
        default:
            printf("잘못된 선택입니다. 숲으로 향합니다.\n");
            return LOCATION_FOREST;
    }
}

Location process_forest_location(Player *player) {
    printf("\n=== 숲 ===\n");
    printf("숲에서 나무열매를 발견했습니다!\n");

    int heal_amount = 10 + rand() % 21;  // 10-30 회복
    player->health += heal_amount;
    if (player->health > 100) player->health = 100;

    printf("체력이 %d만큼 회복되었습니다.\n", heal_amount);

    if (rand() % 3 == 0) {  // 1/3 확률로 몬스터 출현
        printf("갑자기 몬스터가 나타났습니다!\n");
        return LOCATION_MONSTER;
    }

    printf("안전하게 숲을 지나갔습니다.\n");
    return LOCATION_START;
}

Location process_cave_location(Player *player) {
    printf("\n=== 동굴 ===\n");
    printf("어두운 동굴에 들어갔습니다.\n");

    if (rand() % 2 == 0) {  // 1/2 확률로 보물 발견
        printf("반짝이는 보물을 발견했습니다!\n");
        return LOCATION_TREASURE;
    } else {  // 1/2 확률로 몬스터 출현
        printf("동굴 깊숙한 곳에서 으르렁거리는 소리가 들립니다...\n");
        return LOCATION_MONSTER;
    }
}

Location process_treasure_location(Player *player) {
    printf("\n=== 보물 발견! ===\n");

    int treasure_type = rand() % 3;

    switch (treasure_type) {
        case 0: {
            int gold_found = 20 + rand() % 31;  // 20-50 골드
            player->gold += gold_found;
            printf("%d 골드를 발견했습니다!\n", gold_found);
            break;
        }
        case 1:
            if (!player->has_sword) {
                player->has_sword = true;
                player->attack += 10;
                printf("마법의 검을 발견했습니다! 공격력이 10 증가했습니다.\n");
            } else {
                int gold_found = 30;
                player->gold += gold_found;
                printf("이미 검을 가지고 있어서 %d 골드를 얻었습니다.\n", gold_found);
            }
            break;
        case 2:
            if (!player->has_shield) {
                player->has_shield = true;
                printf("튼튼한 방패를 발견했습니다! 방어력이 증가했습니다.\n");
            } else {
                int gold_found = 25;
                player->gold += gold_found;
                printf("이미 방패를 가지고 있어서 %d 골드를 얻었습니다.\n", gold_found);
            }
            break;
    }

    return LOCATION_START;
}

Location process_monster_location(Player *player) {
    printf("\n=== 몬스터와의 전투! ===\n");

    int monster_health = 30 + rand() % 21;  // 30-50 체력
    int monster_attack = 8 + rand() % 5;    // 8-12 공격력

    printf("몬스터가 나타났습니다! (체력: %d, 공격력: %d)\n",
           monster_health, monster_attack);

    while (monster_health > 0 && player->health > 0) {
        printf("\n행동을 선택하세요:\n");
        printf("1. 공격\n");
        printf("2. 도망\n");
        printf("선택: ");

        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1: {
                // 플레이어 공격
                int damage = player->attack + rand() % 6 - 2;  // ±2 변동
                if (damage < 1) damage = 1;

                monster_health -= damage;
                printf("몬스터에게 %d 데미지를 입혔습니다!\n", damage);

                if (monster_health <= 0) {
                    printf("몬스터를 처치했습니다!\n");

                    int reward = 15 + rand() % 16;  // 15-30 골드
                    player->gold += reward;
                    printf("%d 골드를 획득했습니다!\n", reward);

                    return LOCATION_START;
                }

                // 몬스터 반격
                int monster_damage = monster_attack + rand() % 4 - 1;
                if (player->has_shield) {
                    monster_damage -= 3;  // 방패로 데미지 감소
                }
                if (monster_damage < 1) monster_damage = 1;

                player->health -= monster_damage;
                printf("몬스터가 %d 데미지를 입혔습니다! (남은 체력: %d)\n",
                       monster_damage, player->health);

                if (player->health <= 0) {
                    printf("당신은 쓰러졌습니다...\n");
                    return LOCATION_END;
                }
                break;
            }
            case 2:
                printf("도망쳤습니다!\n");
                if (rand() % 3 == 0) {  // 1/3 확률로 도망 실패
                    int flee_damage = monster_attack / 2;
                    player->health -= flee_damage;
                    printf("도망치다가 %d 데미지를 받았습니다!\n", flee_damage);
                }
                return LOCATION_START;
            default:
                printf("잘못된 선택입니다. 공격합니다!\n");
                choice = 1;  // 강제로 공격으로 변경
                break;
        }
    }

    return LOCATION_START;
}

Location process_shop_location(Player *player) {
    printf("\n=== 상점 ===\n");
    printf("상인: 어서오세요! 무엇을 원하시나요?\n");

    while (true) {
        printf("\n상점 목록:\n");
        printf("1. 체력 물약 (20골드) - 체력 50 회복\n");
        printf("2. 검 (50골드) - 공격력 10 증가\n");
        printf("3. 방패 (40골드) - 방어력 증가\n");
        printf("4. 나가기\n");
        printf("소지금: %d골드\n", player->gold);
        printf("선택: ");

        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                if (player->gold >= 20) {
                    if (player->health >= 100) {
                        printf("이미 체력이 가득찼습니다.\n");
                    } else {
                        player->gold -= 20;
                        player->health += 50;
                        if (player->health > 100) player->health = 100;
                        printf("체력이 회복되었습니다!\n");
                    }
                } else {
                    printf("골드가 부족합니다.\n");
                }
                break;

            case 2:
                if (player->has_sword) {
                    printf("이미 검을 가지고 있습니다.\n");
                } else if (player->gold >= 50) {
                    player->gold -= 50;
                    player->has_sword = true;
                    player->attack += 10;
                    printf("검을 구입했습니다! 공격력이 증가했습니다.\n");
                } else {
                    printf("골드가 부족합니다.\n");
                }
                break;

            case 3:
                if (player->has_shield) {
                    printf("이미 방패를 가지고 있습니다.\n");
                } else if (player->gold >= 40) {
                    player->gold -= 40;
                    player->has_shield = true;
                    printf("방패를 구입했습니다! 방어력이 증가했습니다.\n");
                } else {
                    printf("골드가 부족합니다.\n");
                }
                break;

            case 4:
                printf("상인: 또 오세요!\n");
                return LOCATION_START;

            default:
                printf("잘못된 선택입니다.\n");
                break;
        }
    }
}

void text_adventure_game() {
    srand(time(NULL));  // 랜덤 시드 초기화

    Player player;
    init_player(&player);

    Location current_location = LOCATION_START;
    int turn_count = 0;

    printf("=== 텍스트 어드벤처 게임 ===\n");
    printf("용감한 모험가가 되어 보물을 찾아보세요!\n");

    while (current_location != LOCATION_END && player.health > 0) {
        turn_count++;

        if (turn_count % 5 == 0) {  // 5턴마다 상태 표시
            print_player_status(&player);
        }

        switch (current_location) {
            case LOCATION_START:
                current_location = process_start_location();
                break;
            case LOCATION_FOREST:
                current_location = process_forest_location(&player);
                break;
            case LOCATION_CAVE:
                current_location = process_cave_location(&player);
                break;
            case LOCATION_TREASURE:
                current_location = process_treasure_location(&player);
                break;
            case LOCATION_MONSTER:
                current_location = process_monster_location(&player);
                break;
            case LOCATION_SHOP:
                current_location = process_shop_location(&player);
                break;
            default:
                printf("알 수 없는 위치입니다.\n");
                current_location = LOCATION_START;
                break;
        }

        // 게임 종료 조건 체크
        if (turn_count >= 20) {
            printf("\n시간이 너무 오래 지났습니다. 마을로 돌아갑니다.\n");
            break;
        }
    }

    // 게임 결과
    printf("\n=== 게임 종료 ===\n");
    print_player_status(&player);
    printf("총 %d턴 진행했습니다.\n", turn_count);

    if (player.health <= 0) {
        printf("모험이 실패로 끝났습니다...\n");
    } else {
        printf("모험을 마치고 안전하게 돌아왔습니다!\n");

        if (player.gold >= 100) {
            printf("훌륭한 성과입니다!\n");
        } else if (player.gold >= 50) {
            printf("괜찮은 성과입니다.\n");
        } else {
            printf("다음에는 더 많은 보물을 찾아보세요.\n");
        }
    }
}

int main() {
    text_adventure_game();
    return 0;
}
```

## 조건문 최적화와 고급 기법

### 분기 예측 친화적 코드 작성

현대 프로세서의 분기 예측기를 고려한 최적화:

```c
// 예측하기 어려운 코드 (비효율적)
int process_array_unpredictable(int *arr, size_t size) {
    int sum = 0;
    for (size_t i = 0; i < size; i++) {
        if (arr[i] % 2 == 0) {  // 예측 불가능한 패턴
            sum += arr[i] * 2;
        } else {
            sum += arr[i] * 3;
        }
    }
    return sum;
}

// 분기 제거를 통한 최적화
int process_array_optimized(int *arr, size_t size) {
    int sum = 0;
    for (size_t i = 0; i < size; i++) {
        // 조건부 이동 사용 (브랜치 없음)
        int multiplier = 2 + (arr[i] % 2);  // 짝수면 2, 홀수면 3
        sum += arr[i] * multiplier;
    }
    return sum;
}
```

### 조건문 리팩토링 기법

**1. 조기 반환을 통한 중첩 제거**

```c
// 중첩이 깊은 코드
int validate_and_process(const char *data, size_t size, int flags) {
    if (data != NULL) {
        if (size > 0) {
            if (size < MAX_SIZE) {
                if (flags & VALID_FLAG) {
                    // 실제 처리 로직
                    return process_data(data, size);
                } else {
                    return ERROR_INVALID_FLAGS;
                }
            } else {
                return ERROR_SIZE_TOO_LARGE;
            }
        } else {
            return ERROR_EMPTY_SIZE;
        }
    } else {
        return ERROR_NULL_DATA;
    }
}

// 조기 반환으로 개선
int validate_and_process_improved(const char *data, size_t size, int flags) {
    if (data == NULL) return ERROR_NULL_DATA;
    if (size == 0) return ERROR_EMPTY_SIZE;
    if (size >= MAX_SIZE) return ERROR_SIZE_TOO_LARGE;
    if (!(flags & VALID_FLAG)) return ERROR_INVALID_FLAGS;

    // 실제 처리 로직
    return process_data(data, size);
}
```

**2. 다형성을 이용한 조건문 제거**

```c
// 긴 switch 문
double calculate_area_switch(int shape_type, double param1, double param2) {
    switch (shape_type) {
        case CIRCLE:
            return 3.14159 * param1 * param1;
        case RECTANGLE:
            return param1 * param2;
        case TRIANGLE:
            return 0.5 * param1 * param2;
        case SQUARE:
            return param1 * param1;
        default:
            return 0.0;
    }
}

// 함수 포인터 테이블로 개선
typedef double (*area_calculator_t)(double, double);

double circle_area(double radius, double unused) {
    return 3.14159 * radius * radius;
}

double rectangle_area(double width, double height) {
    return width * height;
}

double triangle_area(double base, double height) {
    return 0.5 * base * height;
}

double square_area(double side, double unused) {
    return side * side;
}

static area_calculator_t area_calculators[] = {
    circle_area,
    rectangle_area,
    triangle_area,
    square_area
};

double calculate_area_table(int shape_type, double param1, double param2) {
    if (shape_type >= 0 && shape_type < 4) {
        return area_calculators[shape_type](param1, param2);
    }
    return 0.0;
}
```

## 정리

조건문은 프로그램이 **상황에 따라 다르게 동작**하도록 하는 핵심 도구입니다.

### 핸사 처리도 조건문

일상생활에서 우리는 항상 조건에 따라 선택합니다:

- 비가 오면 우산을 챙긴다
- 배가 고프면 밥을 먹는다
- 피곤하면 잠을 쟔다

프로그램도 마찬가지로 **조건에 따라 다른 처리**를 하므로 조건문이 필수적입니다.

### 기본 3가지 조건문

1. **if** - 조건이 참일 때만 실행
2. **if-else** - 둘 중 하나 선택
3. **switch** - 여러 값 중 하나와 비교

### 실용적인 조언

- **단순하게** 작성하기 - 복잡하면 이해하기 어렷다
- **오류 조건을 먼저** 처리하기
- **의미 있는 변수명** 사용하기
- **default나 else 절** 항상 포함하기

조건문을 잘 사용하면 사용자의 입력에 따라 다른 결과를 보여주는 **지능적인 프로그램**을 만들 수 있습니다.
