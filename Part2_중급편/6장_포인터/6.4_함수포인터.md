# 6.4 함수 포인터 (Function Pointers)

## 함수 포인터란 무엇인가?

### 함수 포인터의 기본 개념

함수 포인터는 **함수의 주소를 저장하는 포인터**입니다. 일반 포인터가 변수의 메모리 주소를 가리키는 것처럼, 함수 포인터는 함수가 저장된 메모리 위치를 가리킵니다.

```c
// 일반적인 함수
int add(int a, int b) {
    return a + b;
}

// 함수 포인터 선언 및 초기화
int (*func_ptr)(int, int) = add;

// 함수 포인터를 통한 호출
int result = func_ptr(3, 4);  // add(3, 4)와 동일
```

### 함수도 메모리에 저장된다

함수는 컴파일 시 기계어로 변환되어 **코드 세그먼트**에 저장됩니다. 함수 포인터는 이 코드의 시작 주소를 가리킵니다.

```c
printf("함수 add의 주소: %p\n", add);        // 함수명은 주소
printf("함수 포인터 값: %p\n", func_ptr);    // 포인터가 가리키는 주소
```

## 함수 포인터의 선언과 사용

### 함수 포인터 선언 문법

함수 포인터 선언은 다음 형태를 따릅니다:

```c
반환타입 (*포인터명)(매개변수타입들);

// 예제들
int (*operation)(int, int);        // int를 두 개 받아 int를 반환하는 함수 포인터
void (*handler)(char*);           // char*를 받아 void를 반환하는 함수 포인터
double (*calculate)(void);        // 매개변수 없이 double을 반환하는 함수 포인터
```

**주의**: 괄호가 중요합니다!
- `int (*ptr)(int, int)`: 함수 포인터
- `int *ptr(int, int)`: int*를 반환하는 함수 (함수 포인터가 아님)

### 함수 포인터 초기화와 호출

```c
#include <stdio.h>

// 두 개의 간단한 함수
int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    int (*operation)(int, int);

    // 함수 포인터에 함수 할당 (두 가지 방법)
    operation = add;        // 방법 1: 함수명 직접 할당
    operation = &multiply;  // 방법 2: 주소 연산자 사용 (선택적)

    // 함수 포인터를 통한 호출 (두 가지 방법)
    int result1 = operation(5, 3);     // 방법 1: 직접 호출
    int result2 = (*operation)(7, 2);  // 방법 2: 역참조 후 호출

    printf("result1: %d, result2: %d\n", result1, result2);

    return 0;
}
```

## 함수 포인터의 실전 활용

### 매개변수로 함수 전달하기

함수 포인터의 가장 강력한 활용은 **다른 함수의 매개변수로 전달**하는 것입니다:

```c
#include <stdio.h>

// 여러 연산 함수들
int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }

// 함수 포인터를 매개변수로 받는 함수
int calculate(int x, int y, int (*operation)(int, int)) {
    return operation(x, y);
}

int main() {
    int a = 10, b = 5;

    printf("%d + %d = %d\n", a, b, calculate(a, b, add));
    printf("%d - %d = %d\n", a, b, calculate(a, b, subtract));
    printf("%d * %d = %d\n", a, b, calculate(a, b, multiply));

    return 0;
}
```

### 콜백 함수 구현

콜백 함수는 **특정 이벤트가 발생했을 때 호출되는 함수**입니다:

```c
#include <stdio.h>

// 콜백 함수들
void onSuccess(int result) {
    printf("성공: 결과값 = %d\n", result);
}

void onError(int errorCode) {
    printf("오류 발생: 코드 = %d\n", errorCode);
}

// 비동기 작업을 시뮬레이션하는 함수
void processData(int data, void (*callback)(int)) {
    printf("데이터 처리 중...\n");

    if (data > 0) {
        callback(data * 2);  // 성공 콜백 호출
    } else {
        callback(-1);        // 에러 콜백 호출
    }
}

int main() {
    processData(5, onSuccess);   // 정상 케이스
    processData(-3, onError);    // 에러 케이스

    return 0;
}
```

### 함수 포인터 배열 활용

함수 포인터를 배열로 관리하면 **점프 테이블**을 구현할 수 있습니다:

```c
#include <stdio.h>

// 메뉴 처리 함수들
void menu_new() { printf("새 파일 생성\n"); }
void menu_open() { printf("파일 열기\n"); }
void menu_save() { printf("파일 저장\n"); }
void menu_exit() { printf("프로그램 종료\n"); }

int main() {
    // 함수 포인터 배열
    void (*menu_functions[])(void) = {
        menu_new,    // 0: 새 파일
        menu_open,   // 1: 파일 열기
        menu_save,   // 2: 파일 저장
        menu_exit    // 3: 종료
    };

    int menu_count = sizeof(menu_functions) / sizeof(menu_functions[0]);
    int choice;

    printf("메뉴를 선택하세요 (0-3): ");
    scanf("%d", &choice);

    if (choice >= 0 && choice < menu_count) {
        menu_functions[choice]();  // 해당 함수 호출
    } else {
        printf("잘못된 선택입니다.\n");
    }

    return 0;
}
```

## 고급 활용 예제

### 정렬 알고리즘의 비교 함수

C 표준 라이브러리의 `qsort` 함수처럼, 비교 함수를 매개변수로 받는 정렬 함수를 만들 수 있습니다:

```c
#include <stdio.h>

// 오름차순 비교 함수
int ascending(const void *a, const void *b) {
    int ia = *(const int*)a;
    int ib = *(const int*)b;
    return (ia > ib) - (ia < ib);
}

// 내림차순 비교 함수
int descending(const void *a, const void *b) {
    return -ascending(a, b);
}

// 간단한 버블 정렬 (비교 함수를 매개변수로 받음)
void bubbleSort(int arr[], int n, int (*compare)(const void*, const void*)) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (compare(&arr[j], &arr[j + 1]) > 0) {
                // 두 요소 교환
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int numbers[] = {64, 34, 25, 12, 22, 11, 90};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    printf("원본 배열: ");
    printArray(numbers, size);

    // 오름차순 정렬
    int asc_array[] = {64, 34, 25, 12, 22, 11, 90};
    bubbleSort(asc_array, size, ascending);
    printf("오름차순: ");
    printArray(asc_array, size);

    // 내림차순 정렬
    int desc_array[] = {64, 34, 25, 12, 22, 11, 90};
    bubbleSort(desc_array, size, descending);
    printf("내림차순: ");
    printArray(desc_array, size);

    return 0;
}
```

### 상태 기계 구현

함수 포인터를 사용하여 상태 기계를 깔끔하게 구현할 수 있습니다:

```c
#include <stdio.h>

// 상태 열거형
typedef enum {
    STATE_IDLE,
    STATE_RUNNING,
    STATE_PAUSED,
    STATE_STOPPED
} state_t;

// 현재 상태
static state_t current_state = STATE_IDLE;

// 상태 처리 함수들
void handle_idle(void) {
    printf("IDLE 상태: 시작을 기다리는 중...\n");
    current_state = STATE_RUNNING;
}

void handle_running(void) {
    printf("RUNNING 상태: 작업 실행 중...\n");
    current_state = STATE_PAUSED;
}

void handle_paused(void) {
    printf("PAUSED 상태: 일시 정지됨...\n");
    current_state = STATE_STOPPED;
}

void handle_stopped(void) {
    printf("STOPPED 상태: 작업 완료\n");
    current_state = STATE_IDLE;
}

int main() {
    // 상태별 처리 함수 테이블
    void (*state_handlers[])(void) = {
        handle_idle,     // STATE_IDLE
        handle_running,  // STATE_RUNNING
        handle_paused,   // STATE_PAUSED
        handle_stopped   // STATE_STOPPED
    };

    // 상태 전환 시뮬레이션
    for (int i = 0; i < 8; i++) {
        printf("Step %d - ", i + 1);
        state_handlers[current_state]();
    }

    return 0;
}
```

### 이벤트 시스템 구현

함수 포인터를 활용하여 간단한 이벤트 시스템을 만들 수 있습니다:

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_LISTENERS 10

// 이벤트 타입
typedef enum {
    EVENT_CLICK,
    EVENT_KEYPRESS,
    EVENT_MOUSE_MOVE
} event_type_t;

// 이벤트 리스너 타입
typedef void (*event_listener_t)(int event_data);

// 이벤트 시스템 구조체
typedef struct {
    event_listener_t listeners[MAX_LISTENERS];
    int listener_count;
} event_system_t;

static event_system_t event_systems[3];  // 각 이벤트 타입별 시스템

// 이벤트 리스너 등록
void addEventListener(event_type_t type, event_listener_t listener) {
    if (event_systems[type].listener_count < MAX_LISTENERS) {
        event_systems[type].listeners[event_systems[type].listener_count++] = listener;
    }
}

// 이벤트 발생
void fireEvent(event_type_t type, int data) {
    for (int i = 0; i < event_systems[type].listener_count; i++) {
        event_systems[type].listeners[i](data);
    }
}

// 이벤트 처리 함수들
void onButtonClick(int button_id) {
    printf("버튼 %d가 클릭되었습니다.\n", button_id);
}

void onKeyPress(int key_code) {
    printf("키 %d가 눌렸습니다.\n", key_code);
}

void onMouseMove(int position) {
    printf("마우스가 위치 %d로 이동했습니다.\n", position);
}

int main() {
    // 이벤트 리스너 등록
    addEventListener(EVENT_CLICK, onButtonClick);
    addEventListener(EVENT_KEYPRESS, onKeyPress);
    addEventListener(EVENT_MOUSE_MOVE, onMouseMove);

    // 이벤트 발생 시뮬레이션
    printf("이벤트 발생 시뮬레이션:\n");
    fireEvent(EVENT_CLICK, 1);
    fireEvent(EVENT_KEYPRESS, 65);  // 'A' 키
    fireEvent(EVENT_MOUSE_MOVE, 150);

    return 0;
}
```

## 함수 포인터 사용 시 주의사항

### 1. NULL 포인터 검사

함수 포인터를 호출하기 전에 항상 유효성을 검사해야 합니다:

```c
void safeCall(void (*func)(void)) {
    if (func != NULL) {
        func();
    } else {
        printf("오류: 유효하지 않은 함수 포인터\n");
    }
}
```

### 2. 타입 호환성 확인

함수 포인터는 정확한 시그니처를 가져야 합니다:

```c
// 잘못된 예: 시그니처 불일치
int add(int a, int b) { return a + b; }
void (*wrong_ptr)(int) = add;  // 컴파일 오류!

// 올바른 예
int (*correct_ptr)(int, int) = add;  // 올바름
```

### 3. 함수 포인터의 생명주기

지역 함수나 임시 함수의 주소는 저장하면 안됩니다:

```c
// 위험한 코드 (일반적으로 C에서는 중첩 함수 지원 안함)
void dangerous_example() {
    // 만약 중첩 함수가 지원된다면...
    // void local_func() { ... }
    // global_ptr = local_func;  // 위험! 범위 벗어나면 무효화
}
```

## typedef를 활용한 가독성 향상

복잡한 함수 포인터 타입은 `typedef`로 간소화할 수 있습니다:

```c
#include <stdio.h>

// 복잡한 함수 포인터를 typedef로 단순화
typedef int (*BinaryOperation)(int, int);
typedef void (*EventHandler)(int event_code);
typedef double (*MathFunction)(double x);

// 계산기 구조체
typedef struct {
    char name[20];
    BinaryOperation operation;
} Calculator;

int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }
int divide(int a, int b) { return b != 0 ? a / b : 0; }

int main() {
    // 계산기 배열
    Calculator calculators[] = {
        {"덧셈", add},
        {"뺄셈", subtract},
        {"곱셈", multiply},
        {"나눗셈", divide}
    };

    int calc_count = sizeof(calculators) / sizeof(calculators[0]);
    int a = 15, b = 3;

    printf("두 수 %d와 %d의 연산 결과:\n", a, b);
    for (int i = 0; i < calc_count; i++) {
        int result = calculators[i].operation(a, b);
        printf("%s: %d\n", calculators[i].name, result);
    }

    return 0;
}
```

## 실전 프로젝트 예제

### 간단한 계산기 프로그램

함수 포인터를 활용한 완전한 계산기 예제:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 연산 함수들
double add(double a, double b) { return a + b; }
double subtract(double a, double b) { return a - b; }
double multiply(double a, double b) { return a * b; }
double divide(double a, double b) {
    if (b == 0) {
        printf("오류: 0으로 나눌 수 없습니다.\n");
        return 0;
    }
    return a / b;
}

// 연산자 정보 구조체
typedef struct {
    char symbol;
    char name[10];
    double (*operation)(double, double);
} Operator;

// 연산자 배열
Operator operators[] = {
    {'+', "덧셈", add},
    {'-', "뺄셈", subtract},
    {'*', "곱셈", multiply},
    {'/', "나눗셈", divide}
};

int operator_count = sizeof(operators) / sizeof(operators[0]);

// 연산자 찾기 함수
Operator* findOperator(char symbol) {
    for (int i = 0; i < operator_count; i++) {
        if (operators[i].symbol == symbol) {
            return &operators[i];
        }
    }
    return NULL;
}

// 도움말 출력
void printHelp() {
    printf("\n=== 간단한 계산기 ===\n");
    printf("사용법: 숫자1 연산자 숫자2\n");
    printf("지원 연산자: ");
    for (int i = 0; i < operator_count; i++) {
        printf("%c(%s) ", operators[i].symbol, operators[i].name);
    }
    printf("\n종료: q\n\n");
}

int main() {
    double num1, num2, result;
    char op;
    char input[100];

    printHelp();

    while (1) {
        printf("계산식을 입력하세요 (예: 10 + 5): ");

        if (fgets(input, sizeof(input), stdin) == NULL) {
            break;
        }

        // 종료 체크
        if (input[0] == 'q' || input[0] == 'Q') {
            printf("계산기를 종료합니다.\n");
            break;
        }

        // 입력 파싱
        if (sscanf(input, "%lf %c %lf", &num1, &op, &num2) != 3) {
            printf("잘못된 입력입니다. 다시 시도하세요.\n");
            continue;
        }

        // 연산자 찾기
        Operator* operator = findOperator(op);
        if (operator == NULL) {
            printf("지원하지 않는 연산자입니다: %c\n", op);
            continue;
        }

        // 계산 실행
        result = operator->operation(num1, num2);
        printf("결과: %.2f %c %.2f = %.2f\n\n", num1, op, num2, result);
    }

    return 0;
}
```

## 함수 포인터의 고급 활용

### 함수를 반환하는 함수

함수 포인터를 반환값으로 사용할 수도 있습니다:

```c
#include <stdio.h>

// 기본 수학 함수들
double add_op(double a, double b) { return a + b; }
double mul_op(double a, double b) { return a * b; }
double sub_op(double a, double b) { return a - b; }

// 연산 타입
typedef enum {
    OP_ADD, OP_SUB, OP_MUL
} operation_type;

// 함수 포인터 타입 정의
typedef double (*MathOperation)(double, double);

// 연산 타입에 따라 적절한 함수를 반환
MathOperation getOperation(operation_type op) {
    switch (op) {
        case OP_ADD: return add_op;
        case OP_SUB: return sub_op;
        case OP_MUL: return mul_op;
        default: return NULL;
    }
}

int main() {
    double a = 10.5, b = 3.2;

    // 동적으로 연산 함수 선택
    MathOperation op = getOperation(OP_ADD);
    if (op != NULL) {
        printf("%.1f + %.1f = %.1f\n", a, b, op(a, b));
    }

    op = getOperation(OP_MUL);
    if (op != NULL) {
        printf("%.1f * %.1f = %.1f\n", a, b, op(a, b));
    }

    return 0;
}
```

### 플러그인 시스템 구현

함수 포인터를 사용하여 간단한 플러그인 시스템을 만들 수 있습니다:

```c
#include <stdio.h>
#include <string.h>

// 플러그인 인터페이스
typedef struct {
    char name[50];
    char version[20];
    void (*init)(void);
    void (*process)(const char* data);
    void (*cleanup)(void);
} Plugin;

// 텍스트 처리 플러그인
void text_plugin_init() {
    printf("[텍스트 플러그인] 초기화 완료\n");
}

void text_plugin_process(const char* data) {
    printf("[텍스트 플러그인] 처리 중: %s\n", data);
}

void text_plugin_cleanup() {
    printf("[텍스트 플러그인] 정리 완료\n");
}

// 로그 플러그인
void log_plugin_init() {
    printf("[로그 플러그인] 초기화 완료\n");
}

void log_plugin_process(const char* data) {
    printf("[로그 플러그인] 로그 기록: %s\n", data);
}

void log_plugin_cleanup() {
    printf("[로그 플러그인] 정리 완료\n");
}

// 플러그인 매니저
typedef struct {
    Plugin plugins[10];
    int count;
} PluginManager;

void plugin_manager_init(PluginManager* pm) {
    pm->count = 0;
}

void plugin_manager_register(PluginManager* pm, Plugin plugin) {
    if (pm->count < 10) {
        pm->plugins[pm->count++] = plugin;
        printf("플러그인 등록: %s v%s\n", plugin.name, plugin.version);
    }
}

void plugin_manager_process_all(PluginManager* pm, const char* data) {
    for (int i = 0; i < pm->count; i++) {
        pm->plugins[i].init();
        pm->plugins[i].process(data);
        pm->plugins[i].cleanup();
        printf("\n");
    }
}

int main() {
    PluginManager pm;
    plugin_manager_init(&pm);

    // 플러그인들 등록
    Plugin text_plugin = {
        "TextProcessor", "1.0",
        text_plugin_init,
        text_plugin_process,
        text_plugin_cleanup
    };

    Plugin log_plugin = {
        "Logger", "2.1",
        log_plugin_init,
        log_plugin_process,
        log_plugin_cleanup
    };

    plugin_manager_register(&pm, text_plugin);
    plugin_manager_register(&pm, log_plugin);

    // 모든 플러그인으로 데이터 처리
    printf("\n=== 데이터 처리 시작 ===\n");
    plugin_manager_process_all(&pm, "Hello, Plugin System!");

    return 0;
}
```

## 성능 고려사항

### 함수 포인터 vs 일반 함수 호출

함수 포인터는 간접 호출로 인한 약간의 성능 오버헤드가 있습니다:

```c
#include <stdio.h>
#include <time.h>

#define ITERATIONS 100000000

int direct_add(int a, int b) {
    return a + b;
}

int main() {
    int (*func_ptr)(int, int) = direct_add;
    clock_t start, end;

    // 직접 호출 성능 측정
    start = clock();
    for (int i = 0; i < ITERATIONS; i++) {
        direct_add(i, i + 1);
    }
    end = clock();
    double direct_time = ((double)(end - start)) / CLOCKS_PER_SEC;

    // 포인터 호출 성능 측정
    start = clock();
    for (int i = 0; i < ITERATIONS; i++) {
        func_ptr(i, i + 1);
    }
    end = clock();
    double pointer_time = ((double)(end - start)) / CLOCKS_PER_SEC;

    printf("직접 호출: %.3f초\n", direct_time);
    printf("포인터 호출: %.3f초\n", pointer_time);
    printf("오버헤드: %.1f%%\n",
           ((pointer_time - direct_time) / direct_time) * 100);

    return 0;
}
```

**일반적인 성능 특성:**
- 함수 포인터는 약간의 오버헤드 존재 (보통 5-15%)
- 현대 CPU의 분기 예측으로 오버헤드 감소
- 유연성과 성능 사이의 트레이드오프

## 디버깅 팁

### 함수 포인터 디버깅

함수 포인터 관련 문제를 디버깅하는 방법:

```c
#include <stdio.h>

// 디버그용 함수 포인터 래퍼
void debug_call(void (*func)(void), const char* func_name) {
    if (func == NULL) {
        printf("오류: %s 함수 포인터가 NULL입니다\n", func_name);
        return;
    }

    printf("호출: %s() - 주소: %p\n", func_name, (void*)func);
    func();
    printf("완료: %s()\n", func_name);
}

void test_function() {
    printf("  테스트 함수 실행 중...\n");
}

int main() {
    void (*ptr)(void) = test_function;

    debug_call(ptr, "test_function");
    debug_call(NULL, "null_function");  // NULL 포인터 테스트

    return 0;
}
```

## 실무에서의 함수 포인터 활용

### 1. 라이브러리 API 설계
- 콜백 함수로 사용자 정의 동작 허용
- 플랫폼별 구현 추상화
- 확장 가능한 인터페이스 제공

### 2. 이벤트 기반 프로그래밍
- GUI 이벤트 처리
- 네트워크 이벤트 핸들링
- 타이머 콜백

### 3. 알고리즘 일반화
- 정렬 함수의 비교 함수
- 검색 알고리즘의 조건 함수
- 필터링 작업

### 4. 상태 기계 구현
- 게임 AI 상태 관리
- 프로토콜 구현
- 워크플로우 시스템

## 마무리

함수 포인터는 **C언어에서 코드의 유연성을 극대화하는 강력한 도구**입니다. 이를 통해 다음과 같은 고급 프로그래밍 기법을 구현할 수 있습니다:

**핵심 기억사항:**
- 함수 포인터는 함수의 메모리 주소를 저장하는 변수
- 런타임에 호출할 함수를 동적으로 결정 가능
- 콜백 함수, 이벤트 시스템, 플러그인 아키텍처 구현에 필수
- typedef를 활용하여 복잡한 함수 포인터 타입 단순화
- 반드시 NULL 검사와 타입 호환성 확인 필요
- 약간의 성능 오버헤드가 있지만 유연성의 이점이 더 큼

**활용 분야:**
- 라이브러리 API 설계
- 이벤트 기반 프로그래밍
- 알고리즘 일반화
- 상태 기계 구현
- 플러그인 시스템
- GUI 프로그래밍

함수 포인터를 마스터하면 C언어로도 현대적이고 유연한 소프트웨어 아키텍처를 설계할 수 있게 됩니다. 이는 시스템 프로그래밍부터 응용 프로그램 개발까지 모든 영역에서 활용할 수 있는 핵심 기술입니다.