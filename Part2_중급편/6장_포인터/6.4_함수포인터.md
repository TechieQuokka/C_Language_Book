# 6.4 함수 포인터 (Function Pointers)

## 함수 포인터의 철학적 기초: 코드와 데이터의 이원성

### 폰 노이만 아키텍처의 근본 통찰

함수 포인터는 **폰 노이만 아키텍처**의 가장 깊은 철학적 함의를 구현합니다. 이 아키텍처의 핵심은 **프로그램과 데이터가 같은 메모리에 저장된다**는 것입니다. 이는 다음을 의미합니다:

1. **코드의 데이터화**: 실행 가능한 코드가 메모리 주소로 표현됨
2. **참조의 일원화**: 데이터 참조와 코드 참조가 본질적으로 동일함
3. **자기 수정의 가능성**: 프로그램이 자기 자신을 변경할 수 있음

이는 **괴델의 불완전성 정리**에서 나타나는 자기 참조적 구조와 유사합니다.

### 실행 가능한 메모리의 존재론

함수 포인터가 가리키는 메모리는 특별합니다. 이는 **정적 데이터**가 아니라 **동적 행동**입니다:

```c
int data = 42;        // 상태(State)를 나타내는 메모리
int (*action)(void);  // 행동(Behavior)을 나타내는 메모리
```

이는 **아리스토텔레스의 엔텔레키아(Entelecheia)** 개념, 즉 **현실태로서의 활동성**과 닮아있습니다.

## 타입 시스템에서의 함수 시그니처

### 함수 타입의 구조적 의미

함수 포인터의 타입은 단순한 주소가 아닙니다. 이는 **인터페이스 계약(Interface Contract)**입니다:

```c
int (*operation)(int, int);  // "두 정수를 받아 정수를 반환하는 행동"
```

이 선언은 다음을 명시합니다:

1. **입력 조건(Precondition)**: 두 개의 정수 매개변수
2. **출력 보장(Postcondition)**: 하나의 정수 반환값
3. **부작용 가능성(Side Effects)**: 명시되지 않음

이는 **계약에 의한 설계(Design by Contract)**의 기초입니다.

### 타입 동등성과 구조적 타이핑

함수 포인터는 **구조적 타이핑(Structural Typing)**의 예입니다:

```c
int add(int a, int b) { return a + b; }
int multiply(int x, int y) { return x * y; }

int (*op)(int, int);  // 같은 시그니처
op = add;             // 호환됨
op = multiply;        // 호환됨
```

함수의 **이름**이나 **의미**가 아니라 **구조**가 타입 호환성을 결정합니다.

## 고차 함수와 메타프로그래밍

### 함수를 매개변수로 받는 함수

고차 함수는 **추상화의 한 단계 상승**입니다:

```c
int apply_operation(int a, int b, int (*op)(int, int)) {
    return op(a, b);  // 구체적 연산을 추상적으로 적용
}
```

이는 **수학의 범함수(Functional)**와 동일한 개념입니다. f(g)에서 g는 함수이고, f는 함수를 함수로 매핑합니다.

### 함수를 반환하는 함수

```c
int (*get_operation(char op))(int, int) {
    switch(op) {
        case '+': return add;
        case '*': return multiply;
        default: return NULL;
    }
}
```

이는 **함수 팩토리(Function Factory)**입니다. 런타임에 새로운 행동을 생성하는 메타프로그래밍의 기초입니다.

## 런타임 다형성과 동적 디스패치

### 컴파일 타임 vs 런타임 바인딩

전통적인 함수 호출은 **정적 바인딩**입니다:
```c
result = add(x, y);  // 컴파일 시점에 결정됨
```

함수 포인터는 **동적 바인딩**을 제공합니다:
```c
result = operation(x, y);  // 런타임에 결정됨
```

이는 **열린 세계 가정(Open World Assumption)**을 가능하게 합니다. 프로그램은 모든 가능한 함수를 미리 알 필요가 없습니다.

### 가상 함수 테이블의 개념

함수 포인터 배열은 **객체지향의 가상 함수 테이블(vtable)**과 본질적으로 동일합니다:

```c
typedef struct {
    void (*draw)(void* self);
    void (*move)(void* self, int x, int y);
    void (*destroy)(void* self);
} ShapeVTable;

typedef struct {
    ShapeVTable* vtable;
    // ... 데이터 멤버들
} Shape;
```

이는 **다형성(Polymorphism)**의 구현 메커니즘입니다.

## 콜백 메커니즘과 제어의 역전

### 할리우드 원칙: "Don't call us, we'll call you"

콜백 함수는 **제어의 역전(Inversion of Control)**을 구현합니다:

```c
void process_data(Data* data, void (*callback)(Result*)) {
    Result* result = heavy_computation(data);
    callback(result);  // 호출자가 아닌 피호출자가 결정
}
```

이는 **의존성 주입(Dependency Injection)**의 기초가 되며, **관심사의 분리(Separation of Concerns)**를 달성합니다.

### 비동기 프로그래밍의 기초

콜백은 **비동기 프로그래밍**의 근본 메커니즘입니다:

```c
void async_read(int fd, void (*on_complete)(char* data, int len)) {
    // 백그라운드에서 읽기 작업 수행
    // 완료 시 on_complete 호출
}
```

이는 **시간의 해방**을 의미합니다. 프로그램이 동기적 시간에서 비동기적 사건으로 전환됩니다.

## 함수 포인터와 알고리즘의 일반화

### 알고리즘과 데이터의 분리

함수 포인터는 **알고리즘의 매개변수화**를 가능하게 합니다:

```c
void sort(void* base, size_t n, size_t size,
          int (*compare)(const void*, const void*)) {
    // 정렬 알고리즘은 고정, 비교 논리는 가변
}
```

이는 **패러다임의 전환**입니다:
- 기존: 각 타입마다 별도의 정렬 함수
- 새로운: 하나의 정렬 함수, 다양한 비교 함수

### 전략 패턴의 구현

```c
typedef struct {
    char name[20];
    double (*calculate)(double principal, double rate, int time);
} InterestStrategy;

InterestStrategy strategies[] = {
    {"Simple", calculate_simple_interest},
    {"Compound", calculate_compound_interest},
    {"Continuous", calculate_continuous_interest}
};
```

이는 **행동의 캡슐화**와 **런타임 선택**을 결합합니다.

## 함수 포인터와 메모리 아키텍처

### 코드 세그먼트의 특성

함수 포인터가 가리키는 메모리는 특별한 속성을 가집니다:

1. **실행 권한(Execute Permission)**: CPU가 명령어로 해석 가능
2. **읽기 전용(Read-Only)**: 일반적으로 수정 불가
3. **공유 가능(Shareable)**: 여러 프로세스가 같은 코드 공유 가능

이는 **데이터와 코드의 존재론적 차이**를 보여줍니다.

### 가상 메모리와 주소 공간

현대 시스템에서 함수 포인터는 **가상 주소**입니다:

```
가상 주소 공간:
[0x400000] ← 코드 세그먼트 시작
    |
[함수들의 가상 주소]
    |
[0x600000] ← 데이터 세그먼트 시작
```

이는 **물리적 현실**과 **논리적 추상화**의 분리를 나타냅니다.

## 함수 포인터와 보안

### DEP와 ASLR의 영향

현대 보안 메커니즘들이 함수 포인터에 미치는 영향:

**DEP (Data Execution Prevention)**:
- 데이터 영역의 코드 실행 방지
- 함수 포인터 조작 공격 방어

**ASLR (Address Space Layout Randomization)**:
- 코드 위치의 무작위화
- 절대 주소에 의존하는 공격 방어

**CFI (Control Flow Integrity)**:
- 제어 흐름의 무결성 검증
- 함수 포인터 오용 방지

이는 **보안과 유연성의 트레이드오프**를 보여줍니다.

## 함수 포인터의 철학적 함의

### 실행과 표현의 이원론

함수 포인터는 **실행(Execution)**과 **표현(Representation)**을 연결합니다:

- **표현**: 메모리 주소로서의 함수
- **실행**: 실제 코드의 수행

이는 **지도와 영토**의 관계와 같습니다. 지도(포인터)는 영토(실제 함수)를 나타내지만 영토 자체는 아닙니다.

### 능동과 수동의 변증법

함수 포인터는 **능동적 코드**를 **수동적 데이터**로 취급합니다:

```c
void (*actions[])(void) = {action1, action2, action3};
// 능동적 행동들이 수동적 배열 요소가 됨
```

이는 **주체와 객체의 전복**입니다. 행동하는 주체(함수)가 조작되는 객체(데이터)가 됩니다.

### 구체와 추상의 매개

함수 포인터는 **구체적 구현**과 **추상적 인터페이스**를 매개합니다:

```c
// 추상적 인터페이스
typedef int (*Comparator)(const void*, const void*);

// 구체적 구현들
int int_compare(const void* a, const void* b);
int string_compare(const void* a, const void* b);
```

이는 **플라톤의 메텍시스(Methexis)**, 즉 이데아에의 참여 개념과 유사합니다.

## 컴파일러 최적화와 함수 포인터

### 간접 호출의 비용

함수 포인터 호출은 **간접성의 대가**를 치릅니다:

1. **분기 예측 실패**: CPU가 호출 대상을 예측하기 어려움
2. **인라이닝 불가**: 컴파일 시점에 호출 대상 미확정
3. **최적화 제약**: 전역 최적화의 어려움

### 현대 최적화 기법

**링크 타임 최적화(LTO)**:
```
소스 코드 → 중간 표현 → 링크 시점 최적화 → 기계어
```

**프로파일 기반 최적화(PGO)**:
- 실행 패턴 수집
- 자주 호출되는 함수에 대한 추측적 인라이닝

**가상화 해제(Devirtualization)**:
- 런타임 타입 정보를 이용한 직접 호출 변환

이는 **정적 분석과 동적 정보의 결합**입니다.

## 함수 포인터의 실용적 패턴

### 명령 패턴 (Command Pattern)

```c
typedef struct {
    void (*execute)(void* context);
    void (*undo)(void* context);
    void* context;
} Command;

void execute_command(Command* cmd) {
    cmd->execute(cmd->context);
}
```

### 관찰자 패턴 (Observer Pattern)

```c
typedef struct Observer {
    void (*notify)(struct Observer* self, Event* event);
    struct Observer* next;
} Observer;
```

### 상태 기계 패턴

```c
typedef struct {
    State current_state;
    void (*state_handlers[NUM_STATES])(Event* event);
} StateMachine;
```

이러한 패턴들은 **설계의 재사용성**과 **코드의 유연성**을 극대화합니다.

## 함수 포인터와 함수형 프로그래밍

### 고차 함수의 시뮬레이션

C언어에서 함수형 프로그래밍 개념을 구현:

```c
// map 함수 시뮬레이션
void map(int* array, int size, int (*func)(int)) {
    for (int i = 0; i < size; i++) {
        array[i] = func(array[i]);
    }
}

// filter 함수 시뮬레이션
int filter(int* src, int* dest, int size, int (*predicate)(int)) {
    int count = 0;
    for (int i = 0; i < size; i++) {
        if (predicate(src[i])) {
            dest[count++] = src[i];
        }
    }
    return count;
}
```

### 클로저의 시뮬레이션

```c
typedef struct {
    int (*call)(struct Closure* self, int arg);
    int captured_value;
} Closure;

int make_adder_func(Closure* self, int arg) {
    return self->captured_value + arg;
}

Closure make_adder(int n) {
    return (Closure){make_adder_func, n};
}
```

이는 **환경의 캡처**와 **지연된 실행**을 구현합니다.

## 마무리: 함수 포인터의 정수(精髓)

함수 포인터는 **코드의 데이터화**라는 근본적 전환을 나타냅니다. 이는 다음을 가능하게 합니다:

1. **메타프로그래밍**: 프로그램이 프로그램을 조작
2. **런타임 다형성**: 실행 시점의 행동 선택
3. **제어의 역전**: 의존성의 방향 전환
4. **알고리즘의 일반화**: 행동의 매개변수화
5. **설계 패턴의 구현**: 재사용 가능한 아키텍처

함수 포인터를 마스터한다는 것은 **정적인 코드에서 동적인 행동으로**, **결정론적 프로그래밍에서 확률론적 프로그래밍으로**의 패러다임 전환을 이해하는 것입니다.

이는 **데카르트의 기계론적 세계관**에서 **라이프니츠의 모나드론적 세계관**으로의 철학적 전환과 유사합니다. 각 함수는 독립적 모나드이지만, 함수 포인터를 통해 **미리 성립된 조화(Pre-established Harmony)**를 이룹니다.

함수 포인터는 단순한 언어 기능이 아닙니다. 이는 **컴퓨터 과학의 철학적 깊이**를 보여주는 개념이며, **소프트웨어 아키텍처의 예술**을 가능하게 하는 도구입니다.

## 함수 포인터의 선언과 사용

### 함수 포인터 선언 문법

함수 포인터 선언은 다음 형태를 따릅니다:

```c
반환타입 (*포인터명)(매개변수타입들);

// 예제들
int (*operation)(int, int);        // int를 두 개 받아 int를 반환하는 함수 포인터
void (*handler)(char*);           // char*를 받아 void를 반환하는 함수 포인터
double (*calculate)(void);        // 매개변수 없이 double을 반환하는 함수 포인터
```

**주의**: 괄호가 중요합니다!
- `int (*ptr)(int, int)`: 함수 포인터
- `int *ptr(int, int)`: int*를 반환하는 함수 (함수 포인터가 아님)

### 함수 포인터 초기화와 호출

```c
#include <stdio.h>

// 두 개의 간단한 함수
int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    int (*operation)(int, int);

    // 함수 포인터에 함수 할당 (두 가지 방법)
    operation = add;        // 방법 1: 함수명 직접 할당
    operation = &multiply;  // 방법 2: 주소 연산자 사용 (선택적)

    // 함수 포인터를 통한 호출 (두 가지 방법)
    int result1 = operation(5, 3);     // 방법 1: 직접 호출
    int result2 = (*operation)(7, 2);  // 방법 2: 역참조 후 호출

    printf("result1: %d, result2: %d\n", result1, result2);

    return 0;
}
```

## 함수 포인터의 실전 활용

### 매개변수로 함수 전달하기

함수 포인터의 가장 강력한 활용은 **다른 함수의 매개변수로 전달**하는 것입니다:

```c
#include <stdio.h>

// 여러 연산 함수들
int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }

// 함수 포인터를 매개변수로 받는 함수
int calculate(int x, int y, int (*operation)(int, int)) {
    return operation(x, y);
}

int main() {
    int a = 10, b = 5;

    printf("%d + %d = %d\n", a, b, calculate(a, b, add));
    printf("%d - %d = %d\n", a, b, calculate(a, b, subtract));
    printf("%d * %d = %d\n", a, b, calculate(a, b, multiply));

    return 0;
}
```

### 콜백 함수 구현

콜백 함수는 **특정 이벤트가 발생했을 때 호출되는 함수**입니다:

```c
#include <stdio.h>

// 콜백 함수들
void onSuccess(int result) {
    printf("성공: 결과값 = %d\n", result);
}

void onError(int errorCode) {
    printf("오류 발생: 코드 = %d\n", errorCode);
}

// 비동기 작업을 시뮬레이션하는 함수
void processData(int data, void (*callback)(int)) {
    printf("데이터 처리 중...\n");

    if (data > 0) {
        callback(data * 2);  // 성공 콜백 호출
    } else {
        callback(-1);        // 에러 콜백 호출
    }
}

int main() {
    processData(5, onSuccess);   // 정상 케이스
    processData(-3, onError);    // 에러 케이스

    return 0;
}
```

### 함수 포인터 배열 활용

함수 포인터를 배열로 관리하면 **점프 테이블**을 구현할 수 있습니다:

```c
#include <stdio.h>

// 메뉴 처리 함수들
void menu_new() { printf("새 파일 생성\n"); }
void menu_open() { printf("파일 열기\n"); }
void menu_save() { printf("파일 저장\n"); }
void menu_exit() { printf("프로그램 종료\n"); }

int main() {
    // 함수 포인터 배열
    void (*menu_functions[])(void) = {
        menu_new,    // 0: 새 파일
        menu_open,   // 1: 파일 열기
        menu_save,   // 2: 파일 저장
        menu_exit    // 3: 종료
    };

    int menu_count = sizeof(menu_functions) / sizeof(menu_functions[0]);
    int choice;

    printf("메뉴를 선택하세요 (0-3): ");
    scanf("%d", &choice);

    if (choice >= 0 && choice < menu_count) {
        menu_functions[choice]();  // 해당 함수 호출
    } else {
        printf("잘못된 선택입니다.\n");
    }

    return 0;
}
```

## 고급 활용 예제

### 정렬 알고리즘의 비교 함수

C 표준 라이브러리의 `qsort` 함수처럼, 비교 함수를 매개변수로 받는 정렬 함수를 만들 수 있습니다:

```c
#include <stdio.h>

// 오름차순 비교 함수
int ascending(const void *a, const void *b) {
    int ia = *(const int*)a;
    int ib = *(const int*)b;
    return (ia > ib) - (ia < ib);
}

// 내림차순 비교 함수
int descending(const void *a, const void *b) {
    return -ascending(a, b);
}

// 간단한 버블 정렬 (비교 함수를 매개변수로 받음)
void bubbleSort(int arr[], int n, int (*compare)(const void*, const void*)) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (compare(&arr[j], &arr[j + 1]) > 0) {
                // 두 요소 교환
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int numbers[] = {64, 34, 25, 12, 22, 11, 90};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    printf("원본 배열: ");
    printArray(numbers, size);

    // 오름차순 정렬
    int asc_array[] = {64, 34, 25, 12, 22, 11, 90};
    bubbleSort(asc_array, size, ascending);
    printf("오름차순: ");
    printArray(asc_array, size);

    // 내림차순 정렬
    int desc_array[] = {64, 34, 25, 12, 22, 11, 90};
    bubbleSort(desc_array, size, descending);
    printf("내림차순: ");
    printArray(desc_array, size);

    return 0;
}
```

### 상태 기계 구현

함수 포인터를 사용하여 상태 기계를 깔끔하게 구현할 수 있습니다:

```c
#include <stdio.h>

// 상태 열거형
typedef enum {
    STATE_IDLE,
    STATE_RUNNING,
    STATE_PAUSED,
    STATE_STOPPED
} state_t;

// 현재 상태
static state_t current_state = STATE_IDLE;

// 상태 처리 함수들
void handle_idle(void) {
    printf("IDLE 상태: 시작을 기다리는 중...\n");
    current_state = STATE_RUNNING;
}

void handle_running(void) {
    printf("RUNNING 상태: 작업 실행 중...\n");
    current_state = STATE_PAUSED;
}

void handle_paused(void) {
    printf("PAUSED 상태: 일시 정지됨...\n");
    current_state = STATE_STOPPED;
}

void handle_stopped(void) {
    printf("STOPPED 상태: 작업 완료\n");
    current_state = STATE_IDLE;
}

int main() {
    // 상태별 처리 함수 테이블
    void (*state_handlers[])(void) = {
        handle_idle,     // STATE_IDLE
        handle_running,  // STATE_RUNNING
        handle_paused,   // STATE_PAUSED
        handle_stopped   // STATE_STOPPED
    };

    // 상태 전환 시뮬레이션
    for (int i = 0; i < 8; i++) {
        printf("Step %d - ", i + 1);
        state_handlers[current_state]();
    }

    return 0;
}
```

### 이벤트 시스템 구현

함수 포인터를 활용하여 간단한 이벤트 시스템을 만들 수 있습니다:

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_LISTENERS 10

// 이벤트 타입
typedef enum {
    EVENT_CLICK,
    EVENT_KEYPRESS,
    EVENT_MOUSE_MOVE
} event_type_t;

// 이벤트 리스너 타입
typedef void (*event_listener_t)(int event_data);

// 이벤트 시스템 구조체
typedef struct {
    event_listener_t listeners[MAX_LISTENERS];
    int listener_count;
} event_system_t;

static event_system_t event_systems[3];  // 각 이벤트 타입별 시스템

// 이벤트 리스너 등록
void addEventListener(event_type_t type, event_listener_t listener) {
    if (event_systems[type].listener_count < MAX_LISTENERS) {
        event_systems[type].listeners[event_systems[type].listener_count++] = listener;
    }
}

// 이벤트 발생
void fireEvent(event_type_t type, int data) {
    for (int i = 0; i < event_systems[type].listener_count; i++) {
        event_systems[type].listeners[i](data);
    }
}

// 이벤트 처리 함수들
void onButtonClick(int button_id) {
    printf("버튼 %d가 클릭되었습니다.\n", button_id);
}

void onKeyPress(int key_code) {
    printf("키 %d가 눌렸습니다.\n", key_code);
}

void onMouseMove(int position) {
    printf("마우스가 위치 %d로 이동했습니다.\n", position);
}

int main() {
    // 이벤트 리스너 등록
    addEventListener(EVENT_CLICK, onButtonClick);
    addEventListener(EVENT_KEYPRESS, onKeyPress);
    addEventListener(EVENT_MOUSE_MOVE, onMouseMove);

    // 이벤트 발생 시뮬레이션
    printf("이벤트 발생 시뮬레이션:\n");
    fireEvent(EVENT_CLICK, 1);
    fireEvent(EVENT_KEYPRESS, 65);  // 'A' 키
    fireEvent(EVENT_MOUSE_MOVE, 150);

    return 0;
}
```

## 함수 포인터 사용 시 주의사항

### 1. NULL 포인터 검사

함수 포인터를 호출하기 전에 항상 유효성을 검사해야 합니다:

```c
void safeCall(void (*func)(void)) {
    if (func != NULL) {
        func();
    } else {
        printf("오류: 유효하지 않은 함수 포인터\n");
    }
}
```

### 2. 타입 호환성 확인

함수 포인터는 정확한 시그니처를 가져야 합니다:

```c
// 잘못된 예: 시그니처 불일치
int add(int a, int b) { return a + b; }
void (*wrong_ptr)(int) = add;  // 컴파일 오류!

// 올바른 예
int (*correct_ptr)(int, int) = add;  // 올바름
```

### 3. 함수 포인터의 생명주기

지역 함수나 임시 함수의 주소는 저장하면 안됩니다:

```c
// 위험한 코드 (일반적으로 C에서는 중첩 함수 지원 안함)
void dangerous_example() {
    // 만약 중첩 함수가 지원된다면...
    // void local_func() { ... }
    // global_ptr = local_func;  // 위험! 범위 벗어나면 무효화
}
```

## typedef를 활용한 가독성 향상

복잡한 함수 포인터 타입은 `typedef`로 간소화할 수 있습니다:

```c
#include <stdio.h>

// 복잡한 함수 포인터를 typedef로 단순화
typedef int (*BinaryOperation)(int, int);
typedef void (*EventHandler)(int event_code);
typedef double (*MathFunction)(double x);

// 계산기 구조체
typedef struct {
    char name[20];
    BinaryOperation operation;
} Calculator;

int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }
int divide(int a, int b) { return b != 0 ? a / b : 0; }

int main() {
    // 계산기 배열
    Calculator calculators[] = {
        {"덧셈", add},
        {"뺄셈", subtract},
        {"곱셈", multiply},
        {"나눗셈", divide}
    };

    int calc_count = sizeof(calculators) / sizeof(calculators[0]);
    int a = 15, b = 3;

    printf("두 수 %d와 %d의 연산 결과:\n", a, b);
    for (int i = 0; i < calc_count; i++) {
        int result = calculators[i].operation(a, b);
        printf("%s: %d\n", calculators[i].name, result);
    }

    return 0;
}
```

## 실전 프로젝트 예제

### 간단한 계산기 프로그램

함수 포인터를 활용한 완전한 계산기 예제:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 연산 함수들
double add(double a, double b) { return a + b; }
double subtract(double a, double b) { return a - b; }
double multiply(double a, double b) { return a * b; }
double divide(double a, double b) {
    if (b == 0) {
        printf("오류: 0으로 나눌 수 없습니다.\n");
        return 0;
    }
    return a / b;
}

// 연산자 정보 구조체
typedef struct {
    char symbol;
    char name[10];
    double (*operation)(double, double);
} Operator;

// 연산자 배열
Operator operators[] = {
    {'+', "덧셈", add},
    {'-', "뺄셈", subtract},
    {'*', "곱셈", multiply},
    {'/', "나눗셈", divide}
};

int operator_count = sizeof(operators) / sizeof(operators[0]);

// 연산자 찾기 함수
Operator* findOperator(char symbol) {
    for (int i = 0; i < operator_count; i++) {
        if (operators[i].symbol == symbol) {
            return &operators[i];
        }
    }
    return NULL;
}

// 도움말 출력
void printHelp() {
    printf("\n=== 간단한 계산기 ===\n");
    printf("사용법: 숫자1 연산자 숫자2\n");
    printf("지원 연산자: ");
    for (int i = 0; i < operator_count; i++) {
        printf("%c(%s) ", operators[i].symbol, operators[i].name);
    }
    printf("\n종료: q\n\n");
}

int main() {
    double num1, num2, result;
    char op;
    char input[100];

    printHelp();

    while (1) {
        printf("계산식을 입력하세요 (예: 10 + 5): ");

        if (fgets(input, sizeof(input), stdin) == NULL) {
            break;
        }

        // 종료 체크
        if (input[0] == 'q' || input[0] == 'Q') {
            printf("계산기를 종료합니다.\n");
            break;
        }

        // 입력 파싱
        if (sscanf(input, "%lf %c %lf", &num1, &op, &num2) != 3) {
            printf("잘못된 입력입니다. 다시 시도하세요.\n");
            continue;
        }

        // 연산자 찾기
        Operator* operator = findOperator(op);
        if (operator == NULL) {
            printf("지원하지 않는 연산자입니다: %c\n", op);
            continue;
        }

        // 계산 실행
        result = operator->operation(num1, num2);
        printf("결과: %.2f %c %.2f = %.2f\n\n", num1, op, num2, result);
    }

    return 0;
}
```

## 함수 포인터의 고급 활용

### 함수를 반환하는 함수

함수 포인터를 반환값으로 사용할 수도 있습니다:

```c
#include <stdio.h>

// 기본 수학 함수들
double add_op(double a, double b) { return a + b; }
double mul_op(double a, double b) { return a * b; }
double sub_op(double a, double b) { return a - b; }

// 연산 타입
typedef enum {
    OP_ADD, OP_SUB, OP_MUL
} operation_type;

// 함수 포인터 타입 정의
typedef double (*MathOperation)(double, double);

// 연산 타입에 따라 적절한 함수를 반환
MathOperation getOperation(operation_type op) {
    switch (op) {
        case OP_ADD: return add_op;
        case OP_SUB: return sub_op;
        case OP_MUL: return mul_op;
        default: return NULL;
    }
}

int main() {
    double a = 10.5, b = 3.2;

    // 동적으로 연산 함수 선택
    MathOperation op = getOperation(OP_ADD);
    if (op != NULL) {
        printf("%.1f + %.1f = %.1f\n", a, b, op(a, b));
    }

    op = getOperation(OP_MUL);
    if (op != NULL) {
        printf("%.1f * %.1f = %.1f\n", a, b, op(a, b));
    }

    return 0;
}
```

### 플러그인 시스템 구현

함수 포인터를 사용하여 간단한 플러그인 시스템을 만들 수 있습니다:

```c
#include <stdio.h>
#include <string.h>

// 플러그인 인터페이스
typedef struct {
    char name[50];
    char version[20];
    void (*init)(void);
    void (*process)(const char* data);
    void (*cleanup)(void);
} Plugin;

// 텍스트 처리 플러그인
void text_plugin_init() {
    printf("[텍스트 플러그인] 초기화 완료\n");
}

void text_plugin_process(const char* data) {
    printf("[텍스트 플러그인] 처리 중: %s\n", data);
}

void text_plugin_cleanup() {
    printf("[텍스트 플러그인] 정리 완료\n");
}

// 로그 플러그인
void log_plugin_init() {
    printf("[로그 플러그인] 초기화 완료\n");
}

void log_plugin_process(const char* data) {
    printf("[로그 플러그인] 로그 기록: %s\n", data);
}

void log_plugin_cleanup() {
    printf("[로그 플러그인] 정리 완료\n");
}

// 플러그인 매니저
typedef struct {
    Plugin plugins[10];
    int count;
} PluginManager;

void plugin_manager_init(PluginManager* pm) {
    pm->count = 0;
}

void plugin_manager_register(PluginManager* pm, Plugin plugin) {
    if (pm->count < 10) {
        pm->plugins[pm->count++] = plugin;
        printf("플러그인 등록: %s v%s\n", plugin.name, plugin.version);
    }
}

void plugin_manager_process_all(PluginManager* pm, const char* data) {
    for (int i = 0; i < pm->count; i++) {
        pm->plugins[i].init();
        pm->plugins[i].process(data);
        pm->plugins[i].cleanup();
        printf("\n");
    }
}

int main() {
    PluginManager pm;
    plugin_manager_init(&pm);

    // 플러그인들 등록
    Plugin text_plugin = {
        "TextProcessor", "1.0",
        text_plugin_init,
        text_plugin_process,
        text_plugin_cleanup
    };

    Plugin log_plugin = {
        "Logger", "2.1",
        log_plugin_init,
        log_plugin_process,
        log_plugin_cleanup
    };

    plugin_manager_register(&pm, text_plugin);
    plugin_manager_register(&pm, log_plugin);

    // 모든 플러그인으로 데이터 처리
    printf("\n=== 데이터 처리 시작 ===\n");
    plugin_manager_process_all(&pm, "Hello, Plugin System!");

    return 0;
}
```

## 성능 고려사항

### 함수 포인터 vs 일반 함수 호출

함수 포인터는 간접 호출로 인한 약간의 성능 오버헤드가 있습니다:

```c
#include <stdio.h>
#include <time.h>

#define ITERATIONS 100000000

int direct_add(int a, int b) {
    return a + b;
}

int main() {
    int (*func_ptr)(int, int) = direct_add;
    clock_t start, end;

    // 직접 호출 성능 측정
    start = clock();
    for (int i = 0; i < ITERATIONS; i++) {
        direct_add(i, i + 1);
    }
    end = clock();
    double direct_time = ((double)(end - start)) / CLOCKS_PER_SEC;

    // 포인터 호출 성능 측정
    start = clock();
    for (int i = 0; i < ITERATIONS; i++) {
        func_ptr(i, i + 1);
    }
    end = clock();
    double pointer_time = ((double)(end - start)) / CLOCKS_PER_SEC;

    printf("직접 호출: %.3f초\n", direct_time);
    printf("포인터 호출: %.3f초\n", pointer_time);
    printf("오버헤드: %.1f%%\n",
           ((pointer_time - direct_time) / direct_time) * 100);

    return 0;
}
```

**일반적인 성능 특성:**
- 함수 포인터는 약간의 오버헤드 존재 (보통 5-15%)
- 현대 CPU의 분기 예측으로 오버헤드 감소
- 유연성과 성능 사이의 트레이드오프

## 디버깅 팁

### 함수 포인터 디버깅

함수 포인터 관련 문제를 디버깅하는 방법:

```c
#include <stdio.h>

// 디버그용 함수 포인터 래퍼
void debug_call(void (*func)(void), const char* func_name) {
    if (func == NULL) {
        printf("오류: %s 함수 포인터가 NULL입니다\n", func_name);
        return;
    }

    printf("호출: %s() - 주소: %p\n", func_name, (void*)func);
    func();
    printf("완료: %s()\n", func_name);
}

void test_function() {
    printf("  테스트 함수 실행 중...\n");
}

int main() {
    void (*ptr)(void) = test_function;

    debug_call(ptr, "test_function");
    debug_call(NULL, "null_function");  // NULL 포인터 테스트

    return 0;
}
```

## 실무에서의 함수 포인터 활용

### 1. 라이브러리 API 설계
- 콜백 함수로 사용자 정의 동작 허용
- 플랫폼별 구현 추상화
- 확장 가능한 인터페이스 제공

### 2. 이벤트 기반 프로그래밍
- GUI 이벤트 처리
- 네트워크 이벤트 핸들링
- 타이머 콜백

### 3. 알고리즘 일반화
- 정렬 함수의 비교 함수
- 검색 알고리즘의 조건 함수
- 필터링 작업

### 4. 상태 기계 구현
- 게임 AI 상태 관리
- 프로토콜 구현
- 워크플로우 시스템

## 마무리

함수 포인터는 **C언어에서 코드의 유연성을 극대화하는 강력한 도구**입니다. 이를 통해 다음과 같은 고급 프로그래밍 기법을 구현할 수 있습니다:

**핵심 기억사항:**
- 함수 포인터는 함수의 메모리 주소를 저장하는 변수
- 런타임에 호출할 함수를 동적으로 결정 가능
- 콜백 함수, 이벤트 시스템, 플러그인 아키텍처 구현에 필수
- typedef를 활용하여 복잡한 함수 포인터 타입 단순화
- 반드시 NULL 검사와 타입 호환성 확인 필요
- 약간의 성능 오버헤드가 있지만 유연성의 이점이 더 큼

**활용 분야:**
- 라이브러리 API 설계
- 이벤트 기반 프로그래밍
- 알고리즘 일반화
- 상태 기계 구현
- 플러그인 시스템
- GUI 프로그래밍

함수 포인터를 마스터하면 C언어로도 현대적이고 유연한 소프트웨어 아키텍처를 설계할 수 있게 됩니다. 이는 시스템 프로그래밍부터 응용 프로그램 개발까지 모든 영역에서 활용할 수 있는 핵심 기술입니다.