# 6.3 포인터와 문자열 (Pointers and Strings)

## 문자열의 본질적 이해

### 문자열이란 무엇인가?

C언어에서 **문자열은 문자들의 배열에 널 문자(`\0`)가 붙은 것**입니다. 문자열은 포인터와 깊은 관련이 있으며, 실제로 문자열 처리의 대부분은 포인터를 통해 이루어집니다.

```c
char str[] = "Hello";
// 메모리 구조: ['H']['e']['l']['l']['o']['\0']
//             [0] [1] [2] [3] [4] [5]
```

**핵심 개념**:
- 문자열 = 문자 배열 + 널 종료 문자(`\0`)
- 널 문자는 문자열의 끝을 나타내는 표시
- 문자열 길이는 널 문자를 제외한 문자 개수

### 문자열 저장의 두 가지 방법

```c
// 1. 문자 배열로 저장
char str1[6] = "Hello";     // 스택에 저장, 수정 가능
char str2[] = {'H','e','l','l','o','\0'};  // 동일한 효과

// 2. 문자열 리터럴의 포인터
char *str3 = "Hello";       // 리터럴 영역에 저장, 수정 불가 (일반적으로)
```

**중요한 차이점**:
- `char str[]`: 문자 배열, 수정 가능
- `char *str`: 포인터, 가리키는 문자열은 보통 수정 불가

## 문자열과 포인터의 관계

### 문자열명은 포인터

배열명이 첫 번째 요소의 주소인 것처럼, 문자열명도 첫 번째 문자의 주소입니다:

```c
char message[] = "Programming";
char *ptr = message;

printf("문자열: %s\n", message);
printf("포인터: %s\n", ptr);        // 동일한 결과

printf("첫 문자: %c\n", message[0]); // 'P'
printf("첫 문자: %c\n", *ptr);       // 'P' (동일)
```

### 포인터를 이용한 문자 접근

```c
char str[] = "Hello World";
char *p = str;

// 여러 가지 접근 방법
printf("첫 번째 문자: %c\n", str[0]);     // 'H'
printf("첫 번째 문자: %c\n", *p);         // 'H'
printf("두 번째 문자: %c\n", *(p + 1));   // 'e'
printf("두 번째 문자: %c\n", p[1]);       // 'e'
```

## 문자열 포인터 연산

### 포인터를 이용한 문자열 순회

```c
#include <stdio.h>

int main() {
    char message[] = "Hello, C!";
    char *ptr = message;

    // 방법 1: 인덱스를 이용한 순회
    printf("인덱스 방법: ");
    for (int i = 0; message[i] != '\0'; i++) {
        printf("%c", message[i]);
    }

    // 방법 2: 포인터 이동을 이용한 순회
    printf("\n포인터 방법: ");
    while (*ptr != '\0') {
        printf("%c", *ptr);
        ptr++;
    }

    // 방법 3: 포인터를 이용한 간결한 순회
    printf("\n간결한 방법: ");
    for (ptr = message; *ptr; ptr++) {  // *ptr이 0이 아닌 동안
        printf("%c", *ptr);
    }
    printf("\n");

    return 0;
}
```

### 문자열 길이 계산

```c
#include <stdio.h>

// 포인터를 이용한 문자열 길이 계산 함수
int stringLength(char *str) {
    int length = 0;
    while (*str != '\0') {
        length++;
        str++;
    }
    return length;
}

// 더 간결한 버전
int stringLength2(char *str) {
    char *start = str;
    while (*str) str++;
    return str - start;  // 포인터 차이로 길이 계산
}

int main() {
    char message[] = "Programming is fun!";

    printf("문자열: \"%s\"\n", message);
    printf("길이: %d\n", stringLength(message));
    printf("길이: %d\n", stringLength2(message));

    return 0;
}
```

## 문자열 함수 구현

### 문자열 복사 함수

```c
#include <stdio.h>

// 포인터를 이용한 문자열 복사
void stringCopy(char *dest, char *src) {
    while (*src != '\0') {
        *dest = *src;
        dest++;
        src++;
    }
    *dest = '\0';  // 널 문자 추가
}

// 더 간결한 버전
void stringCopy2(char *dest, char *src) {
    while ((*dest++ = *src++));  // 할당과 증가를 동시에
}

int main() {
    char source[] = "Hello World";
    char destination[20];

    stringCopy(destination, source);

    printf("원본: %s\n", source);
    printf("복사본: %s\n", destination);

    return 0;
}
```

### 문자열 연결 함수

```c
#include <stdio.h>

void stringConcatenate(char *dest, char *src) {
    // dest의 끝을 찾음
    while (*dest) {
        dest++;
    }

    // src를 dest 끝에 복사
    while (*src) {
        *dest = *src;
        dest++;
        src++;
    }
    *dest = '\0';
}

int main() {
    char str1[50] = "Hello ";
    char str2[] = "World!";

    printf("연결 전: \"%s\"\n", str1);

    stringConcatenate(str1, str2);

    printf("연결 후: \"%s\"\n", str1);

    return 0;
}
```

### 문자열 비교 함수

```c
#include <stdio.h>

int stringCompare(char *str1, char *str2) {
    while (*str1 && *str2 && (*str1 == *str2)) {
        str1++;
        str2++;
    }
    return *str1 - *str2;
}

int main() {
    char string1[] = "apple";
    char string2[] = "application";
    char string3[] = "apple";

    int result1 = stringCompare(string1, string2);
    int result2 = stringCompare(string1, string3);

    printf("\"%s\"와 \"%s\" 비교: %d\n", string1, string2, result1);
    printf("\"%s\"와 \"%s\" 비교: %d\n", string1, string3, result2);

    if (result2 == 0) {
        printf("두 문자열이 같습니다!\n");
    }

    return 0;
}
```

## 문자열 배열과 포인터

### 문자열 배열의 두 가지 표현

```c
// 1. 2차원 문자 배열
char names1[3][10] = {"Alice", "Bob", "Charlie"};

// 2. 문자열 포인터 배열
char *names2[3] = {"Alice", "Bob", "Charlie"};
```

**차이점**:
- `char names1[3][10]`: 각 문자열이 10바이트씩 고정 할당
- `char *names2[3]`: 각 포인터가 실제 문자열 길이만큼만 사용

### 문자열 배열 처리 예제

```c
#include <stdio.h>

int main() {
    // 문자열 포인터 배열
    char *fruits[] = {
        "Apple",
        "Banana",
        "Cherry",
        "Date",
        "Elderberry"
    };

    int count = sizeof(fruits) / sizeof(fruits[0]);

    // 모든 과일 이름 출력
    printf("과일 목록:\n");
    for (int i = 0; i < count; i++) {
        printf("%d. %s (길이: %zu)\n", i + 1, fruits[i], strlen(fruits[i]));
    }

    // 포인터를 이용한 접근
    char **ptr = fruits;
    printf("\n포인터를 통한 접근:\n");
    for (int i = 0; i < count; i++) {
        printf("- %s\n", *(ptr + i));
    }

    return 0;
}
```

## 동적 문자열 처리

### 동적 메모리를 이용한 문자열

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* createString(const char* source) {
    int length = strlen(source);
    char* newString = (char*)malloc((length + 1) * sizeof(char));

    if (newString != NULL) {
        strcpy(newString, source);
    }

    return newString;
}

int main() {
    char input[100];
    char *dynamicString;

    printf("문자열 입력: ");
    fgets(input, sizeof(input), stdin);

    // 개행문자 제거
    input[strcspn(input, "\n")] = '\0';

    // 동적 문자열 생성
    dynamicString = createString(input);

    if (dynamicString != NULL) {
        printf("저장된 문자열: \"%s\"\n", dynamicString);
        printf("문자열 길이: %zu\n", strlen(dynamicString));

        // 메모리 해제
        free(dynamicString);
    }

    return 0;
}
```

## 실전 예제

### 예제 1: 단어 개수 세기

```c
#include <stdio.h>
#include <ctype.h>

int countWords(char *str) {
    int count = 0;
    int inWord = 0;  // 현재 단어 내부인지 표시

    while (*str) {
        if (isspace(*str)) {
            inWord = 0;  // 공백 만나면 단어 외부
        } else if (!inWord) {
            inWord = 1;  // 단어 시작
            count++;
        }
        str++;
    }

    return count;
}

int main() {
    char sentence[] = "  Hello,   beautiful   world!  ";

    printf("문장: \"%s\"\n", sentence);
    printf("단어 개수: %d\n", countWords(sentence));

    return 0;
}
```

### 예제 2: 문자열 뒤집기

```c
#include <stdio.h>
#include <string.h>

void reverseString(char *str) {
    char *start = str;
    char *end = str + strlen(str) - 1;
    char temp;

    while (start < end) {
        // 두 문자 교환
        temp = *start;
        *start = *end;
        *end = temp;

        start++;
        end--;
    }
}

int main() {
    char message[] = "Programming";

    printf("원본: \"%s\"\n", message);
    reverseString(message);
    printf("뒤집힌 문자열: \"%s\"\n", message);

    return 0;
}
```

### 예제 3: 부분 문자열 찾기

```c
#include <stdio.h>

char* findSubstring(char *haystack, char *needle) {
    char *h, *n;

    while (*haystack) {
        h = haystack;
        n = needle;

        // needle의 모든 문자가 일치하는지 확인
        while (*n && *h && (*h == *n)) {
            h++;
            n++;
        }

        // needle의 끝에 도달하면 찾았음
        if (*n == '\0') {
            return haystack;
        }

        haystack++;
    }

    return NULL;  // 찾지 못함
}

int main() {
    char text[] = "The quick brown fox jumps over the lazy dog";
    char pattern[] = "brown";

    char *result = findSubstring(text, pattern);

    if (result != NULL) {
        printf("원본: \"%s\"\n", text);
        printf("패턴: \"%s\"\n", pattern);
        printf("찾은 위치: %ld\n", result - text);
        printf("찾은 부분: \"%s\"\n", result);
    } else {
        printf("패턴을 찾지 못했습니다.\n");
    }

    return 0;
}
```

### 예제 4: 문자열 토큰화 (단어 분리)

```c
#include <stdio.h>
#include <ctype.h>

void tokenizeString(char *str) {
    char *start = str;
    char *current = str;
    int tokenNumber = 1;

    printf("토큰 분리 결과:\n");

    while (*current) {
        // 공백이 아닌 문자를 찾음
        while (*start && isspace(*start)) {
            start++;
        }

        if (*start == '\0') break;

        current = start;

        // 단어의 끝을 찾음
        while (*current && !isspace(*current)) {
            current++;
        }

        // 단어 출력
        printf("토큰 %d: ", tokenNumber++);
        for (char *p = start; p < current; p++) {
            printf("%c", *p);
        }
        printf("\n");

        start = current;
    }
}

int main() {
    char sentence[] = "  Hello   world   from   C programming  ";

    printf("원본: \"%s\"\n", sentence);
    tokenizeString(sentence);

    return 0;
}
```

## 문자열 처리 시 주의사항

### 1. 버퍼 오버플로우 방지

```c
// 위험한 코드
char buffer[10];
char *source = "This is a very long string!";
// strcpy(buffer, source);  // 버퍼 오버플로우!

// 안전한 코드
if (strlen(source) < sizeof(buffer)) {
    strcpy(buffer, source);
} else {
    printf("문자열이 너무 깁니다!\n");
}
```

### 2. 널 포인터 검사

```c
int safeStringLength(char *str) {
    if (str == NULL) {
        return 0;  // 또는 -1 (에러 표시)
    }

    int length = 0;
    while (*str++) {
        length++;
    }
    return length;
}
```

### 3. 읽기 전용 문자열 수정 방지

```c
char *readOnlyString = "Hello";  // 리터럴 영역
// readOnlyString[0] = 'h';      // 런타임 에러 가능

// 수정 가능한 문자열
char modifiableString[] = "Hello";
modifiableString[0] = 'h';  // 안전함
```

## 마무리

포인터와 문자열의 관계는 **C언어에서 텍스트 처리의 핵심**입니다. 이 관계를 정확히 이해하면 효율적이고 강력한 문자열 처리 프로그램을 작성할 수 있습니다.

**핵심 기억사항:**
- 문자열은 널 문자(`\0`)로 끝나는 문자 배열
- 문자열명은 첫 번째 문자를 가리키는 포인터
- 포인터 산술 연산으로 문자열 순회 가능
- 문자 배열과 문자열 포인터는 다른 특성을 가짐
- 동적 메모리를 활용한 유연한 문자열 처리
- 항상 버퍼 오버플로우와 널 포인터 검사 필요

문자열과 포인터의 마스터리는 시스템 프로그래밍, 텍스트 처리, 파싱 등 다양한 영역에서 강력한 도구가 됩니다.