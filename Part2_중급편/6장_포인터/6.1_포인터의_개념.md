# 6.1 포인터의 개념 (Concept of Pointers)

## 포인터란 무엇인가?

### 포인터의 본질적 이해

포인터(Pointer)는 **메모리 주소를 저장하는 변수**입니다. 쉽게 말해, 어떤 데이터가 저장된 위치를 가리키는 "이정표" 역할을 합니다.

일상생활의 비유로 이해해보겠습니다:
- **집 주소**: "서울시 강남구 테헤란로 123번지"
- **포인터**: 이 주소를 적어놓은 쪽지
- **실제 집**: 그 주소에 위치한 건물

포인터는 데이터 자체가 아니라 **데이터가 저장된 위치(주소)**를 담고 있습니다.

### 메모리와 주소의 이해

컴퓨터 메모리는 거대한 **우편함 집합**으로 생각할 수 있습니다:

```c
// 메모리 구조 (개념적 표현)
// 주소     값      변수명
// 1000:    42      int num = 42;
// 1004:   1000     int *ptr = &num;  // num의 주소를 저장
// 1008:    3.14    float pi = 3.14;
```

- 각 메모리 위치는 고유한 **주소**를 가집니다
- 변수는 특정 주소부터 시작하는 메모리 공간에 저장됩니다
- 포인터는 이런 주소 값을 저장하는 특별한 변수입니다

## 포인터 선언과 초기화

### 포인터 선언의 문법

```c
자료형 *포인터명;
```

별표(`*`)는 "이 변수는 포인터다"라는 의미입니다.

```c
int *ptr;        // 정수를 가리키는 포인터
float *fptr;     // 실수를 가리키는 포인터
char *cptr;      // 문자를 가리키는 포인터
```

### 주소 연산자 (&)와 간접 연산자 (*)

**주소 연산자 (&)**: "~의 주소"를 의미합니다.
```c
int num = 42;
int *ptr = &num;    // num의 주소를 ptr에 저장
```

**간접 연산자 (*)**: "~가 가리키는 곳의 값"을 의미합니다.
```c
int value = *ptr;   // ptr이 가리키는 곳의 값을 가져옴
```

### 포인터의 완전한 예제

```c
#include <stdio.h>

int main() {
    int number = 100;        // 일반 변수
    int *ptr;               // 포인터 선언

    ptr = &number;          // number의 주소를 ptr에 저장

    printf("number의 값: %d\n", number);        // 100
    printf("number의 주소: %p\n", &number);     // 예: 0x7fff5c3c291c
    printf("ptr의 값 (주소): %p\n", ptr);       // number의 주소와 동일
    printf("ptr이 가리키는 값: %d\n", *ptr);    // 100

    return 0;
}
```

## 포인터의 동작 원리

### 메모리 상에서의 포인터

```c
int num = 42;
int *ptr = &num;

// 메모리 구조 예시
// 주소    변수명    값
// 2000    num      42
// 2004    ptr      2000  (num의 주소)
```

### 간접 참조의 과정

`*ptr`을 사용할 때 일어나는 일:
1. ptr의 값(주소)을 읽습니다 → 2000
2. 그 주소(2000)로 이동합니다
3. 해당 위치의 값을 가져옵니다 → 42

이것이 "간접 참조(dereferencing)"입니다.

## 포인터를 통한 값 변경

### 직접 변경 vs 간접 변경

```c
#include <stdio.h>

int main() {
    int num = 100;
    int *ptr = &num;

    printf("초기값: %d\n", num);        // 100

    // 직접 변경
    num = 200;
    printf("직접 변경 후: %d\n", num);   // 200
    printf("포인터로 확인: %d\n", *ptr);  // 200 (같은 값)

    // 간접 변경
    *ptr = 300;
    printf("간접 변경 후: %d\n", num);   // 300
    printf("포인터로 확인: %d\n", *ptr);  // 300

    return 0;
}
```

두 방식 모두 같은 메모리 위치의 값을 변경하므로 결과가 동일합니다.

## 포인터의 자료형과 크기

### 포인터의 자료형이 중요한 이유

포인터의 자료형은 **가리키는 데이터의 해석 방법**을 결정합니다:

```c
int num = 0x12345678;
int *int_ptr = &num;
char *char_ptr = (char*)&num;

printf("int 포인터로 읽기: %d\n", *int_ptr);      // 전체 4바이트 읽기
printf("char 포인터로 읽기: %d\n", *char_ptr);    // 첫 1바이트만 읽기
```

### 포인터의 크기

**중요한 사실**: 모든 포인터의 크기는 **동일**합니다.
- 32비트 시스템: 4바이트
- 64비트 시스템: 8바이트

```c
printf("int* 크기: %zu\n", sizeof(int*));     // 8 (64비트 시스템)
printf("float* 크기: %zu\n", sizeof(float*));  // 8
printf("char* 크기: %zu\n", sizeof(char*));   // 8
```

가리키는 데이터의 타입과 관계없이 포인터는 항상 "주소"만 저장하기 때문입니다.

## 포인터 사용 시 주의사항

### 1. 초기화되지 않은 포인터

```c
int *ptr;           // 위험! 임의의 주소를 가리킴
*ptr = 100;         // 심각한 오류 발생 가능

// 올바른 방법
int num = 0;
int *ptr = &num;    // 안전하게 초기화
*ptr = 100;         // 안전한 사용
```

### 2. NULL 포인터의 활용

```c
int *ptr = NULL;    // NULL로 초기화

if (ptr != NULL) {  // 사용 전 검사
    *ptr = 100;
} else {
    printf("포인터가 유효하지 않습니다.\n");
}
```

### 3. 댕글링 포인터 (Dangling Pointer)

```c
int *ptr;
{
    int local_var = 100;
    ptr = &local_var;      // 지역변수의 주소를 저장
}  // local_var가 소멸됨

// *ptr = 200;             // 위험! 유효하지 않은 주소 접근
```

## 실전 예제

### 예제 1: 두 변수의 값 교환

```c
#include <stdio.h>

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 10, y = 20;

    printf("교환 전: x=%d, y=%d\n", x, y);
    swap(&x, &y);
    printf("교환 후: x=%d, y=%d\n", x, y);

    return 0;
}
```

### 예제 2: 포인터를 통한 데이터 조작

```c
#include <stdio.h>

int main() {
    int numbers[3] = {10, 20, 30};
    int *ptr = numbers;  // 배열의 첫 번째 요소를 가리킴

    printf("배열 요소들:\n");
    for (int i = 0; i < 3; i++) {
        printf("numbers[%d] = %d\n", i, numbers[i]);
    }

    printf("\n포인터를 통한 접근:\n");
    printf("*ptr = %d\n", *ptr);           // 첫 번째 요소
    printf("*(ptr+1) = %d\n", *(ptr+1));   // 두 번째 요소
    printf("*(ptr+2) = %d\n", *(ptr+2));   // 세 번째 요소

    // 포인터를 통한 값 변경
    *ptr = 100;        // 첫 번째 요소 변경
    *(ptr+1) = 200;    // 두 번째 요소 변경

    printf("\n변경 후:\n");
    for (int i = 0; i < 3; i++) {
        printf("numbers[%d] = %d\n", i, numbers[i]);
    }

    return 0;
}
```

### 예제 3: 포인터 체인

```c
#include <stdio.h>

int main() {
    int value = 42;
    int *ptr1 = &value;      // value를 가리키는 포인터
    int **ptr2 = &ptr1;      // ptr1을 가리키는 포인터의 포인터

    printf("value = %d\n", value);
    printf("*ptr1 = %d\n", *ptr1);
    printf("**ptr2 = %d\n", **ptr2);

    // 이중 포인터를 통한 값 변경
    **ptr2 = 100;
    printf("\n값 변경 후:\n");
    printf("value = %d\n", value);

    return 0;
}
```

## 포인터의 장점과 활용

### 1. 메모리 효율성
- 큰 데이터를 복사하지 않고 주소만 전달
- 함수 간 데이터 공유 효율적

### 2. 동적 메모리 관리
- 프로그램 실행 중 메모리 할당/해제
- 데이터 크기를 런타임에 결정

### 3. 자료구조 구현
- 연결 리스트, 트리, 그래프 등 복잡한 자료구조
- 노드 간의 연결을 포인터로 표현

### 4. 함수의 다중 반환값
- 포인터 매개변수를 통해 여러 값을 반환

## 마무리

포인터는 **메모리 주소를 다루는 강력한 도구**입니다. C언어의 핵심 개념 중 하나로, 다음과 같은 특징을 가집니다:

**핵심 기억사항:**
- 포인터는 메모리 주소를 저장하는 변수
- `&`는 주소를 얻고, `*`는 그 주소의 값에 접근
- 모든 포인터의 크기는 동일 (시스템 의존적)
- 반드시 초기화 후 사용해야 함
- NULL 검사로 안전성 확보

포인터를 정확히 이해하면 C언어의 진정한 힘을 발휘할 수 있습니다. 메모리를 직접 제어하며 효율적이고 강력한 프로그램을 작성할 수 있는 기반이 됩니다.