# 6.2 포인터와 배열 (Pointers and Arrays)

## 배열과 포인터의 존재론적 통일성

### 배열명의 이중성: 타입과 값

배열과 포인터의 관계는 C언어에서 가장 심오한 개념 중 하나입니다. 이는 **타입(Type)과 값(Value)의 이중성**을 보여줍니다:

```c
int arr[5];
```

이 선언에서 `arr`는:
1. **타입으로서**: `int[5]` (크기가 5인 정수 배열)
2. **값으로서**: `int*` (첫 번째 요소를 가리키는 포인터)

이는 **하나의 존재가 두 가지 관점**을 가질 수 있음을 보여주는 철학적 개념입니다.

### 배열의 메타물리학

배열은 단순한 데이터 집합이 아닙니다. 이는 **연속성(Continuity)**과 **동질성(Homogeneity)**이라는 두 가지 근본 속성을 가집니다:

**연속성**: 메모리 상에서 요소들이 **인접하게** 배치됨
- 이는 **지역성(Locality)**의 원리를 구현
- 캐시 효율성과 직결
- 순차 접근의 근본 토대

**동질성**: 모든 요소가 **같은 타입**을 가짐
- 타입 안전성 보장
- 균일한 메모리 레이아웃
- 포인터 산술의 기초

## 메모리 레이아웃의 기하학

### 선형성과 차원성

배열의 메모리 레이아웃은 **선형적(Linear)**이지만, 개념적으로는 **다차원적**일 수 있습니다:

```c
int arr1D[10];           // 1차원: 선형 배열
int arr2D[3][4];         // 2차원: 행렬
int arr3D[2][3][4];      // 3차원: 텐서
```

그러나 메모리는 본질적으로 **1차원**입니다. 다차원 배열은 **매핑(Mapping)**을 통해 구현됩니다:

```
2차원 배열 arr[i][j]의 선형 주소:
address = base + (i × columns + j) × sizeof(element_type)
```

이는 **공간의 차원 축약**이라는 수학적 개념의 구현입니다.

### 메모리 정렬과 패딩

컴퓨터는 **정렬(Alignment)**을 통해 메모리 접근을 최적화합니다:

```c
struct mixed {
    char c;      // 1바이트
    int i;       // 4바이트 (3바이트 패딩 후)
    char c2;     // 1바이트 (3바이트 패딩 후)
};
// 총 크기: 12바이트 (논리적으로는 6바이트)
```

이는 **효율성과 단순성** 사이의 트레이드오프를 보여줍니다.

## 포인터 산술의 수학적 구조

### 아핀 공간(Affine Space)으로서의 메모리

포인터 산술은 일반적인 산술이 아닙니다. 이는 **아핀 공간**의 연산입니다:

**점(Point)**: 포인터
**벡터(Vector)**: 정수 오프셋
**연산**:
- `point + vector = point` (포인터 + 정수 = 포인터)
- `point - point = vector` (포인터 - 포인터 = 거리)
- `point - vector = point` (포인터 - 정수 = 포인터)

```c
int arr[10];
int *p1 = arr + 3;      // 점 + 벡터 = 점
int *p2 = arr + 7;      // 점 + 벡터 = 점
ptrdiff_t diff = p2 - p1;  // 점 - 점 = 벡터 (값: 4)
```

### 스케일링(Scaling)의 개념

포인터 산술에서 `+1`은 **1바이트**가 아니라 **1개 요소의 크기**만큼 이동입니다:

```c
char *cp;    cp++;  // 1바이트 이동
int *ip;     ip++;  // 4바이트 이동
double *dp;  dp++;  // 8바이트 이동
```

이는 **추상적 거리**와 **물리적 거리**의 분리를 나타냅니다.

## 배열과 포인터의 동치성과 차이성

### 구조적 동치성

대부분의 상황에서 배열과 포인터는 **구조적으로 동치**입니다:

```c
arr[i] ≡ *(arr + i) ≡ *(i + arr) ≡ i[arr]
```

마지막 표현 `i[arr]`는 가환성(Commutativity)을 보여주는 놀라운 결과입니다.

### 본질적 차이성

하지만 둘 사이에는 근본적 차이가 있습니다:

| 특성 | 배열 | 포인터 |
|------|------|---------|
| **존재성** | 컴파일 시 고정된 메모리 블록 | 주소값을 담는 변수 |
| **가변성** | 불변 (배열명은 상수) | 가변 (다른 주소 할당 가능) |
| **크기 정보** | 타입에 포함 | 타입에 미포함 |
| **초기화** | 선언 시에만 가능 | 언제든 가능 |
| **메모리** | 요소들을 직접 보유 | 주소값만 보유 |

## 배열 매개변수의 퇴화(Array Decay)

### 차원 손실의 현상

함수 매개변수로 배열을 전달할 때 **차원 정보가 손실**됩니다:

```c
void func(int arr[10]);     // 실제로는 int *arr
void func(int arr[]);       // 동일함
void func(int *arr);        // 동일함
```

이를 **배열의 포인터로의 퇴화(Array-to-pointer decay)**라고 합니다. 이는 다음을 의미합니다:

1. **크기 정보 손실**: `sizeof(arr)`는 배열 크기가 아닌 포인터 크기 반환
2. **타입 변환**: `int[n]`에서 `int*`로 변환
3. **의미적 변화**: 소유권에서 참조로

### 함수 인터페이스의 설계 철학

이런 퇴화는 **일관성(Uniformity)**을 위한 설계 선택입니다:
- 크기에 관계없이 동일한 방식으로 처리
- 메모리 효율성 (복사 대신 참조)
- 유연성 (가변 크기 배열 처리 가능)

하지만 동시에 **타입 안전성의 손실**이라는 대가를 치릅니다.

## 다차원 배열과 포인터의 복잡성

### 행렬의 메모리 표현

2차원 배열은 **행 우선(Row-major)**으로 저장됩니다:

```c
int matrix[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// 메모리 레이아웃: [1][2][3][4][5][6][7][8][9][10][11][12]
```

### 포인터의 포인터 vs 배열의 배열

```c
// 배열의 배열 (연속 메모리)
int arr2D[3][4];
int (*ptr_to_arr)[4] = arr2D;  // 배열을 가리키는 포인터

// 포인터의 배열 (비연속 메모리 가능)
int *ptr_arr[3];               // 포인터들의 배열
int **ptr_to_ptr = ptr_arr;    // 포인터를 가리키는 포인터
```

이는 **연속성 vs 유연성**의 트레이드오프를 보여줍니다.

## 동적 메모리와 배열

### 힙에서의 배열

동적 할당된 메모리는 **런타임 배열**을 생성합니다:

```c
int *dynamic_array = malloc(n * sizeof(int));
```

이는 **컴파일 타임 결정**에서 **런타임 결정**으로의 패러다임 전환입니다.

### 가변 길이 배열 (VLA)

C99에서 도입된 VLA는 스택에서 가변 크기 배열을 허용합니다:

```c
void func(int n) {
    int vla[n];  // 런타임에 크기 결정
}
```

이는 **정적 할당의 동적화**라는 개념적 혁신입니다.

## 메모리 순회의 패턴과 성능

### 공간적 지역성 (Spatial Locality)

연속된 메모리 접근은 **캐시 친화적**입니다:

```c
// 캐시 친화적 (순차 접근)
for (int i = 0; i < n; i++) {
    process(arr[i]);
}

// 캐시 비친화적 (무작위 접근)
for (int i = 0; i < n; i++) {
    process(arr[random_index[i]]);
}
```

### 시간적 지역성 (Temporal Locality)

최근 접근한 메모리를 다시 접근할 가능성이 높습니다:

```c
// 시간적 지역성 활용
int sum = 0;
for (int i = 0; i < n; i++) {
    sum += arr[i];  // arr[i]를 여러 번 사용
}
```

## 배열과 포인터의 철학적 함의

### 집합론적 관점

배열은 **순서가 있는 집합(Ordered Set)**입니다:
- 인덱스는 **순서 관계(Order Relation)**
- 요소들은 **집합의 원소(Elements)**
- 크기는 **집합의 기수(Cardinality)**

### 함수론적 관점

배열은 **정의역이 정수인 함수**로 볼 수 있습니다:
- `f: {0, 1, 2, ..., n-1} → T`
- `f(i) = arr[i]`

이는 **이산 수학**과 **프로그래밍**의 연결점입니다.

### 타입론적 관점

배열의 타입 `T[n]`은 **의존 타입(Dependent Type)**의 예입니다:
- 타입이 값(크기 n)에 의존
- 컴파일 시 타입 검사
- 정적 보증과 최적화 가능

## 최적화와 컴파일러의 이해

### 루프 벡터화 (Loop Vectorization)

컴파일러는 배열의 연속성을 이용해 **SIMD 명령어**를 생성합니다:

```c
// 벡터화 가능
for (int i = 0; i < n; i++) {
    c[i] = a[i] + b[i];
}
```

### 경계 검사 제거 (Bounds Check Elimination)

컴파일러는 정적 분석을 통해 불필요한 경계 검사를 제거합니다:

```c
for (int i = 0; i < 10; i++) {
    arr[i] = 0;  // 경계 검사 불필요 (정적으로 안전함을 증명 가능)
}
```

## 마무리: 배열과 포인터의 변증법

배열과 포인터의 관계는 **통일성과 대립성의 변증법**입니다:

**통일성 (Thesis)**:
- 대부분의 맥락에서 교환 가능
- 동일한 메모리 접근 패턴
- 포인터 산술의 공통 기반

**대립성 (Antithesis)**:
- 타입 시스템에서의 차이
- 메모리 레이아웃의 차이
- 소유권과 생명주기의 차이

**종합성 (Synthesis)**:
- 상황에 따른 적절한 선택
- 각각의 강점을 활용
- 타입 안전성과 유연성의 균형

포인터와 배열을 이해하는 것은 **메모리라는 물리적 현실**과 **추상화라는 개념적 도구** 사이의 관계를 이해하는 것입니다. 이는 효율적이고 안전한 프로그래밍의 토대가 됩니다.

## 포인터를 이용한 배열 접근

### 배열 접근의 두 가지 방법

배열 요소에 접근하는 방법은 크게 두 가지입니다:

```c
int arr[5] = {10, 20, 30, 40, 50};

// 1. 배열 표기법 (Array Notation)
printf("%d\n", arr[2]);    // 30

// 2. 포인터 표기법 (Pointer Notation)
printf("%d\n", *(arr + 2)); // 30 (동일한 결과)
```

### 포인터 산술 연산의 원리

포인터에 정수를 더하면 **그 자료형의 크기만큼** 주소가 증가합니다:

```c
int arr[5] = {10, 20, 30, 40, 50};
int *ptr = arr;  // 첫 번째 요소를 가리킴

printf("ptr: %p\n", ptr);        // 1000 (예시)
printf("ptr+1: %p\n", ptr+1);    // 1004 (int는 4바이트이므로 +4)
printf("ptr+2: %p\n", ptr+2);    // 1008 (+8)
printf("ptr+3: %p\n", ptr+3);    // 1012 (+12)
```

**중요**: `ptr + 1`은 "다음 바이트"가 아니라 "다음 요소"를 의미합니다.

### 배열 표기법과 포인터 표기법의 동등성

```c
int arr[5] = {10, 20, 30, 40, 50};

// 다음은 모두 동일한 의미
arr[i] ≡ *(arr + i) ≡ *(i + arr) ≡ i[arr]

// 실제 사용 예
for (int i = 0; i < 5; i++) {
    printf("arr[%d] = %d\n", i, arr[i]);        // 일반적 방법
    printf("*(arr+%d) = %d\n", i, *(arr + i));   // 포인터 방법
}
```

## 포인터 변수를 이용한 배열 순회

### for문을 이용한 배열 순회

```c
#include <stdio.h>

int main() {
    int numbers[5] = {10, 20, 30, 40, 50};
    int *ptr;

    // 방법 1: 인덱스를 이용한 포인터 접근
    for (int i = 0; i < 5; i++) {
        printf("numbers[%d] = %d\n", i, *(numbers + i));
    }

    // 방법 2: 포인터 이동을 이용한 접근
    printf("\n포인터 이동을 통한 순회:\n");
    for (ptr = numbers; ptr < numbers + 5; ptr++) {
        printf("값: %d, 주소: %p\n", *ptr, ptr);
    }

    return 0;
}
```

### 포인터를 이용한 역순 접근

```c
#include <stdio.h>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int *ptr;

    printf("정순 출력: ");
    for (ptr = arr; ptr < arr + 5; ptr++) {
        printf("%d ", *ptr);
    }

    printf("\n역순 출력: ");
    for (ptr = arr + 4; ptr >= arr; ptr--) {
        printf("%d ", *ptr);
    }
    printf("\n");

    return 0;
}
```

## 배열을 매개변수로 전달하기

### 배열 매개변수의 본질

함수에 배열을 전달할 때, 실제로는 **첫 번째 요소의 주소**가 전달됩니다:

```c
// 다음 세 선언은 모두 동일함
void printArray(int arr[], int size);
void printArray(int *arr, int size);
void printArray(int arr[10], int size);  // 크기는 무시됨
```

### 배열 처리 함수의 예제

```c
#include <stdio.h>

// 배열 출력 함수
void printArray(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);  // 또는 *(arr + i)
    }
    printf("\n");
}

// 배열 합계 계산 함수
int sumArray(int *arr, int size) {
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += *(arr + i);
    }
    return sum;
}

// 배열에서 최댓값 찾기
int findMax(int *arr, int size) {
    int max = *arr;  // 첫 번째 요소로 초기화

    for (int i = 1; i < size; i++) {
        if (*(arr + i) > max) {
            max = *(arr + i);
        }
    }
    return max;
}

int main() {
    int numbers[] = {15, 32, 8, 47, 23, 6, 91, 12};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    printf("배열: ");
    printArray(numbers, size);

    printf("합계: %d\n", sumArray(numbers, size));
    printf("최댓값: %d\n", findMax(numbers, size));

    return 0;
}
```

## 포인터 배열 vs 배열 포인터

### 포인터 배열 (Array of Pointers)

```c
int a = 10, b = 20, c = 30;
int *ptr_array[3];  // 포인터들의 배열

// 각 포인터에 변수의 주소 할당
ptr_array[0] = &a;
ptr_array[1] = &b;
ptr_array[2] = &c;

printf("포인터 배열을 통한 접근:\n");
for (int i = 0; i < 3; i++) {
    printf("ptr_array[%d]가 가리키는 값: %d\n", i, *ptr_array[i]);
}
```

### 배열 포인터 (Pointer to Array)

```c
int arr[3] = {10, 20, 30};
int (*array_ptr)[3] = &arr;  // 배열 전체를 가리키는 포인터

// 배열 포인터를 통한 접근
for (int i = 0; i < 3; i++) {
    printf("(*array_ptr)[%d] = %d\n", i, (*array_ptr)[i]);
}
```

**구분하는 법**:
- `int *ptr[3]`: 포인터 배열 (3개의 int 포인터)
- `int (*ptr)[3]`: 배열 포인터 (3개 int 배열을 가리키는 포인터)

## 동적 배열과 포인터

### malloc을 이용한 동적 배열

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int size;
    int *dynamic_array;

    printf("배열 크기 입력: ");
    scanf("%d", &size);

    // 동적 메모리 할당
    dynamic_array = (int*)malloc(size * sizeof(int));

    if (dynamic_array == NULL) {
        printf("메모리 할당 실패!\n");
        return 1;
    }

    // 배열에 값 입력
    printf("%d개의 정수 입력: ", size);
    for (int i = 0; i < size; i++) {
        scanf("%d", &dynamic_array[i]);
    }

    // 배열 출력
    printf("입력된 배열: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", dynamic_array[i]);
    }
    printf("\n");

    // 메모리 해제
    free(dynamic_array);
    return 0;
}
```

## 다차원 배열과 포인터

### 2차원 배열과 포인터

```c
int arr2D[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// 2차원 배열의 메모리 구조는 1차원으로 연속 배치
// [1][2][3][4][5][6][7][8][9][10][11][12]

// 포인터를 이용한 2차원 배열 접근
int *ptr = (int*)arr2D;  // 1차원 포인터로 캐스팅

for (int i = 0; i < 12; i++) {
    printf("%d ", *(ptr + i));
    if ((i + 1) % 4 == 0) printf("\n");
}
```

### 행 단위 포인터 접근

```c
int arr2D[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};

// 각 행의 시작 주소 출력
for (int i = 0; i < 3; i++) {
    printf("행 %d 주소: %p\n", i, arr2D[i]);

    // 해당 행의 모든 요소 출력
    for (int j = 0; j < 4; j++) {
        printf("%d ", *(arr2D[i] + j));  // arr2D[i][j]와 동일
    }
    printf("\n");
}
```

## 실전 예제

### 예제 1: 배열 내 특정 값 검색

```c
#include <stdio.h>

int* findValue(int *arr, int size, int target) {
    for (int i = 0; i < size; i++) {
        if (*(arr + i) == target) {
            return arr + i;  // 찾은 요소의 주소 반환
        }
    }
    return NULL;  // 찾지 못한 경우
}

int main() {
    int numbers[] = {10, 23, 45, 67, 89, 12, 34};
    int size = sizeof(numbers) / sizeof(numbers[0]);
    int target = 67;

    int *result = findValue(numbers, size, target);

    if (result != NULL) {
        int index = result - numbers;  // 포인터 차이로 인덱스 계산
        printf("값 %d를 인덱스 %d에서 발견 (주소: %p)\n",
               target, index, result);
    } else {
        printf("값 %d를 찾을 수 없습니다.\n", target);
    }

    return 0;
}
```

### 예제 2: 배열 뒤집기 (포인터 활용)

```c
#include <stdio.h>

void reverseArray(int *arr, int size) {
    int *start = arr;           // 시작 포인터
    int *end = arr + size - 1;  // 끝 포인터
    int temp;

    while (start < end) {
        // 두 값 교환
        temp = *start;
        *start = *end;
        *end = temp;

        start++;  // 시작 포인터 오른쪽 이동
        end--;    // 끝 포인터 왼쪽 이동
    }
}

int main() {
    int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    printf("원래 배열: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", numbers[i]);
    }

    reverseArray(numbers, size);

    printf("\n뒤집힌 배열: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");

    return 0;
}
```

### 예제 3: 포인터를 이용한 배열 정렬 (버블 정렬)

```c
#include <stdio.h>

void bubbleSort(int *arr, int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (*(arr + j) > *(arr + j + 1)) {
                // 두 요소 교환
                int temp = *(arr + j);
                *(arr + j) = *(arr + j + 1);
                *(arr + j + 1) = temp;
            }
        }
    }
}

int main() {
    int numbers[] = {64, 34, 25, 12, 22, 11, 90};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    printf("정렬 전: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", numbers[i]);
    }

    bubbleSort(numbers, size);

    printf("\n정렬 후: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");

    return 0;
}
```

## 포인터와 배열의 차이점

### 유사점과 차이점

| 특성 | 배열 | 포인터 |
|------|------|---------|
| 메모리 할당 | 연속적 고정 공간 | 주소값만 저장 |
| 크기 변경 | 불가능 | 가리키는 대상 변경 가능 |
| sizeof 결과 | 전체 배열 크기 | 포인터 자체 크기 |
| 증감 연산 | 불가능 (arr++ 에러) | 가능 (ptr++) |
| 초기화 | 선언 시에만 가능 | 언제든 가능 |

```c
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr;

printf("sizeof(arr): %zu\n", sizeof(arr));   // 20 (5 * 4바이트)
printf("sizeof(ptr): %zu\n", sizeof(ptr));   // 8 (64비트 시스템)

// arr++;  // 컴파일 에러! 배열명은 상수
ptr++;     // 정상 동작
```

## 마무리

포인터와 배열의 관계는 **C언어의 핵심 개념** 중 하나입니다. 이 관계를 정확히 이해하면 메모리 효율적이고 강력한 프로그램을 작성할 수 있습니다.

**핵심 기억사항:**
- 배열명은 첫 번째 요소를 가리키는 포인터 상수
- `arr[i]`와 `*(arr + i)`는 동일한 의미
- 포인터 산술 연산은 자료형 크기 단위로 수행
- 함수에 배열 전달 시 포인터로 전달됨
- 포인터 배열과 배열 포인터는 다른 개념
- 동적 배열 생성과 관리에 포인터 활용

이러한 이해를 바탕으로 다음 단계인 문자열과 포인터의 관계, 그리고 함수 포인터로 나아갈 수 있습니다.