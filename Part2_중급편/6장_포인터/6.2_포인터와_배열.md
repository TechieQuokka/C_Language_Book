# 6.2 포인터와 배열 (Pointers and Arrays)

## 배열과 포인터의 밀접한 관계

### 배열명의 정체

배열과 포인터는 **C언어에서 가장 밀접한 관계**를 가지는 개념입니다. 실제로 배열명은 **첫 번째 요소를 가리키는 포인터 상수**입니다.

```c
int arr[5] = {10, 20, 30, 40, 50};

// 다음 세 가지는 모두 동일한 주소를 가리킴
printf("배열명: %p\n", arr);        // 배열의 시작 주소
printf("첫 요소의 주소: %p\n", &arr[0]);  // 첫 번째 요소의 주소
printf("포인터: %p\n", &arr);       // 배열 전체의 주소 (값은 같지만 의미가 다름)
```

### 메모리 상에서 배열과 포인터

```c
int numbers[4] = {10, 20, 30, 40};

// 메모리 구조 (예시)
// 주소    값     인덱스
// 1000    10     numbers[0]
// 1004    20     numbers[1]
// 1008    30     numbers[2]
// 1012    40     numbers[3]

// numbers는 1000번지를 가리키는 포인터 상수
```

**핵심 이해**: 배열명 `numbers`는 주소 1000을 담고 있는 포인터와 동일하게 동작합니다.

## 포인터를 이용한 배열 접근

### 배열 접근의 두 가지 방법

배열 요소에 접근하는 방법은 크게 두 가지입니다:

```c
int arr[5] = {10, 20, 30, 40, 50};

// 1. 배열 표기법 (Array Notation)
printf("%d\n", arr[2]);    // 30

// 2. 포인터 표기법 (Pointer Notation)
printf("%d\n", *(arr + 2)); // 30 (동일한 결과)
```

### 포인터 산술 연산의 원리

포인터에 정수를 더하면 **그 자료형의 크기만큼** 주소가 증가합니다:

```c
int arr[5] = {10, 20, 30, 40, 50};
int *ptr = arr;  // 첫 번째 요소를 가리킴

printf("ptr: %p\n", ptr);        // 1000 (예시)
printf("ptr+1: %p\n", ptr+1);    // 1004 (int는 4바이트이므로 +4)
printf("ptr+2: %p\n", ptr+2);    // 1008 (+8)
printf("ptr+3: %p\n", ptr+3);    // 1012 (+12)
```

**중요**: `ptr + 1`은 "다음 바이트"가 아니라 "다음 요소"를 의미합니다.

### 배열 표기법과 포인터 표기법의 동등성

```c
int arr[5] = {10, 20, 30, 40, 50};

// 다음은 모두 동일한 의미
arr[i] ≡ *(arr + i) ≡ *(i + arr) ≡ i[arr]

// 실제 사용 예
for (int i = 0; i < 5; i++) {
    printf("arr[%d] = %d\n", i, arr[i]);        // 일반적 방법
    printf("*(arr+%d) = %d\n", i, *(arr + i));   // 포인터 방법
}
```

## 포인터 변수를 이용한 배열 순회

### for문을 이용한 배열 순회

```c
#include <stdio.h>

int main() {
    int numbers[5] = {10, 20, 30, 40, 50};
    int *ptr;

    // 방법 1: 인덱스를 이용한 포인터 접근
    for (int i = 0; i < 5; i++) {
        printf("numbers[%d] = %d\n", i, *(numbers + i));
    }

    // 방법 2: 포인터 이동을 이용한 접근
    printf("\n포인터 이동을 통한 순회:\n");
    for (ptr = numbers; ptr < numbers + 5; ptr++) {
        printf("값: %d, 주소: %p\n", *ptr, ptr);
    }

    return 0;
}
```

### 포인터를 이용한 역순 접근

```c
#include <stdio.h>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int *ptr;

    printf("정순 출력: ");
    for (ptr = arr; ptr < arr + 5; ptr++) {
        printf("%d ", *ptr);
    }

    printf("\n역순 출력: ");
    for (ptr = arr + 4; ptr >= arr; ptr--) {
        printf("%d ", *ptr);
    }
    printf("\n");

    return 0;
}
```

## 배열을 매개변수로 전달하기

### 배열 매개변수의 본질

함수에 배열을 전달할 때, 실제로는 **첫 번째 요소의 주소**가 전달됩니다:

```c
// 다음 세 선언은 모두 동일함
void printArray(int arr[], int size);
void printArray(int *arr, int size);
void printArray(int arr[10], int size);  // 크기는 무시됨
```

### 배열 처리 함수의 예제

```c
#include <stdio.h>

// 배열 출력 함수
void printArray(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);  // 또는 *(arr + i)
    }
    printf("\n");
}

// 배열 합계 계산 함수
int sumArray(int *arr, int size) {
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += *(arr + i);
    }
    return sum;
}

// 배열에서 최댓값 찾기
int findMax(int *arr, int size) {
    int max = *arr;  // 첫 번째 요소로 초기화

    for (int i = 1; i < size; i++) {
        if (*(arr + i) > max) {
            max = *(arr + i);
        }
    }
    return max;
}

int main() {
    int numbers[] = {15, 32, 8, 47, 23, 6, 91, 12};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    printf("배열: ");
    printArray(numbers, size);

    printf("합계: %d\n", sumArray(numbers, size));
    printf("최댓값: %d\n", findMax(numbers, size));

    return 0;
}
```

## 포인터 배열 vs 배열 포인터

### 포인터 배열 (Array of Pointers)

```c
int a = 10, b = 20, c = 30;
int *ptr_array[3];  // 포인터들의 배열

// 각 포인터에 변수의 주소 할당
ptr_array[0] = &a;
ptr_array[1] = &b;
ptr_array[2] = &c;

printf("포인터 배열을 통한 접근:\n");
for (int i = 0; i < 3; i++) {
    printf("ptr_array[%d]가 가리키는 값: %d\n", i, *ptr_array[i]);
}
```

### 배열 포인터 (Pointer to Array)

```c
int arr[3] = {10, 20, 30};
int (*array_ptr)[3] = &arr;  // 배열 전체를 가리키는 포인터

// 배열 포인터를 통한 접근
for (int i = 0; i < 3; i++) {
    printf("(*array_ptr)[%d] = %d\n", i, (*array_ptr)[i]);
}
```

**구분하는 법**:
- `int *ptr[3]`: 포인터 배열 (3개의 int 포인터)
- `int (*ptr)[3]`: 배열 포인터 (3개 int 배열을 가리키는 포인터)

## 동적 배열과 포인터

### malloc을 이용한 동적 배열

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int size;
    int *dynamic_array;

    printf("배열 크기 입력: ");
    scanf("%d", &size);

    // 동적 메모리 할당
    dynamic_array = (int*)malloc(size * sizeof(int));

    if (dynamic_array == NULL) {
        printf("메모리 할당 실패!\n");
        return 1;
    }

    // 배열에 값 입력
    printf("%d개의 정수 입력: ", size);
    for (int i = 0; i < size; i++) {
        scanf("%d", &dynamic_array[i]);
    }

    // 배열 출력
    printf("입력된 배열: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", dynamic_array[i]);
    }
    printf("\n");

    // 메모리 해제
    free(dynamic_array);
    return 0;
}
```

## 다차원 배열과 포인터

### 2차원 배열과 포인터

```c
int arr2D[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// 2차원 배열의 메모리 구조는 1차원으로 연속 배치
// [1][2][3][4][5][6][7][8][9][10][11][12]

// 포인터를 이용한 2차원 배열 접근
int *ptr = (int*)arr2D;  // 1차원 포인터로 캐스팅

for (int i = 0; i < 12; i++) {
    printf("%d ", *(ptr + i));
    if ((i + 1) % 4 == 0) printf("\n");
}
```

### 행 단위 포인터 접근

```c
int arr2D[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};

// 각 행의 시작 주소 출력
for (int i = 0; i < 3; i++) {
    printf("행 %d 주소: %p\n", i, arr2D[i]);

    // 해당 행의 모든 요소 출력
    for (int j = 0; j < 4; j++) {
        printf("%d ", *(arr2D[i] + j));  // arr2D[i][j]와 동일
    }
    printf("\n");
}
```

## 실전 예제

### 예제 1: 배열 내 특정 값 검색

```c
#include <stdio.h>

int* findValue(int *arr, int size, int target) {
    for (int i = 0; i < size; i++) {
        if (*(arr + i) == target) {
            return arr + i;  // 찾은 요소의 주소 반환
        }
    }
    return NULL;  // 찾지 못한 경우
}

int main() {
    int numbers[] = {10, 23, 45, 67, 89, 12, 34};
    int size = sizeof(numbers) / sizeof(numbers[0]);
    int target = 67;

    int *result = findValue(numbers, size, target);

    if (result != NULL) {
        int index = result - numbers;  // 포인터 차이로 인덱스 계산
        printf("값 %d를 인덱스 %d에서 발견 (주소: %p)\n",
               target, index, result);
    } else {
        printf("값 %d를 찾을 수 없습니다.\n", target);
    }

    return 0;
}
```

### 예제 2: 배열 뒤집기 (포인터 활용)

```c
#include <stdio.h>

void reverseArray(int *arr, int size) {
    int *start = arr;           // 시작 포인터
    int *end = arr + size - 1;  // 끝 포인터
    int temp;

    while (start < end) {
        // 두 값 교환
        temp = *start;
        *start = *end;
        *end = temp;

        start++;  // 시작 포인터 오른쪽 이동
        end--;    // 끝 포인터 왼쪽 이동
    }
}

int main() {
    int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    printf("원래 배열: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", numbers[i]);
    }

    reverseArray(numbers, size);

    printf("\n뒤집힌 배열: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");

    return 0;
}
```

### 예제 3: 포인터를 이용한 배열 정렬 (버블 정렬)

```c
#include <stdio.h>

void bubbleSort(int *arr, int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (*(arr + j) > *(arr + j + 1)) {
                // 두 요소 교환
                int temp = *(arr + j);
                *(arr + j) = *(arr + j + 1);
                *(arr + j + 1) = temp;
            }
        }
    }
}

int main() {
    int numbers[] = {64, 34, 25, 12, 22, 11, 90};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    printf("정렬 전: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", numbers[i]);
    }

    bubbleSort(numbers, size);

    printf("\n정렬 후: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");

    return 0;
}
```

## 포인터와 배열의 차이점

### 유사점과 차이점

| 특성 | 배열 | 포인터 |
|------|------|---------|
| 메모리 할당 | 연속적 고정 공간 | 주소값만 저장 |
| 크기 변경 | 불가능 | 가리키는 대상 변경 가능 |
| sizeof 결과 | 전체 배열 크기 | 포인터 자체 크기 |
| 증감 연산 | 불가능 (arr++ 에러) | 가능 (ptr++) |
| 초기화 | 선언 시에만 가능 | 언제든 가능 |

```c
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr;

printf("sizeof(arr): %zu\n", sizeof(arr));   // 20 (5 * 4바이트)
printf("sizeof(ptr): %zu\n", sizeof(ptr));   // 8 (64비트 시스템)

// arr++;  // 컴파일 에러! 배열명은 상수
ptr++;     // 정상 동작
```

## 마무리

포인터와 배열의 관계는 **C언어의 핵심 개념** 중 하나입니다. 이 관계를 정확히 이해하면 메모리 효율적이고 강력한 프로그램을 작성할 수 있습니다.

**핵심 기억사항:**
- 배열명은 첫 번째 요소를 가리키는 포인터 상수
- `arr[i]`와 `*(arr + i)`는 동일한 의미
- 포인터 산술 연산은 자료형 크기 단위로 수행
- 함수에 배열 전달 시 포인터로 전달됨
- 포인터 배열과 배열 포인터는 다른 개념
- 동적 배열 생성과 관리에 포인터 활용

이러한 이해를 바탕으로 다음 단계인 문자열과 포인터의 관계, 그리고 함수 포인터로 나아갈 수 있습니다.