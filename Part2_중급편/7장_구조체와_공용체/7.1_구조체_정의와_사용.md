# 7.1 구조체 정의와 사용 (Structure Definition and Usage)

## 구조체의 철학적 기초: 데이터의 추상화

### 구조체와 객체의 존재론

구조체(Structure)는 **서로 다른 타입의 데이터를 하나의 논리적 단위로 묶는 복합 자료형**입니다. 이는 단순한 문법적 편의가 아니라 **현실 세계의 객체를 프로그래밍 세계로 추상화하는 근본적 메커니즘**입니다.

구조체는 **아리스토텔레스의 실체론(Substance Theory)**과 닮아있습니다:
- **실체(Substance)**: 구조체 그 자체
- **속성(Attributes)**: 구조체의 멤버들
- **본질(Essence)**: 구조체가 나타내는 개념적 정체성

```c
struct Student {
    char name[50];    // 속성: 이름
    int age;          // 속성: 나이
    float gpa;        // 속성: 성적
};
// 실체: 학생이라는 개념적 존재
```

### 집합론적 관점에서의 구조체

구조체는 **데카르트 곱(Cartesian Product)**의 구현입니다. 서로 다른 타입 집합의 곱집합을 메모리에서 표현합니다:

```
Student = String × Integer × Float
struct Student s; // (name, age, gpa) ∈ String × Integer × Float
```

이는 **수학적 구조**를 **프로그래밍 구조**로 번역하는 과정입니다.

## 구조체와 타입 시스템

### 명목적 타이핑과 구조적 타이핑

C언어의 구조체는 **명목적 타이핑(Nominal Typing)**을 따릅니다:

```c
struct Point2D { int x, y; };
struct Vector2D { int x, y; };

struct Point2D p = {1, 2};
struct Vector2D v = {1, 2};
// p = v;  // 컴파일 에러! 구조가 같아도 타입이 다름
```

이는 **타입의 정체성**이 **구조**가 아닌 **이름**에 의해 결정됨을 의미합니다. 같은 구조라도 다른 개념을 나타내면 다른 타입입니다.

### 타입 별명과 의미론

`typedef`를 통한 타입 별명은 **의미론적 명확성**을 제공합니다:

```c
// 구조적으로는 동일하지만 의미적으로 다름
typedef struct { int x, y; } Point;
typedef struct { int width, height; } Size;
typedef struct { int dx, dy; } Offset;
```

이는 **같은 구조, 다른 의미**의 철학적 구현입니다.

## 메모리 레이아웃과 정렬(Alignment)

### 구조체의 물리적 배치

구조체는 **연속된 메모리 블록**에 저장되지만, 멤버들 사이에 **패딩(Padding)**이 삽입될 수 있습니다:

```c
struct Mixed {
    char a;      // 1바이트
    // 3바이트 패딩
    int b;       // 4바이트
    char c;      // 1바이트
    // 3바이트 패딩 (구조체 정렬을 위해)
};
// 총 크기: 12바이트 (논리적 크기 6바이트 + 패딩 6바이트)
```

이는 **효율성과 단순성**의 트레이드오프입니다:
- **효율성**: CPU가 정렬된 데이터에 더 빠르게 접근
- **비용**: 메모리 공간의 낭비

### 패킹과 정렬 제어

```c
// 패킹된 구조체 (컴파일러 확장)
struct __attribute__((packed)) PackedStruct {
    char a;
    int b;
    char c;
};  // 크기: 6바이트 (패딩 없음)
```

이는 **공간 효율성**과 **접근 효율성** 사이의 선택을 프로그래머에게 맡깁니다.

## 구조체 초기화의 의미론

### 초기화와 생성의 철학

구조체 초기화는 **무에서 유로의 창조**입니다:

```c
// 지정 초기화 (C99)
struct Point p = {
    .x = 10,
    .y = 20
};
```

이는 **명시적 의도**를 표현하며, **실수를 방지**하는 안전 장치입니다.

### 복합 리터럴 (Compound Literals)

```c
// 익명 구조체 생성
struct Point *ptr = &(struct Point){.x = 5, .y = 10};
```

이는 **일시적 객체의 생성**을 나타내며, **함수형 프로그래밍의 불변성 개념**과 연결됩니다.

## 구조체와 추상 데이터 타입

### 정보 은닉과 캡슐화

C언어의 구조체는 **불완전한 캡슐화**를 제공합니다:

```c
// 헤더 파일에서 불완전 선언
struct opaqueStruct;  // 구현 숨김

// 소스 파일에서 완전 정의
struct opaqueStruct {
    int private_data;
    char internal_buffer[256];
};
```

이는 **인터페이스와 구현의 분리**라는 소프트웨어 공학의 핵심 원칙을 구현합니다.

### 생성자와 소멸자의 시뮬레이션

```c
typedef struct {
    char *data;
    size_t size;
    size_t capacity;
} String;

// 생성자 시뮬레이션
String* string_create(const char* initial) {
    String *s = malloc(sizeof(String));
    if (s) {
        s->size = strlen(initial);
        s->capacity = s->size + 1;
        s->data = malloc(s->capacity);
        strcpy(s->data, initial);
    }
    return s;
}

// 소멸자 시뮬레이션
void string_destroy(String *s) {
    if (s) {
        free(s->data);
        free(s);
    }
}
```

이는 **자원 관리의 명시화**를 통한 **안전성 확보**입니다.

## 구조체와 객체지향의 시뮬레이션

### 가상 함수 테이블

```c
typedef struct {
    void (*draw)(void *self);
    void (*move)(void *self, int x, int y);
    void (*destroy)(void *self);
} ShapeVTable;

typedef struct {
    ShapeVTable *vtable;
    int x, y;
} Shape;

typedef struct {
    Shape base;    // 상속 시뮬레이션
    int radius;
} Circle;

void circle_draw(void *self) {
    Circle *c = (Circle*)self;
    printf("Drawing circle at (%d, %d) with radius %d\n",
           c->base.x, c->base.y, c->radius);
}

ShapeVTable circle_vtable = {
    .draw = circle_draw,
    .move = shape_move,
    .destroy = circle_destroy
};
```

이는 **다형성과 상속**의 C언어 구현입니다.

## 구조체의 철학적 함의

### 부분과 전체의 관계

구조체는 **메레올로지(Mereology)**, 즉 부분-전체 관계의 철학을 구현합니다:

```c
struct Car {
    struct Engine engine;    // 부분
    struct Wheel wheels[4];  // 부분들
    struct Body body;        // 부분
};
// 전체는 부분들의 단순한 합이 아님
```

**게슈탈트 원리**: 전체는 부분의 합보다 크다는 철학적 통찰을 프로그래밍에서 구현합니다.

### 동일성과 동등성

```c
struct Person p1 = {"Alice", 25};
struct Person p2 = {"Alice", 25};

// 구조적 동등성 (내용이 같음)
if (strcmp(p1.name, p2.name) == 0 && p1.age == p2.age) {
    // 같은 내용
}

// 참조적 동일성 (같은 객체)
if (&p1 == &p2) {  // 항상 false
    // 같은 메모리 위치
}
```

이는 **라이프니츠의 동일자 식별 불가능성 원리**와 **수치적 동일성 vs 질적 동일성**의 구분을 보여줍니다.

## 중첩 구조체와 재귀적 정의

### 자기 참조적 구조

```c
typedef struct Node {
    int data;
    struct Node *next;    // 자기 참조
} Node;
```

이는 **무한 재귀의 가능성**을 **포인터를 통한 간접성**으로 해결합니다. **괴델의 불완전성 정리**에서 나타나는 자기 참조적 구조와 유사합니다.

### 상호 참조적 구조

```c
typedef struct A A;
typedef struct B B;

struct A {
    B *b_ref;
    int a_data;
};

struct B {
    A *a_ref;
    int b_data;
};
```

이는 **순환 종속성**을 **전방 선언**을 통해 해결하는 메커니즘입니다.

## 구조체와 메타프로그래밍

### 런타임 타입 정보

```c
typedef enum {
    TYPE_INT,
    TYPE_FLOAT,
    TYPE_STRING
} DataType;

typedef struct {
    DataType type;
    union {
        int i_val;
        float f_val;
        char *s_val;
    } value;
} Variant;
```

이는 **타입 정보의 런타임 보존**을 통한 **동적 타이핑의 시뮬레이션**입니다.

### 리플렉션의 시뮬레이션

```c
typedef struct {
    char *name;
    size_t offset;
    size_t size;
    DataType type;
} FieldInfo;

FieldInfo person_fields[] = {
    {"name", offsetof(struct Person, name), sizeof(char[50]), TYPE_STRING},
    {"age", offsetof(struct Person, age), sizeof(int), TYPE_INT}
};
```

이는 **메타데이터를 통한 구조체 검사**를 가능하게 합니다.

## 구조체와 함수형 프로그래밍

### 불변 구조체

```c
typedef struct {
    const int x;
    const int y;
} ImmutablePoint;

ImmutablePoint point_move(ImmutablePoint p, int dx, int dy) {
    return (ImmutablePoint){p.x + dx, p.y + dy};  // 새 인스턴스 생성
}
```

이는 **불변성(Immutability)**을 통한 **부작용 없는 프로그래밍**을 지향합니다.

### 모나드 패턴의 시뮬레이션

```c
typedef struct {
    int value;
    int is_valid;
} Maybe;

Maybe maybe_bind(Maybe m, Maybe (*func)(int)) {
    if (m.is_valid) {
        return func(m.value);
    }
    return (Maybe){0, 0};  // Nothing
}
```

이는 **오류 처리**를 **타입 시스템**으로 끌어올리는 함수형 접근입니다.

## 실제 세계 모델링

### 도메인 모델링

```c
// 금융 도메인 모델링
typedef struct {
    char currency[4];    // "USD", "EUR" 등
    long long amount;    // 센트 단위 (소수점 오차 방지)
} Money;

typedef struct {
    char account_number[20];
    Money balance;
    char owner_name[100];
} Account;

typedef struct {
    Account *from;
    Account *to;
    Money amount;
    time_t timestamp;
    char description[200];
} Transaction;
```

이는 **현실 세계의 개념**을 **프로그래밍 구조**로 매핑하는 과정입니다.

### 상태 기계의 구현

```c
typedef enum {
    STATE_IDLE,
    STATE_CONNECTING,
    STATE_CONNECTED,
    STATE_ERROR
} ConnectionState;

typedef struct {
    ConnectionState state;
    int socket_fd;
    char server_address[256];
    time_t last_activity;

    // 상태별 행동
    void (*on_idle)(struct Connection *self);
    void (*on_connecting)(struct Connection *self);
    void (*on_connected)(struct Connection *self);
    void (*on_error)(struct Connection *self);
} Connection;
```

이는 **상태와 행동의 결합**을 통한 **동적 시스템 모델링**입니다.

## 마무리: 구조체의 정수(精髓)

구조체는 **데이터의 추상화**를 넘어서 **현실 세계의 개념화**입니다. 이는 다음을 가능하게 합니다:

1. **개념적 통합**: 관련된 데이터들을 논리적 단위로 묶기
2. **타입 안전성**: 의미적으로 다른 데이터의 혼용 방지
3. **추상화**: 구현 세부사항의 은닉
4. **확장성**: 새로운 속성과 행동의 추가
5. **재사용성**: 동일한 구조의 다중 인스턴스 생성

구조체를 마스터한다는 것은 **프로그래밍이 단순한 계산이 아니라 현실 세계의 모델링**이라는 점을 이해하는 것입니다. 이는 **소프트웨어 설계**의 기초가 되며, **객체지향 프로그래밍**의 철학적 토대를 제공합니다.

구조체는 **플라톤의 이데아**와 **아리스토텔레스의 실체론**을 프로그래밍으로 구현한 것입니다. 개념적 세계의 완벽한 형식을 현실적 메모리의 불완전한 구현으로 번역하는 과정이며, 이를 통해 프로그래머는 **사고하는 도구**를 얻게 됩니다.