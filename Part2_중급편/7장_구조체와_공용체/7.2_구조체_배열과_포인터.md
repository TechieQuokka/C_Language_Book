# 7.2 구조체 배열과 포인터 (Structure Arrays and Pointers)

## 복합 데이터 구조의 메타물리학

### 구조체 배열: 객체들의 집합론

구조체 배열은 **동질적 객체들의 순서가 있는 집합**입니다. 이는 **집합론과 대수학**의 만남을 보여줍니다:

```c
struct Student {
    char name[50];
    int id;
    float gpa;
};

struct Student classroom[30];  // 30명의 학생 객체들
```

이는 다음을 의미합니다:
- **집합의 원소**: 각 구조체 인스턴스는 집합의 원소
- **동질성**: 모든 원소는 같은 타입 (구조체 정의)
- **순서성**: 배열 인덱스를 통한 순서 관계
- **유한성**: 컴파일 시 또는 런타임에 결정된 유한한 크기

### 메모리 공간에서의 객체 배치

구조체 배열은 **메모리의 기하학**을 보여줍니다:

```c
struct Point { int x, y; };
struct Point points[3] = {{1,2}, {3,4}, {5,6}};

// 메모리 레이아웃:
// [1][2][3][4][5][6]
//  point[0] point[1] point[2]
```

이는 **연속성(Continuity)**과 **지역성(Locality)**의 원리를 구현합니다:
- **공간적 지역성**: 관련 객체들이 메모리상에 인접
- **시간적 지역성**: 한 객체에 접근하면 인근 객체에도 접근할 가능성
- **캐시 친화성**: CPU 캐시 라인의 효율적 활용

## 포인터를 통한 구조체 접근

### 간접 참조의 의미론

구조체 포인터는 **객체의 참조(Reference)**를 구현합니다:

```c
struct Student *student_ptr = &classroom[0];

// 두 가지 접근 방식
(*student_ptr).name;    // 역참조 후 멤버 접근
student_ptr->name;      // 화살표 연산자 (syntactic sugar)
```

화살표 연산자(`->`)는 **의미론적 편의성**을 제공합니다. 이는 포인터와 구조체가 얼마나 밀접한 관계인지를 보여줍니다.

### 포인터 산술과 구조체 순회

구조체 포인터에 대한 산술 연산은 **객체 단위의 이동**을 의미합니다:

```c
struct Student *ptr = classroom;

ptr++;        // 다음 학생 객체로 이동
ptr += 5;     // 5번째 학생 객체로 이동
ptr - classroom;  // 첫 번째 학생으로부터의 거리 (객체 개수)
```

이는 **추상화된 거리 개념**입니다. 물리적 바이트가 아닌 **논리적 객체 단위**로 계산됩니다.

## 동적 메모리와 구조체

### 런타임 객체 집합의 생성

동적 할당은 **컴파일 타임 제약**에서 **런타임 자유**로의 해방입니다:

```c
struct Student *students = malloc(n * sizeof(struct Student));
```

이는 다음을 가능하게 합니다:
1. **유연한 크기**: 실행 시점에 필요에 따른 크기 결정
2. **메모리 효율성**: 실제 필요한 만큼만 할당
3. **동적 성장**: 필요에 따른 확장/축소

### 생명주기 관리와 소유권

동적으로 할당된 구조체는 **명시적 생명주기 관리**를 요구합니다:

```c
struct Database {
    struct Record *records;
    size_t count;
    size_t capacity;
};

struct Database* db_create(size_t initial_capacity) {
    struct Database *db = malloc(sizeof(struct Database));
    if (db) {
        db->records = malloc(initial_capacity * sizeof(struct Record));
        db->count = 0;
        db->capacity = initial_capacity;
    }
    return db;  // 소유권 이전
}

void db_destroy(struct Database *db) {
    if (db) {
        free(db->records);  // 내부 자원 해제
        free(db);           // 외부 자원 해제
    }
}
```

이는 **RAII(Resource Acquisition Is Initialization)**의 C언어 시뮬레이션입니다.

## 구조체 포인터의 고급 패턴

### 자기 참조적 구조와 연결 리스트

```c
typedef struct Node {
    int data;
    struct Node *next;    // 자기 참조
} Node;

typedef struct {
    Node *head;
    Node *tail;
    size_t size;
} LinkedList;
```

이는 **무한 재귀의 가능성**을 **포인터의 간접성**으로 해결합니다. **괴델의 불완전성 정리**에서 나타나는 자기 참조적 구조의 프로그래밍 구현입니다.

### 트리 구조의 구현

```c
typedef struct TreeNode {
    int value;
    struct TreeNode *left;
    struct TreeNode *right;
    struct TreeNode *parent;  // 상향 참조
} TreeNode;
```

이는 **계층적 관계**의 메모리 표현입니다. **그래프 이론**의 트리 구조를 포인터 네트워크로 구현합니다.

### 다형성과 상속의 시뮬레이션

```c
// 베이스 클래스
typedef struct {
    int type;  // 런타임 타입 정보
    void (*draw)(void *self);
    void (*destroy)(void *self);
} Shape;

// 파생 클래스
typedef struct {
    Shape base;  // 상속 시뮬레이션
    int radius;
} Circle;

typedef struct {
    Shape base;
    int width, height;
} Rectangle;

void draw_shape(Shape *shape) {
    shape->draw(shape);  // 다형적 호출
}
```

이는 **객체지향의 핵심 개념**을 C언어로 구현한 것입니다.

## 구조체 배열의 알고리즘적 활용

### 검색 알고리즘

```c
struct Student* find_student_by_id(struct Student *students, size_t count, int target_id) {
    // 선형 검색
    for (size_t i = 0; i < count; i++) {
        if (students[i].id == target_id) {
            return &students[i];
        }
    }
    return NULL;  // 찾지 못함
}

// 이진 검색 (정렬된 배열 가정)
struct Student* binary_search_by_id(struct Student *students, size_t count, int target_id) {
    size_t left = 0, right = count - 1;

    while (left <= right) {
        size_t mid = left + (right - left) / 2;

        if (students[mid].id == target_id) {
            return &students[mid];
        } else if (students[mid].id < target_id) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return NULL;
}
```

### 정렬 알고리즘

```c
int compare_students_by_gpa(const void *a, const void *b) {
    const struct Student *s1 = (const struct Student*)a;
    const struct Student *s2 = (const struct Student*)b;

    if (s1->gpa < s2->gpa) return -1;
    if (s1->gpa > s2->gpa) return 1;
    return 0;
}

void sort_students_by_gpa(struct Student *students, size_t count) {
    qsort(students, count, sizeof(struct Student), compare_students_by_gpa);
}
```

이는 **알고리즘의 일반화**를 보여줍니다. 함수 포인터를 통한 **비교 논리의 매개변수화**입니다.

## 메모리 효율성과 캐시 최적화

### 구조체 배열 vs 배열들의 구조체

**AoS (Array of Structures)**:
```c
struct Particle {
    float x, y, z;    // 위치
    float vx, vy, vz; // 속도
};
struct Particle particles[1000];
```

**SoA (Structure of Arrays)**:
```c
struct ParticleSystem {
    float x[1000], y[1000], z[1000];      // 위치 배열들
    float vx[1000], vy[1000], vz[1000];   // 속도 배열들
};
```

**트레이드오프**:
- **AoS**: 객체 단위 접근에 유리, 캐시 지역성 좋음
- **SoA**: 벡터화에 유리, SIMD 연산에 최적화

### 메모리 접근 패턴의 최적화

```c
// 캐시 친화적 순회
void process_students_cache_friendly(struct Student *students, size_t count) {
    // 순차 접근으로 캐시 프리페칭 활용
    for (size_t i = 0; i < count; i++) {
        process_single_student(&students[i]);
    }
}

// 캐시 비친화적 순회 (피해야 할 패턴)
void process_students_cache_unfriendly(struct Student **student_pointers, size_t count) {
    // 포인터들이 무작위 메모리 위치를 가리킬 수 있음
    for (size_t i = 0; i < count; i++) {
        process_single_student(student_pointers[i]);  // 캐시 미스 가능성 높음
    }
}
```

## 구조체 포인터와 함수 설계

### 값 전달 vs 참조 전달

```c
// 값 전달 (복사)
void modify_student_by_value(struct Student student) {
    student.gpa += 0.1;  // 복사본만 변경됨
}

// 참조 전달 (포인터)
void modify_student_by_reference(struct Student *student) {
    student->gpa += 0.1;  // 원본이 변경됨
}

// const 참조 (읽기 전용)
void print_student(const struct Student *student) {
    printf("Name: %s, GPA: %.2f\n", student->name, student->gpa);
    // student->gpa = 4.0;  // 컴파일 에러!
}
```

이는 **의도의 명시화**와 **성능 최적화**를 동시에 달성합니다.

### 함수 체이닝과 플루언트 인터페이스

```c
struct StringBuilder* sb_append(struct StringBuilder *sb, const char *str) {
    // 문자열 추가 로직
    return sb;  // 자기 자신을 반환
}

// 체이닝 사용
sb_append(sb_append(sb_append(sb, "Hello"), " "), "World!");
```

이는 **함수형 프로그래밍의 체이닝 개념**을 명령형 언어에서 구현한 것입니다.

## 구조체 포인터와 다형성

### 가상 함수 테이블을 통한 다형성

```c
typedef struct {
    void (*serialize)(void *self, FILE *output);
    void (*deserialize)(void *self, FILE *input);
    void (*destroy)(void *self);
} SerializableVTable;

typedef struct {
    SerializableVTable *vtable;
    // 공통 데이터
} SerializableBase;

typedef struct {
    SerializableBase base;
    int integer_data;
} SerializableInteger;

void serialize_anything(SerializableBase *obj, FILE *output) {
    obj->vtable->serialize(obj, output);  // 다형적 호출
}
```

### 타입 태깅과 런타임 타입 검사

```c
typedef enum {
    SHAPE_CIRCLE,
    SHAPE_RECTANGLE,
    SHAPE_TRIANGLE
} ShapeType;

typedef struct {
    ShapeType type;
    union {
        struct { int radius; } circle;
        struct { int width, height; } rectangle;
        struct { int base, height; } triangle;
    } data;
} Shape;

double calculate_area(const Shape *shape) {
    switch (shape->type) {
        case SHAPE_CIRCLE:
            return 3.14159 * shape->data.circle.radius * shape->data.circle.radius;
        case SHAPE_RECTANGLE:
            return shape->data.rectangle.width * shape->data.rectangle.height;
        case SHAPE_TRIANGLE:
            return 0.5 * shape->data.triangle.base * shape->data.triangle.height;
        default:
            return 0.0;
    }
}
```

이는 **타입 안전성**과 **런타임 다형성**을 결합한 패턴입니다.

## 복잡한 데이터 구조의 구현

### 해시 테이블

```c
typedef struct HashNode {
    char *key;
    void *value;
    struct HashNode *next;  // 충돌 해결을 위한 체이닝
} HashNode;

typedef struct {
    HashNode **buckets;
    size_t bucket_count;
    size_t size;

    unsigned (*hash_func)(const char *key);
    int (*key_compare)(const char *a, const char *b);
} HashTable;
```

### 그래프 구조

```c
typedef struct GraphNode {
    int id;
    void *data;
    struct GraphEdge *edges;  // 인접 리스트
    struct GraphNode *next;   // 노드 리스트
} GraphNode;

typedef struct GraphEdge {
    GraphNode *target;
    int weight;
    struct GraphEdge *next;
} GraphEdge;

typedef struct {
    GraphNode *nodes;
    size_t node_count;
    int is_directed;
} Graph;
```

## 메모리 풀과 객체 풀

### 효율적인 메모리 관리

```c
typedef struct {
    struct Student *students;
    size_t capacity;
    size_t next_free;
    int *free_list;  // 재사용 가능한 슬롯들
} StudentPool;

StudentPool* pool_create(size_t capacity) {
    StudentPool *pool = malloc(sizeof(StudentPool));
    if (pool) {
        pool->students = malloc(capacity * sizeof(struct Student));
        pool->free_list = malloc(capacity * sizeof(int));
        pool->capacity = capacity;
        pool->next_free = 0;

        // 초기 free_list 설정
        for (size_t i = 0; i < capacity; i++) {
            pool->free_list[i] = i;
        }
    }
    return pool;
}

struct Student* pool_allocate(StudentPool *pool) {
    if (pool->next_free < pool->capacity) {
        int index = pool->free_list[pool->next_free++];
        return &pool->students[index];
    }
    return NULL;  // 풀이 가득 참
}
```

이는 **메모리 단편화 방지**와 **할당 성능 향상**을 달성합니다.

## 마무리: 구조체 배열과 포인터의 정수(精髓)

구조체 배열과 포인터의 조합은 **복잡한 데이터 관계의 메모리 표현**을 가능하게 합니다. 이는 다음을 실현합니다:

1. **관계의 구현**: 객체들 간의 복잡한 관계를 포인터로 표현
2. **효율적 순회**: 연속된 메모리 레이아웃을 통한 캐시 친화적 접근
3. **동적 구조**: 런타임에 크기와 관계가 결정되는 유연한 데이터 구조
4. **추상화**: 물리적 메모리를 논리적 객체 네트워크로 추상화
5. **다형성**: 타입 시스템을 확장한 런타임 다형성

이는 **관계형 데이터베이스의 개념**을 **프로그래밍 메모리**에서 구현한 것입니다. 각 구조체는 **레코드**이고, 포인터는 **관계**이며, 배열은 **테이블**입니다.

구조체 배열과 포인터를 마스터하는 것은 **컴퓨터 과학의 핵심인 데이터 구조**를 이해하는 것이며, **알고리즘과 자료구조의 실제 구현**을 가능하게 합니다. 이는 **메모리라는 1차원 공간**에서 **다차원적 관계**를 표현하는 **추상화의 예술**입니다.