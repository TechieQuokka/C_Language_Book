# 7.3 공용체 (Union)

## 공용체의 존재론적 본질: 메모리 공간의 중첩

### 공용체와 양자역학적 중첩

공용체(Union)는 **같은 메모리 공간을 여러 타입이 공유하는 복합 자료형**입니다. 이는 프로그래밍에서 **양자역학의 중첩 상태**와 유사한 개념을 구현합니다:

```c
union Value {
    int as_int;
    float as_float;
    char as_bytes[4];
};
```

이 선언은 다음을 의미합니다:
- **동일한 메모리 위치**에 서로 다른 타입의 **해석 렌즈**가 존재
- 한 순간에는 **하나의 해석만 유효**하지만, **모든 해석이 가능**
- **관찰자(프로그래머)의 관점**에 따라 같은 데이터가 다르게 해석

### 타입의 다형성과 해석학적 순환

공용체는 **해석학적 순환(Hermeneutic Circle)**의 프로그래밍 구현입니다:

```c
union Number {
    int integer;
    float floating_point;
    unsigned bits;
};

union Number n;
n.floating_point = 3.14f;

printf("As float: %f\n", n.floating_point);    // 3.14
printf("As int: %d\n", n.integer);             // 부정확한 해석
printf("As bits: 0x%x\n", n.bits);             // 비트 패턴으로 해석
```

같은 **존재(메모리 내용)**가 **다른 본질(타입 해석)**을 가질 수 있습니다. 이는 **현상학**에서 말하는 **지향성(Intentionality)**의 개념과 연결됩니다.

## 메모리 공유의 철학

### 공간의 효율성과 의미의 모호성

공용체는 **공간 효율성**과 **의미적 명확성** 사이의 근본적 트레이드오프를 보여줍니다:

**장점**:
- 메모리 사용량 최소화
- 다양한 타입 표현의 유연성
- 하드웨어 레벨 조작 가능

**단점**:
- 타입 안전성 부족
- 데이터 무결성 위험
- 플랫폼 의존적 동작

이는 **최적화와 안전성**의 영원한 딜레마입니다.

### 메모리 정렬과 공용체 크기

공용체의 크기는 **가장 큰 멤버의 크기**로 결정되며, **정렬 요구사항**을 만족해야 합니다:

```c
union Mixed {
    char c;        // 1바이트
    int i;         // 4바이트
    double d;      // 8바이트
};
// sizeof(union Mixed) == 8 (가장 큰 멤버 크기)

union Padded {
    char c;
    struct {
        char pad[7];
        double d;
    } aligned;
};
// 정렬 요구사항에 따른 크기 결정
```

## 공용체의 실용적 활용 패턴

### 변종 타입 (Variant Types)

공용체의 가장 일반적인 활용은 **태그된 공용체(Tagged Union)**입니다:

```c
typedef enum {
    TYPE_INTEGER,
    TYPE_FLOAT,
    TYPE_STRING,
    TYPE_BOOLEAN
} ValueType;

typedef struct {
    ValueType type;    // 타입 태그
    union {
        int i_val;
        float f_val;
        char *s_val;
        int b_val;     // boolean (0 또는 1)
    } data;
} Variant;

void print_variant(const Variant *v) {
    switch (v->type) {
        case TYPE_INTEGER:
            printf("Integer: %d\n", v->data.i_val);
            break;
        case TYPE_FLOAT:
            printf("Float: %f\n", v->data.f_val);
            break;
        case TYPE_STRING:
            printf("String: %s\n", v->data.s_val);
            break;
        case TYPE_BOOLEAN:
            printf("Boolean: %s\n", v->data.b_val ? "true" : "false");
            break;
    }
}
```

이는 **동적 타이핑의 시뮬레이션**이며, **타입 안전성**을 **런타임 검사**로 보장합니다.

### 비트 조작과 엔디안 변환

```c
union ByteConverter {
    uint32_t value;
    struct {
        uint8_t byte0, byte1, byte2, byte3;
    } bytes;
};

uint32_t swap_endian(uint32_t value) {
    union ByteConverter converter;
    converter.value = value;

    uint8_t temp;
    temp = converter.bytes.byte0;
    converter.bytes.byte0 = converter.bytes.byte3;
    converter.bytes.byte3 = temp;

    temp = converter.bytes.byte1;
    converter.bytes.byte1 = converter.bytes.byte2;
    converter.bytes.byte2 = temp;

    return converter.value;
}
```

이는 **하위 레벨 데이터 조작**의 강력한 도구입니다.

## 공용체와 함수형 프로그래밍

### Maybe/Option 타입의 구현

```c
typedef enum {
    MAYBE_NOTHING,
    MAYBE_SOMETHING
} MaybeTag;

typedef struct {
    MaybeTag tag;
    union {
        int nothing;    // 실제로는 사용되지 않음
        int value;      // 실제 값
    } data;
} MaybeInt;

MaybeInt maybe_divide(int a, int b) {
    if (b == 0) {
        return (MaybeInt){MAYBE_NOTHING, {.nothing = 0}};
    } else {
        return (MaybeInt){MAYBE_SOMETHING, {.value = a / b}};
    }
}

void handle_maybe(MaybeInt maybe) {
    switch (maybe.tag) {
        case MAYBE_NOTHING:
            printf("Division by zero!\n");
            break;
        case MAYBE_SOMETHING:
            printf("Result: %d\n", maybe.data.value);
            break;
    }
}
```

이는 **NULL 포인터 예외**를 **타입 시스템**으로 해결하는 함수형 프로그래밍 접근법입니다.

### Either 타입의 구현

```c
typedef enum {
    EITHER_LEFT,
    EITHER_RIGHT
} EitherTag;

typedef struct {
    EitherTag tag;
    union {
        char *error;    // Left: 에러 메시지
        int result;     // Right: 성공 결과
    } data;
} EitherErrorInt;

EitherErrorInt safe_parse_int(const char *str) {
    char *endptr;
    int result = strtol(str, &endptr, 10);

    if (*endptr != '\0') {
        return (EitherErrorInt){
            EITHER_LEFT,
            {.error = "Invalid number format"}
        };
    } else {
        return (EitherErrorInt){
            EITHER_RIGHT,
            {.result = result}
        };
    }
}
```

이는 **예외 처리**를 **값으로 표현**하는 방식입니다.

## 메시지 패싱과 프로토콜 구현

### 네트워크 프로토콜 메시지

```c
typedef enum {
    MSG_CONNECT,
    MSG_DISCONNECT,
    MSG_DATA,
    MSG_HEARTBEAT
} MessageType;

typedef struct {
    MessageType type;
    union {
        struct {
            char username[32];
            char password[32];
        } connect;

        struct {
            char reason[64];
        } disconnect;

        struct {
            size_t length;
            char *payload;
        } data;

        struct {
            time_t timestamp;
        } heartbeat;
    } content;
} NetworkMessage;

void process_message(const NetworkMessage *msg) {
    switch (msg->type) {
        case MSG_CONNECT:
            authenticate_user(msg->content.connect.username,
                            msg->content.connect.password);
            break;
        case MSG_DISCONNECT:
            cleanup_connection(msg->content.disconnect.reason);
            break;
        case MSG_DATA:
            handle_data(msg->content.data.payload,
                       msg->content.data.length);
            break;
        case MSG_HEARTBEAT:
            update_last_seen(msg->content.heartbeat.timestamp);
            break;
    }
}
```

### 상태 기계와 이벤트 시스템

```c
typedef enum {
    EVENT_KEYPRESS,
    EVENT_MOUSECLICK,
    EVENT_TIMER,
    EVENT_NETWORK
} EventType;

typedef struct {
    EventType type;
    union {
        struct {
            int key_code;
            int modifiers;
        } keypress;

        struct {
            int x, y;
            int button;
        } mouseclick;

        struct {
            int timer_id;
            void *user_data;
        } timer;

        struct {
            int socket_fd;
            char buffer[256];
            size_t bytes_received;
        } network;
    } data;
} Event;

void handle_event(const Event *event) {
    switch (event->type) {
        case EVENT_KEYPRESS:
            if (event->data.keypress.key_code == 27) {  // ESC
                exit_application();
            }
            break;
        case EVENT_MOUSECLICK:
            handle_click(event->data.mouseclick.x,
                        event->data.mouseclick.y,
                        event->data.mouseclick.button);
            break;
        case EVENT_TIMER:
            timer_expired(event->data.timer.timer_id,
                         event->data.timer.user_data);
            break;
        case EVENT_NETWORK:
            process_network_data(event->data.network.socket_fd,
                                event->data.network.buffer,
                                event->data.network.bytes_received);
            break;
    }
}
```

## 메모리 해석과 형 변환

### 안전하지 않은 형 변환

```c
union TypePunning {
    float f;
    uint32_t i;
};

uint32_t float_to_bits(float f) {
    union TypePunning pun;
    pun.f = f;
    return pun.i;  // IEEE 754 비트 패턴 획득
}

float bits_to_float(uint32_t bits) {
    union TypePunning pun;
    pun.i = bits;
    return pun.f;
}

// IEEE 754 부동소수점 분석
void analyze_float(float value) {
    uint32_t bits = float_to_bits(value);

    uint32_t sign = (bits >> 31) & 1;
    uint32_t exponent = (bits >> 23) & 0xFF;
    uint32_t mantissa = bits & 0x7FFFFF;

    printf("Float %f:\n", value);
    printf("  Sign: %u\n", sign);
    printf("  Exponent: %u (biased: %d)\n", exponent, (int)exponent - 127);
    printf("  Mantissa: 0x%X\n", mantissa);
}
```

**주의**: 이런 형 변환은 **미정의 동작**을 일으킬 수 있으며, **컴파일러 최적화**에 의해 예상과 다른 결과가 나올 수 있습니다.

## 공용체와 메모리 맵 I/O

### 하드웨어 레지스터 모델링

```c
// 하드웨어 레지스터를 공용체로 모델링
typedef union {
    uint32_t raw;
    struct {
        uint32_t enable : 1;
        uint32_t mode : 3;
        uint32_t priority : 4;
        uint32_t reserved : 24;
    } bits;
} ControlRegister;

void configure_hardware(volatile ControlRegister *reg) {
    // 비트필드를 통한 구조적 접근
    reg->bits.enable = 1;
    reg->bits.mode = 5;
    reg->bits.priority = 2;

    // 또는 raw 값으로 한 번에 설정
    // reg->raw = 0x00000025;
}
```

### 패킷 파싱과 프로토콜 처리

```c
typedef union {
    uint8_t raw[20];  // IP 헤더는 최소 20바이트
    struct {
        uint8_t version_ihl;
        uint8_t type_of_service;
        uint16_t total_length;
        uint16_t identification;
        uint16_t flags_fragment;
        uint8_t time_to_live;
        uint8_t protocol;
        uint16_t header_checksum;
        uint32_t source_address;
        uint32_t destination_address;
    } header;
} IPPacket;

void parse_ip_packet(const uint8_t *data, size_t len) {
    if (len < sizeof(IPPacket)) {
        printf("Packet too short\n");
        return;
    }

    const IPPacket *packet = (const IPPacket*)data;

    printf("IP Version: %d\n", (packet->header.version_ihl >> 4) & 0xF);
    printf("Source: %s\n", inet_ntoa(*(struct in_addr*)&packet->header.source_address));
    printf("Destination: %s\n", inet_ntoa(*(struct in_addr*)&packet->header.destination_address));
}
```

## 공용체의 위험성과 안전한 사용법

### 타입 안전성 부족

```c
union Dangerous {
    int i;
    float f;
    char *p;
};

union Dangerous d;
d.i = 42;
printf("%f\n", d.f);    // 미정의 동작!
printf("%s\n", d.p);    // 매우 위험!
```

### 안전한 공용체 사용 패턴

```c
// 1. 항상 타입 태그와 함께 사용
typedef struct {
    enum { INT_TYPE, FLOAT_TYPE, STRING_TYPE } type;
    union {
        int i;
        float f;
        char *s;
    } value;
} SafeUnion;

// 2. 즉시 사용하고 폐기
void process_data(void *data, DataType type) {
    union {
        int *i_ptr;
        float *f_ptr;
        char **s_ptr;
    } converter;

    converter.i_ptr = data;  // 포인터 형변환용으로만 사용

    switch (type) {
        case INT_TYPE:
            process_int(*converter.i_ptr);
            break;
        case FLOAT_TYPE:
            process_float(*converter.f_ptr);
            break;
        case STRING_TYPE:
            process_string(*converter.s_ptr);
            break;
    }
}
```

## 공용체와 최적화

### 메모리 사용량 최적화

```c
// 큰 구조체들의 공용체
typedef struct {
    int common_field;
    union {
        struct {
            char large_buffer1[1000];
            int extra_data1[100];
        } mode_a;

        struct {
            char large_buffer2[800];
            float extra_data2[200];
        } mode_b;

        struct {
            double large_buffer3[150];
        } mode_c;
    } mode_data;

    enum { MODE_A, MODE_B, MODE_C } current_mode;
} LargeUnion;
```

### 캐시 효율성 고려

```c
// 자주 접근하는 데이터는 공용체 밖에
typedef struct {
    int frequently_used;      // 자주 사용됨
    char cache_friendly[64];  // 캐시 라인 크기 고려

    union {
        char rarely_used_big[1000];  // 거의 사용되지 않는 큰 데이터
        int rarely_used_array[250];
    } optional_data;
} CacheOptimizedUnion;
```

## 마무리: 공용체의 정수(精髓)

공용체는 **메모리 공간의 재해석**이라는 강력한 개념을 구현합니다. 이는 다음을 가능하게 합니다:

1. **공간 효율성**: 여러 타입이 같은 메모리 공간 공유
2. **저수준 조작**: 비트 수준의 데이터 조작
3. **다형성 구현**: 태그된 공용체를 통한 변종 타입
4. **하드웨어 추상화**: 메모리 맵 I/O와 레지스터 모델링
5. **프로토콜 구현**: 메시지 패싱과 상태 기계

공용체는 **양자역학의 중첩 상태**처럼, 하나의 메모리 공간이 **여러 가능성을 동시에 내포**합니다. 이는 **관찰자(프로그래머)의 해석**에 따라 다른 의미를 가지는 **해석학적 구조**입니다.

하지만 공용체는 **타입 안전성을 포기하는 대신 효율성을 얻는 트레이드오프**입니다. 이를 안전하게 사용하려면:

- **항상 타입 태그와 함께 사용**
- **즉시 사용 후 폐기** 패턴 적용
- **플랫폼 의존성** 주의
- **미정의 동작** 방지

공용체를 마스터하는 것은 **메모리의 물리적 현실**과 **타입의 논리적 추상화** 사이의 경계를 이해하는 것입니다. 이는 **시스템 프로그래밍**과 **임베디드 프로그래밍**에서 필수적인 도구이며, **성능 최적화**의 강력한 무기입니다.