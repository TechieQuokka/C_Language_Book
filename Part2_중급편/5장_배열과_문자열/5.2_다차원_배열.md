# 5.2 다차원 배열 (Multidimensional Arrays)

## 다차원 배열의 개념과 본질

### 차원이란 무엇인가?

다차원 배열은 **배열의 배열**입니다. 1차원 배열이 일렬로 늘어선 데이터라면, 다차원 배열은 표나 격자처럼 여러 방향으로 확장된 데이터 구조입니다.

일상생활에서 다차원 구조의 예:
- **2차원**: 바둑판, 체스판, 교실 좌석표, 달력
- **3차원**: 아파트 (동-층-호수), 좌표계 (x-y-z)
- **4차원**: 시간이 추가된 공간 (x-y-z-시간)

### 다차원 배열이 필요한 이유

현실 세계의 많은 데이터는 다차원적 성격을 가집니다:

```c
// 학생 5명의 과목 3개 점수를 저장하려면?
// 1차원으로는 복잡함
int student1_math, student1_english, student1_science;
int student2_math, student2_english, student2_science;
// ...

// 2차원 배열로 간단하게
int scores[5][3];  // 5명의 학생, 3개 과목
```

### 다차원 배열의 핵심 특성

1. **구조적 관계**: 데이터 간의 2차원 이상의 관계 표현
2. **논리적 그룹핑**: 관련 데이터를 논리적으로 그룹화
3. **직관적 접근**: 행과 열 개념으로 직관적 접근
4. **메모리 연속성**: 여전히 메모리상에 연속적으로 배치

## 2차원 배열 - 표와 행렬

### 2차원 배열의 원리

2차원 배열은 **행(row)과 열(column)로 구성된 테이블**입니다. 마치 엑셀 스프레드시트나 수학의 행렬과 같은 구조를 가집니다.

```c
자료형 배열명[행의_수][열의_수];
```

### 2차원 배열의 선언과 초기화

```c
// 기본 선언
int matrix[3][4];  // 3행 4열의 정수 배열

// 선언과 동시에 초기화 (방법 1: 일렬로)
int arr[2][3] = {1, 2, 3, 4, 5, 6};

// 선언과 동시에 초기화 (방법 2: 행별로 구분)
int arr[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};

// 부분 초기화
int arr[3][3] = {
    {1, 2},      // {1, 2, 0}
    {3},         // {3, 0, 0}
                 // {0, 0, 0}
};
```

### 2차원 배열의 시각적 이해

```c
int scores[3][4] = {
    {90, 85, 92, 88},  // 1번 학생의 4과목 점수
    {78, 91, 85, 90},  // 2번 학생의 4과목 점수
    {95, 87, 89, 93}   // 3번 학생의 4과목 점수
};

// 시각적 표현:
//     [0] [1] [2] [3]  (열 인덱스)
// [0]  90  85  92  88
// [1]  78  91  85  90
// [2]  95  87  89  93
// (행 인덱스)
```

### 2차원 배열 요소 접근

```c
int matrix[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// 개별 요소 접근
printf("첫 번째 행, 첫 번째 열: %d\n", matrix[0][0]);  // 1
printf("두 번째 행, 세 번째 열: %d\n", matrix[1][2]);  // 6
printf("세 번째 행, 두 번째 열: %d\n", matrix[2][1]);  // 8

// 요소 변경
matrix[1][1] = 99;  // 두 번째 행, 두 번째 열을 99로 변경
```

## 다차원 배열과 중첩 반복문

### 2차원 배열의 완전 순회

2차원 배열의 모든 요소를 처리하려면 **중첩 반복문**을 사용합니다:

```c
int matrix[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// 모든 요소 출력 (행 우선 순회)
for (int i = 0; i < 3; i++) {        // 행 반복
    for (int j = 0; j < 4; j++) {    // 열 반복
        printf("%3d ", matrix[i][j]);
    }
    printf("\n");
}
```

### 반복문의 의미

- **외부 루프 (i)**: 행(row)을 선택
- **내부 루프 (j)**: 선택된 행에서 열(column)을 순회
- **접근 순서**: [0][0] → [0][1] → [0][2] → ... → [1][0] → [1][1] → ...

### 다양한 순회 패턴

```c
int matrix[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// 행 우선 순회 (일반적)
printf("행 우선 순회: ");
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        printf("%d ", matrix[i][j]);
    }
}

// 열 우선 순회
printf("\n열 우선 순회: ");
for (int j = 0; j < 3; j++) {
    for (int i = 0; i < 3; i++) {
        printf("%d ", matrix[i][j]);
    }
}
```

## 3차원 배열과 고차원 배열

### 3차원 배열의 개념

3차원 배열은 **2차원 배열들의 집합**입니다. 마치 여러 개의 표를 쌓아놓은 것과 같습니다.

```c
int cube[2][3][4];  // 2개의 3×4 행렬

// 시각적 표현:
// 층 0:        층 1:
// [0][1][2][3] [0][1][2][3]
// [0][1][2][3] [0][1][2][3]
// [0][1][2][3] [0][1][2][3]
```

### 3차원 배열의 선언과 초기화

```c
// 선언
int arr[2][2][3];

// 초기화
int cube[2][2][3] = {
    {  // 첫 번째 층 (인덱스 0)
        {1, 2, 3},   // 첫 번째 행
        {4, 5, 6}    // 두 번째 행
    },
    {  // 두 번째 층 (인덱스 1)
        {7, 8, 9},   // 첫 번째 행
        {10, 11, 12} // 두 번째 행
    }
};
```

### 3차원 배열 요소 접근

```c
// 요소 접근: [층][행][열]
printf("첫 번째 층, 첫 번째 행, 첫 번째 열: %d\n", cube[0][0][0]);  // 1
printf("두 번째 층, 두 번째 행, 세 번째 열: %d\n", cube[1][1][2]);  // 12

// 삼중 중첩 반복문으로 모든 요소 출력
for (int k = 0; k < 2; k++) {        // 층
    printf("층 %d:\n", k);
    for (int i = 0; i < 2; i++) {    // 행
        for (int j = 0; j < 3; j++) { // 열
            printf("%3d ", cube[k][i][j]);
        }
        printf("\n");
    }
    printf("\n");
}
```

## 다차원 배열의 메모리 구조

### 메모리상의 선형 배치

다차원 배열도 메모리상에서는 **1차원적으로 연속 배치**됩니다. C언어는 **행 우선 순서(row-major order)**로 저장합니다.

```c
int arr[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};

// 메모리상의 실제 배치:
// 주소: 1000 1004 1008 1012 1016 1020
// 값:    1    2    3    4    5    6
// 논리: [0][0][0][1][0][2][1][0][1][1][1][2]
```

### 인덱스와 메모리 주소의 관계

2차원 배열 `arr[행][열]`에서 `arr[i][j]`의 메모리 위치:
```
실제_주소 = 시작_주소 + (i × 열의_수 + j) × sizeof(자료형)
```

이 공식은 C언어가 다차원 배열의 인덱스를 실제 메모리 주소로 변환하는 방법입니다.

## 실전 예제

### 예제 1: 학생 성적 관리 시스템

```c
#include <stdio.h>

int main() {
    const int STUDENTS = 3;
    const int SUBJECTS = 4;
    int scores[STUDENTS][SUBJECTS];
    char subjects[][10] = {"수학", "영어", "과학", "국어"};

    // 성적 입력
    for (int i = 0; i < STUDENTS; i++) {
        printf("학생 %d의 성적을 입력하세요:\n", i + 1);
        for (int j = 0; j < SUBJECTS; j++) {
            printf("%s: ", subjects[j]);
            scanf("%d", &scores[i][j]);
        }
        printf("\n");
    }

    // 학생별 총점과 평균 계산
    printf("=== 학생별 성적 ===\n");
    for (int i = 0; i < STUDENTS; i++) {
        int total = 0;
        printf("학생 %d: ", i + 1);

        for (int j = 0; j < SUBJECTS; j++) {
            printf("%s:%d ", subjects[j], scores[i][j]);
            total += scores[i][j];
        }

        printf("| 총점:%d, 평균:%.1f\n", total, (double)total / SUBJECTS);
    }

    // 과목별 평균 계산
    printf("\n=== 과목별 평균 ===\n");
    for (int j = 0; j < SUBJECTS; j++) {
        int total = 0;
        for (int i = 0; i < STUDENTS; i++) {
            total += scores[i][j];
        }
        printf("%s: %.1f점\n", subjects[j], (double)total / STUDENTS);
    }

    return 0;
}
```

### 예제 2: 3×3 행렬 연산

```c
#include <stdio.h>

int main() {
    int matrix1[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int matrix2[3][3] = {
        {9, 8, 7},
        {6, 5, 4},
        {3, 2, 1}
    };

    int sum[3][3];

    // 행렬 덧셈
    printf("행렬 1:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%3d ", matrix1[i][j]);
        }
        printf("\n");
    }

    printf("\n행렬 2:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%3d ", matrix2[i][j]);
        }
        printf("\n");
    }

    // 덧셈 수행
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            sum[i][j] = matrix1[i][j] + matrix2[i][j];
        }
    }

    printf("\n행렬 합:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%3d ", sum[i][j]);
        }
        printf("\n");
    }

    return 0;
}
```

### 예제 3: 틱택토 게임판

```c
#include <stdio.h>

int main() {
    char board[3][3] = {
        {' ', ' ', ' '},
        {' ', ' ', ' '},
        {' ', ' ', ' '}
    };

    int row, col;
    char player = 'X';

    printf("틱택토 게임 (3×3 보드)\n");
    printf("위치 입력: 행(0-2) 열(0-2)\n\n");

    // 게임판 표시 함수
    void printBoard() {
        printf("  0 1 2\n");
        for (int i = 0; i < 3; i++) {
            printf("%d ", i);
            for (int j = 0; j < 3; j++) {
                printf("%c", board[i][j]);
                if (j < 2) printf("|");
            }
            printf("\n");
            if (i < 2) printf("  -----\n");
        }
        printf("\n");
    }

    // 초기 게임판 표시
    printBoard();

    // 간단한 게임 진행 (9턴)
    for (int turn = 0; turn < 9; turn++) {
        printf("플레이어 %c의 차례입니다.\n", player);
        printf("행과 열을 입력하세요: ");
        scanf("%d %d", &row, &col);

        // 유효성 검사 (간단화)
        if (row >= 0 && row < 3 && col >= 0 && col < 3 && board[row][col] == ' ') {
            board[row][col] = player;
            printBoard();

            // 플레이어 교체
            player = (player == 'X') ? 'O' : 'X';
        } else {
            printf("잘못된 위치입니다. 다시 시도하세요.\n");
            turn--; // 턴 감소하지 않음
        }
    }

    printf("게임 종료!\n");
    return 0;
}
```

## 다차원 배열 사용 시 주의사항

### 1. 메모리 사용량

다차원 배열은 차원이 증가할수록 메모리 사용량이 기하급수적으로 증가합니다:

```c
int arr1[1000];        // 4KB (1000 × 4바이트)
int arr2[100][100];    // 40KB (10,000 × 4바이트)
int arr3[10][10][100]; // 40KB (10,000 × 4바이트)
int arr4[10][10][10][10]; // 40KB (10,000 × 4바이트)
```

### 2. 초기화 패턴

```c
// 권장: 명확한 초기화
int arr[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};

// 가능하지만 혼란스러울 수 있음
int arr[2][3] = {1, 2, 3, 4, 5, 6};

// 부분 초기화 시 주의
int arr[2][3] = {
    {1, 2},    // {1, 2, 0}
    {3}        // {3, 0, 0}
};
```

### 3. 인덱스 범위 주의

```c
int arr[3][4];

// 올바른 접근
arr[0][0] = 1;   // 첫 번째 행, 첫 번째 열
arr[2][3] = 2;   // 마지막 행, 마지막 열

// 잘못된 접근 (피해야 함)
// arr[3][0] = 3;   // 행 인덱스 초과
// arr[0][4] = 4;   // 열 인덱스 초과
```

## 마무리

다차원 배열은 **복잡한 데이터 구조를 논리적으로 표현하는 강력한 도구**입니다. 2차원 배열을 통해 표 형태의 데이터를, 3차원 이상의 배열을 통해 더 복잡한 관계를 가진 데이터를 효율적으로 관리할 수 있습니다.

**핵심 기억사항:**
- 다차원 배열은 배열의 배열 구조
- 2차원: 행과 열로 구성된 테이블 구조
- 중첩 반복문으로 모든 요소 접근 가능
- 메모리상에는 1차원적으로 연속 배치 (행 우선 순서)
- 차원이 증가할수록 메모리 사용량 급증

다차원 배열을 마스터하면 게임, 이미지 처리, 과학 계산 등 다양한 분야에서 복잡한 데이터를 효과적으로 다룰 수 있습니다.