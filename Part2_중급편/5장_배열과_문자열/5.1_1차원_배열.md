# 5.1 1차원 배열 (One-Dimensional Arrays)

## 배열의 개념과 본질

### 집합이란 무엇인가?

배열은 **같은 종류의 데이터를 순서대로 나열한 자료구조**입니다. 마치 책꽂이에 책들을 일렬로 정렬해 놓은 것처럼, 동일한 타입의 변수들을 메모리 상에 연속적으로 배치한 것입니다.

일상생활에서 우리는 이미 배열의 개념을 자연스럽게 사용하고 있습니다:
- 아파트의 호수: 101호, 102호, 103호...
- 학급의 출석번호: 1번, 2번, 3번...
- 책의 페이지: 1페이지, 2페이지, 3페이지...

### 배열이 필요한 이유

개별 변수로 여러 데이터를 다루는 것의 한계:

```c
// 10명의 학생 점수를 저장하려면?
int score1, score2, score3, score4, score5;
int score6, score7, score8, score9, score10;

// 평균을 구하려면?
int average = (score1 + score2 + score3 + score4 + score5 +
              score6 + score7 + score8 + score9 + score10) / 10;
```

이런 방식은:
- 변수 이름을 일일이 만들어야 함
- 반복문을 사용할 수 없음
- 데이터 개수가 변경되면 코드 전체를 수정해야 함
- 코드가 길어지고 관리가 어려워짐

### 배열의 핵심 특성

1. **동질성**: 모든 요소가 같은 자료형
2. **순서성**: 각 요소는 고유한 순서(인덱스)를 가짐
3. **연속성**: 메모리 상에 연속적으로 배치됨
4. **고정성**: 선언 시 크기가 결정되면 변경 불가

## 배열의 선언과 초기화

### 배열 선언의 원리

배열을 선언한다는 것은 **"같은 타입의 변수 n개를 연속적으로 만들어 달라"**고 컴퓨터에게 요청하는 것입니다.

```c
자료형 배열명[크기];
```

이때 컴퓨터는:
1. 지정된 자료형의 크기 × 배열 크기만큼 메모리 공간을 확보
2. 이 공간을 연속적으로 배치
3. 배열명을 첫 번째 요소의 주소로 설정

### 배열 선언의 다양한 형태

```c
// 기본 선언
int numbers[5];        // 정수 5개를 담을 수 있는 배열

// 선언과 동시에 초기화
int scores[3] = {90, 85, 92};

// 크기 생략 (초기값 개수로 자동 결정)
int grades[] = {95, 87, 91, 88, 93};  // 크기 5로 자동 결정

// 부분 초기화
int values[5] = {1, 2};  // {1, 2, 0, 0, 0}으로 초기화
```

### 배열 초기화의 원리

배열을 초기화할 때 C언어는 다음 규칙을 따릅니다:

1. **완전 초기화**: 모든 요소에 값 제공
2. **부분 초기화**: 일부만 초기화하면 나머지는 0으로 자동 설정
3. **전체 0 초기화**: `{0}`으로 모든 요소를 0으로 초기화 가능

```c
int arr1[5] = {1, 2, 3, 4, 5};  // 완전 초기화
int arr2[5] = {1, 2};           // {1, 2, 0, 0, 0}
int arr3[5] = {0};              // {0, 0, 0, 0, 0}
```

## 배열의 인덱스와 접근

### 인덱스의 개념

배열의 각 요소는 **인덱스(index)**라는 번호로 구분됩니다. 이는 마치 아파트 호수나 좌석 번호와 같은 역할을 합니다.

**중요한 특징:**
- 인덱스는 **0부터 시작**
- 크기가 n인 배열의 인덱스 범위: 0 ~ (n-1)
- 인덱스는 정수형 표현식이어야 함

```c
int numbers[5] = {10, 20, 30, 40, 50};

// 인덱스:  0   1   2   3   4
// 값:     10  20  30  40  50
```

### 배열 요소 접근 방법

```c
int numbers[5] = {10, 20, 30, 40, 50};

// 개별 요소 읽기
printf("첫 번째 요소: %d\n", numbers[0]);    // 10
printf("세 번째 요소: %d\n", numbers[2]);    // 30

// 개별 요소 변경
numbers[1] = 25;  // 두 번째 요소를 25로 변경
numbers[4] = 55;  // 다섯 번째 요소를 55로 변경
```

### 인덱스 사용 시 주의사항

배열의 **경계를 벗어난 접근**은 심각한 오류를 일으킵니다:

```c
int arr[5] = {1, 2, 3, 4, 5};

// 위험한 접근 (컴파일러가 잡지 못할 수 있음)
arr[5] = 100;   // 인덱스 5는 존재하지 않음!
arr[-1] = 200;  // 음수 인덱스 사용 불가!

// C언어는 이런 오류를 런타임에 검사하지 않으므로
// 프로그래머가 직접 주의해야 함
```

## 배열과 반복문

### 배열과 반복문의 완벽한 조합

배열의 진정한 힘은 **반복문과 결합될 때** 발휘됩니다. 인덱스가 규칙적으로 증가하는 특성을 활용하면 모든 요소를 효율적으로 처리할 수 있습니다.

```c
int scores[5] = {90, 85, 92, 78, 96};

// 모든 점수 출력
for (int i = 0; i < 5; i++) {
    printf("학생 %d: %d점\n", i+1, scores[i]);
}

// 총합과 평균 계산
int sum = 0;
for (int i = 0; i < 5; i++) {
    sum += scores[i];
}
double average = (double)sum / 5;
printf("평균: %.1f점\n", average);
```

### 배열 크기를 활용한 안전한 반복

```c
#define ARRAY_SIZE 5
int numbers[ARRAY_SIZE] = {1, 2, 3, 4, 5};

// 매크로를 사용한 안전한 반복
for (int i = 0; i < ARRAY_SIZE; i++) {
    printf("%d ", numbers[i]);
}

// 또는 sizeof를 활용
int count = sizeof(numbers) / sizeof(numbers[0]);
for (int i = 0; i < count; i++) {
    printf("%d ", numbers[i]);
}
```

## 배열의 메모리 구조

### 메모리상의 배열 배치

배열은 메모리에서 **연속적으로 배치**됩니다. 이는 배열이 빠른 이유이자 중요한 특성입니다.

```c
int arr[4] = {10, 20, 30, 40};

// 메모리 구조 (예시)
// 주소:   1000  1004  1008  1012
// 값:     10    20    30    40
// 인덱스: [0]   [1]   [2]   [3]
```

### 배열명의 의미

배열명은 **첫 번째 요소의 주소**를 나타냅니다:

```c
int numbers[5] = {1, 2, 3, 4, 5};

printf("배열명: %p\n", numbers);        // 첫 번째 요소의 주소
printf("첫 요소: %p\n", &numbers[0]);   // 첫 번째 요소의 주소 (같음)
printf("두 요소: %p\n", &numbers[1]);   // 두 번째 요소의 주소
```

## 실전 예제

### 예제 1: 점수 관리 시스템

```c
#include <stdio.h>

int main() {
    const int STUDENT_COUNT = 5;
    int scores[STUDENT_COUNT];
    int sum = 0;
    int max_score, min_score;

    // 점수 입력
    printf("5명의 학생 점수를 입력하세요:\n");
    for (int i = 0; i < STUDENT_COUNT; i++) {
        printf("학생 %d: ", i + 1);
        scanf("%d", &scores[i]);
    }

    // 최대값, 최소값, 합계 계산
    max_score = min_score = scores[0];

    for (int i = 0; i < STUDENT_COUNT; i++) {
        sum += scores[i];

        if (scores[i] > max_score) {
            max_score = scores[i];
        }
        if (scores[i] < min_score) {
            min_score = scores[i];
        }
    }

    // 결과 출력
    printf("\n=== 결과 ===\n");
    printf("총합: %d\n", sum);
    printf("평균: %.1f\n", (double)sum / STUDENT_COUNT);
    printf("최고점: %d\n", max_score);
    printf("최저점: %d\n", min_score);

    return 0;
}
```

### 예제 2: 숫자 뒤집기

```c
#include <stdio.h>

int main() {
    int numbers[5] = {1, 2, 3, 4, 5};
    int temp;

    printf("원래 배열: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", numbers[i]);
    }

    // 배열 뒤집기
    for (int i = 0; i < 5 / 2; i++) {
        temp = numbers[i];
        numbers[i] = numbers[4 - i];
        numbers[4 - i] = temp;
    }

    printf("\n뒤집은 배열: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");

    return 0;
}
```

### 예제 3: 숫자 찾기와 개수 세기

```c
#include <stdio.h>

int main() {
    int numbers[] = {3, 7, 2, 7, 1, 7, 4, 7, 9};
    int size = sizeof(numbers) / sizeof(numbers[0]);
    int target = 7;
    int count = 0;

    printf("배열: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", numbers[i]);
    }

    // 특정 숫자 개수 세기
    for (int i = 0; i < size; i++) {
        if (numbers[i] == target) {
            count++;
            printf("\n인덱스 %d에서 %d 발견!", i, target);
        }
    }

    printf("\n\n숫자 %d가 %d번 나타납니다.\n", target, count);

    return 0;
}
```

## 배열 사용 시 주의사항

### 1. 경계 검사

```c
int arr[5];

// 안전한 접근
for (int i = 0; i < 5; i++) {
    arr[i] = i * 10;
}

// 위험한 접근 (피해야 함)
// arr[5] = 100;  // 인덱스 초과
// arr[-1] = 200; // 음수 인덱스
```

### 2. 초기화의 중요성

```c
int arr1[5];           // 쓰레기 값으로 초기화됨
int arr2[5] = {0};     // 모든 요소가 0으로 초기화됨

// arr1은 반드시 초기화 후 사용
for (int i = 0; i < 5; i++) {
    arr1[i] = 0;  // 명시적 초기화
}
```

### 3. 크기와 인덱스의 관계

```c
int arr[5];  // 인덱스 범위: 0, 1, 2, 3, 4

// 마지막 요소 접근
arr[4] = 100;        // 올바름
// arr[5] = 200;     // 잘못됨! (크기는 5이지만 마지막 인덱스는 4)
```

## 마무리

1차원 배열은 **연관된 데이터들을 체계적으로 관리하는 가장 기본적인 자료구조**입니다. 배열의 핵심은 같은 타입의 데이터를 순서대로 배열하여 인덱스로 접근할 수 있게 하는 것입니다.

**핵심 기억사항:**
- 배열은 같은 타입 데이터의 연속적 집합
- 인덱스는 0부터 시작하며 (크기-1)까지 사용 가능
- 반복문과의 조합으로 강력한 데이터 처리 가능
- 메모리상에 연속적으로 배치되어 효율적
- 경계 검사는 프로그래머의 책임

배열을 마스터하면 대량의 데이터를 효율적으로 처리할 수 있는 기반을 마련하게 됩니다.