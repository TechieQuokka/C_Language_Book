# 5.3 문자열과 문자 배열 (Strings and Character Arrays)

## 문자열의 개념과 본질

### 문자열이란 무엇인가?

문자열(String)은 **문자들이 순서대로 연결된 데이터**입니다. 우리가 일상적으로 사용하는 단어, 문장, 이름, 주소 등은 모두 문자열입니다. 프로그래밍에서 텍스트 데이터를 다루는 것은 매우 중요하며, C언어는 이를 문자 배열로 구현합니다.

일상생활의 문자열 예:
- 이름: "김철수", "Jane Smith"
- 주소: "서울시 강남구 역삼동"
- 메시지: "Hello, World!"
- 명령어: "save file.txt"

### C언어에서 문자열의 특별함

C언어에는 다른 언어들과 달리 **문자열 타입이 별도로 존재하지 않습니다**. 대신 **문자 배열을 사용하여 문자열을 구현**합니다. 이는 C언어의 단순함과 효율성을 보여주는 특징이기도 합니다.

```c
// C언어에서는 이런 문자열 타입이 없음
// string name = "김철수";  // 다른 언어의 예

// C언어에서는 문자 배열로 구현
char name[] = "김철수";     // 문자 배열
```

### 문자와 문자열의 구분

```c
char single_char = 'A';      // 단일 문자 (작은따옴표)
char string[] = "Apple";     // 문자열 (큰따옴표)
```

**중요한 차이점:**
- **문자**: 하나의 글자, 작은따옴표 사용, 1바이트
- **문자열**: 문자들의 집합, 큰따옴표 사용, 여러 바이트

## 문자 배열 vs 문자열

### 문자 배열의 기본 개념

문자 배열은 **char 타입의 배열**입니다. 문자들을 순서대로 저장할 수 있지만, 그 자체로는 문자열이 아닙니다.

```c
// 단순한 문자 배열
char chars[5] = {'H', 'e', 'l', 'l', 'o'};

// 메모리 구조:
// [0] [1] [2] [3] [4]
//  H   e   l   l   o
```

### 문자열이 되기 위한 조건

문자 배열이 문자열이 되려면 **널 종료자(null terminator) '\0'**가 필요합니다. 이는 "문자열이 여기서 끝난다"를 알려주는 특별한 문자입니다.

```c
// 진정한 문자열
char string[6] = {'H', 'e', 'l', 'l', 'o', '\0'};

// 메모리 구조:
// [0] [1] [2] [3] [4] [5]
//  H   e   l   l   o  \0
```

### 널 종료자의 중요성

널 종료자는 **문자열의 끝을 표시하는 중요한 역할**을 합니다:

```c
char str1[10] = "Hello";  // 자동으로 '\0' 추가됨
char str2[10] = {'H', 'e', 'l', 'l', 'o'};  // '\0' 없음!

printf("%s\n", str1);  // "Hello" 정상 출력
printf("%s\n", str2);  // 예측 불가능한 결과 (쓰레기 값까지 출력 가능)
```

**왜 이런 차이가 발생하는가?**
- `printf("%s")`는 '\0'을 만날 때까지 계속 문자를 읽음
- '\0'이 없으면 메모리의 쓰레기 값까지 계속 읽어버림

## 문자열의 선언과 초기화

### 문자열 리터럴을 사용한 초기화

```c
// 방법 1: 문자열 리터럴 (가장 일반적)
char greeting[] = "Hello";  // 크기 자동 결정 (6개: H,e,l,l,o,\0)
char name[20] = "김철수";   // 20개 공간 중 일부만 사용

// 방법 2: 개별 문자로 초기화
char word[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

### 초기화 시 메모리 구조

```c
char str1[] = "Hello";
// 메모리: [H][e][l][l][o][\0] (총 6바이트)

char str2[10] = "Hi";
// 메모리: [H][i][\0][0][0][0][0][0][0][0] (총 10바이트)
```

### 문자열 초기화 시 주의사항

```c
char str[5] = "Hello";  // 위험! '\0' 들어갈 공간 없음
char str[6] = "Hello";  // 안전! '\0' 포함하여 정확한 크기

// 배열 크기 생략이 가장 안전
char str[] = "Hello";   // 컴파일러가 자동으로 올바른 크기 계산
```

## 문자열 입출력

### 문자열 출력

```c
char message[] = "Hello, World!";

// 방법 1: printf의 %s 지정자
printf("%s\n", message);

// 방법 2: puts 함수 (자동으로 줄바꿈 추가)
puts(message);

// 방법 3: 개별 문자 출력
for (int i = 0; message[i] != '\0'; i++) {
    printf("%c", message[i]);
}
```

### 문자열 입력

```c
char input[100];

// 방법 1: scanf (공백으로 구분, 한 단어만 입력 가능)
printf("이름을 입력하세요: ");
scanf("%s", input);  // 주의: &가 필요 없음!

// 방법 2: gets (위험한 함수, 사용 권장 안 함)
// gets(input);

// 방법 3: fgets (안전한 방법, 권장)
printf("문장을 입력하세요: ");
fgets(input, sizeof(input), stdin);
```

### scanf vs fgets 비교

```c
char name[20];

// scanf: 공백을 만나면 입력 중단
scanf("%s", name);
// 입력: "Kim Chul Su" → name에는 "Kim"만 저장됨

// fgets: 줄바꿈까지 모든 문자 입력 가능
fgets(name, sizeof(name), stdin);
// 입력: "Kim Chul Su" → name에는 "Kim Chul Su\n"이 저장됨
```

## 문자열 조작과 처리

### 문자열 길이 구하기

```c
// 방법 1: strlen() 함수 사용 (string.h 필요)
#include <string.h>
char text[] = "Hello";
int length = strlen(text);  // 5 (널 종료자 제외)

// 방법 2: 직접 구현
int getLength(char str[]) {
    int count = 0;
    while (str[count] != '\0') {
        count++;
    }
    return count;
}
```

### 문자열 복사

```c
#include <string.h>

char source[] = "Original";
char destination[20];

// 방법 1: strcpy() 함수 사용
strcpy(destination, source);

// 방법 2: 직접 구현
void copyString(char dest[], char src[]) {
    int i = 0;
    while (src[i] != '\0') {
        dest[i] = src[i];
        i++;
    }
    dest[i] = '\0';  // 널 종료자 추가 중요!
}
```

### 문자열 연결

```c
#include <string.h>

char str1[20] = "Hello ";
char str2[] = "World";

// strcat() 함수 사용
strcat(str1, str2);  // str1이 "Hello World"가 됨
printf("%s\n", str1);
```

### 문자열 비교

```c
#include <string.h>

char str1[] = "Apple";
char str2[] = "Banana";
char str3[] = "Apple";

// strcmp() 함수 사용
int result1 = strcmp(str1, str2);  // 음수 (Apple < Banana)
int result2 = strcmp(str1, str3);  // 0 (같음)
int result3 = strcmp(str2, str1);  // 양수 (Banana > Apple)

// 직접 비교 (잘못된 방법)
// if (str1 == str3)  // 주소를 비교하므로 항상 거짓!
```

## 실전 예제

### 예제 1: 문자열 분석 프로그램

```c
#include <stdio.h>
#include <string.h>

int main() {
    char text[100];
    int letters = 0, digits = 0, spaces = 0, others = 0;

    printf("문장을 입력하세요: ");
    fgets(text, sizeof(text), stdin);

    printf("입력된 문장: %s", text);
    printf("문자 분석 결과:\n");

    for (int i = 0; text[i] != '\0'; i++) {
        if (text[i] >= 'A' && text[i] <= 'Z' ||
            text[i] >= 'a' && text[i] <= 'z') {
            letters++;
        } else if (text[i] >= '0' && text[i] <= '9') {
            digits++;
        } else if (text[i] == ' ') {
            spaces++;
        } else if (text[i] != '\n') {  // 줄바꿈 문자 제외
            others++;
        }
    }

    printf("영문자: %d개\n", letters);
    printf("숫자: %d개\n", digits);
    printf("공백: %d개\n", spaces);
    printf("기타: %d개\n", others);
    printf("총 길이: %d글자\n", (int)strlen(text) - 1);  // \n 제외

    return 0;
}
```

### 예제 2: 문자열 뒤집기

```c
#include <stdio.h>
#include <string.h>

int main() {
    char original[100];
    char reversed[100];
    int length;

    printf("문자열을 입력하세요: ");
    scanf("%s", original);

    length = strlen(original);

    // 문자열 뒤집기
    for (int i = 0; i < length; i++) {
        reversed[i] = original[length - 1 - i];
    }
    reversed[length] = '\0';  // 널 종료자 추가

    printf("원래 문자열: %s\n", original);
    printf("뒤집은 문자열: %s\n", reversed);

    // 회문(팰린드롬) 검사
    if (strcmp(original, reversed) == 0) {
        printf("이 문자열은 회문입니다!\n");
    } else {
        printf("이 문자열은 회문이 아닙니다.\n");
    }

    return 0;
}
```

### 예제 3: 단어 개수 세기

```c
#include <stdio.h>

int main() {
    char sentence[200];
    int word_count = 0;
    int in_word = 0;  // 단어 안에 있는지 플래그

    printf("문장을 입력하세요: ");
    fgets(sentence, sizeof(sentence), stdin);

    printf("입력된 문장: %s", sentence);

    for (int i = 0; sentence[i] != '\0'; i++) {
        if (sentence[i] != ' ' && sentence[i] != '\t' &&
            sentence[i] != '\n' && sentence[i] != '\r') {
            // 공백이 아닌 문자 발견
            if (!in_word) {
                word_count++;  // 새로운 단어 시작
                in_word = 1;
            }
        } else {
            // 공백 문자 발견
            in_word = 0;  // 단어 끝
        }
    }

    printf("단어 개수: %d개\n", word_count);
    return 0;
}
```

### 예제 4: 간단한 암호화

```c
#include <stdio.h>

int main() {
    char message[100];
    char encrypted[100];
    int shift = 3;  // 시저 암호 (3글자씩 이동)

    printf("암호화할 메시지를 입력하세요: ");
    fgets(message, sizeof(message), stdin);

    printf("원본 메시지: %s", message);

    // 시저 암호 적용
    for (int i = 0; message[i] != '\0'; i++) {
        if (message[i] >= 'A' && message[i] <= 'Z') {
            // 대문자 처리
            encrypted[i] = ((message[i] - 'A' + shift) % 26) + 'A';
        } else if (message[i] >= 'a' && message[i] <= 'z') {
            // 소문자 처리
            encrypted[i] = ((message[i] - 'a' + shift) % 26) + 'a';
        } else {
            // 영문자가 아닌 경우 그대로 복사
            encrypted[i] = message[i];
        }
    }
    encrypted[strlen(message)] = '\0';  // 널 종료자 추가

    printf("암호화된 메시지: %s", encrypted);

    return 0;
}
```

## 문자열 사용 시 주의사항

### 1. 배열 크기와 널 종료자

```c
char str[5] = "Hello";  // 위험! '\0' 공간 없음
char str[6] = "Hello";  // 안전! '\0' 포함

// 가장 안전한 방법
char str[] = "Hello";   // 컴파일러가 자동으로 크기 결정
```

### 2. 문자열 입력 시 버퍼 오버플로우 방지

```c
char name[20];

// 위험한 방법
// gets(name);  // 버퍼 오버플로우 가능

// 안전한 방법
fgets(name, sizeof(name), stdin);
```

### 3. 문자열 비교 시 주의

```c
char str1[] = "Hello";
char str2[] = "Hello";

// 잘못된 비교 (주소를 비교)
if (str1 == str2) { /* 항상 거짓 */ }

// 올바른 비교 (내용을 비교)
if (strcmp(str1, str2) == 0) { /* 올바른 결과 */ }
```

### 4. scanf의 한계 이해

```c
char fullname[50];

// scanf는 공백을 만나면 중단
scanf("%s", fullname);
// 입력: "Kim Chul Su" → "Kim"만 저장

// 공백 포함 입력을 원할 때
fgets(fullname, sizeof(fullname), stdin);
```

## 마무리

문자열과 문자 배열은 **텍스트 데이터를 다루는 핵심 도구**입니다. C언어에서 문자열은 널 종료자를 가진 문자 배열로 구현되며, 이를 이해하는 것은 안전하고 효율적인 문자열 처리의 기초가 됩니다.

**핵심 기억사항:**
- 문자열 = 문자 배열 + 널 종료자 '\0'
- 문자('A')와 문자열("A")은 다름
- scanf는 공백 처리 한계, fgets가 더 안전
- 문자열 비교는 반드시 strcmp() 사용
- 버퍼 오버플로우 방지를 위한 크기 관리 중요

문자열을 마스터하면 사용자 인터페이스, 파일 처리, 데이터 파싱 등 다양한 프로그래밍 영역에서 텍스트를 자유자재로 다룰 수 있게 됩니다.