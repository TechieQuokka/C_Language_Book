# 5.4 문자열 처리 함수 (String Processing Functions)

## 문자열 함수의 개념과 필요성

### 왜 문자열 함수가 필요한가?

문자열은 프로그래밍에서 매우 자주 사용되는 데이터 타입입니다. 매번 문자열을 복사하거나, 길이를 구하거나, 비교하는 코드를 직접 작성하는 것은 비효율적이고 오류가 발생하기 쉽습니다.

C언어는 **표준 라이브러리(string.h)**에서 문자열 처리를 위한 다양한 함수들을 제공합니다. 이 함수들은 수십 년간 검증된 안전하고 효율적인 구현으로, 프로그래머의 생산성을 크게 향상시킵니다.

### 문자열 함수의 특징

1. **널 종료자 의존성**: 모든 문자열 함수는 '\0'에 의존하여 문자열의 끝을 판단
2. **포인터 기반**: 문자열을 포인터로 전달받아 처리
3. **메모리 안전성**: 대부분의 함수는 대상 버퍼의 크기를 확인하지 않음 (주의 필요)
4. **표준화**: ANSI C 표준에 따라 모든 컴파일러에서 동일하게 작동

### string.h 헤더 파일

문자열 함수를 사용하려면 반드시 `string.h` 헤더 파일을 포함해야 합니다:

```c
#include <string.h>  // 문자열 함수 사용을 위해 필수
```

## 문자열 길이 함수 - strlen()

### strlen()의 원리

`strlen()` 함수는 **문자열의 길이를 반환**합니다. 널 종료자('\0')를 만날 때까지 문자를 세어 그 개수를 반환합니다.

```c
size_t strlen(const char *str);
```

**동작 원리:**
1. 문자열의 첫 번째 문자부터 시작
2. 각 문자를 하나씩 검사
3. '\0'을 만나면 지금까지 센 개수 반환
4. 널 종료자는 길이에 포함되지 않음

### strlen() 사용 예제

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str1[] = "Hello";
    char str2[] = "안녕하세요";
    char str3[10] = "Hi";

    printf("'%s'의 길이: %zu\n", str1, strlen(str1));    // 5
    printf("'%s'의 길이: %zu\n", str2, strlen(str2));    // 10 (UTF-8에서 한글은 3바이트씩)
    printf("'%s'의 길이: %zu\n", str3, strlen(str3));    // 2

    // 빈 문자열
    char empty[] = "";
    printf("빈 문자열의 길이: %zu\n", strlen(empty));     // 0

    return 0;
}
```

### strlen() 직접 구현해보기

```c
size_t my_strlen(const char *str) {
    size_t count = 0;
    while (str[count] != '\0') {
        count++;
    }
    return count;
}
```

## 문자열 복사 함수 - strcpy(), strncpy()

### strcpy()의 원리

`strcpy()` 함수는 **원본 문자열을 대상 문자열에 복사**합니다. 널 종료자까지 포함하여 모든 문자를 복사합니다.

```c
char *strcpy(char *dest, const char *src);
```

**동작 과정:**
1. src의 문자를 하나씩 dest에 복사
2. '\0'을 만날 때까지 계속
3. 마지막에 '\0'도 복사
4. dest의 주소를 반환

### strcpy() 사용 예제

```c
#include <stdio.h>
#include <string.h>

int main() {
    char source[] = "Hello World";
    char destination[20];  // 충분한 크기 확보

    strcpy(destination, source);

    printf("원본: %s\n", source);
    printf("복사본: %s\n", destination);

    // 문자열 리터럴도 복사 가능
    strcpy(destination, "New Message");
    printf("변경된 복사본: %s\n", destination);

    return 0;
}
```

### strncpy() - 안전한 복사

`strncpy()`는 **최대 n개의 문자만 복사**하는 더 안전한 버전입니다:

```c
char *strncpy(char *dest, const char *src, size_t n);
```

```c
#include <stdio.h>
#include <string.h>

int main() {
    char source[] = "Hello World";
    char destination[10];

    strncpy(destination, source, 9);
    destination[9] = '\0';  // 수동으로 널 종료자 추가 필요!

    printf("제한된 복사: %s\n", destination);  // "Hello Wor"

    return 0;
}
```

### 복사 함수 직접 구현해보기

```c
char *my_strcpy(char *dest, const char *src) {
    char *original_dest = dest;

    while (*src != '\0') {
        *dest = *src;
        dest++;
        src++;
    }
    *dest = '\0';  // 널 종료자 복사

    return original_dest;
}
```

## 문자열 연결 함수 - strcat(), strncat()

### strcat()의 원리

`strcat()` 함수는 **두 문자열을 연결**합니다. 첫 번째 문자열의 끝에 두 번째 문자열을 붙입니다.

```c
char *strcat(char *dest, const char *src);
```

**동작 과정:**
1. dest에서 '\0'의 위치를 찾음
2. 그 위치부터 src의 문자들을 하나씩 복사
3. src의 '\0'까지 복사 완료
4. dest의 주소를 반환

### strcat() 사용 예제

```c
#include <stdio.h>
#include <string.h>

int main() {
    char greeting[50] = "Hello";  // 충분한 공간 필요
    char target[] = " World";

    printf("연결 전: '%s'\n", greeting);

    strcat(greeting, target);
    printf("연결 후: '%s'\n", greeting);  // "Hello World"

    strcat(greeting, "!");
    printf("추가 연결: '%s'\n", greeting);  // "Hello World!"

    return 0;
}
```

### strncat() - 안전한 연결

`strncat()`는 **최대 n개의 문자만 연결**하는 더 안전한 버전입니다:

```c
#include <stdio.h>
#include <string.h>

int main() {
    char result[20] = "Hello";
    char addition[] = " Beautiful World";

    strncat(result, addition, 10);  // 최대 10글자만 추가
    printf("제한된 연결: %s\n", result);  // "Hello Beau"

    return 0;
}
```

## 문자열 비교 함수 - strcmp(), strncmp()

### strcmp()의 원리

`strcmp()` 함수는 **두 문자열을 사전식으로 비교**합니다. ASCII 값을 기준으로 문자 단위로 비교합니다.

```c
int strcmp(const char *str1, const char *str2);
```

**반환값:**
- **0**: 두 문자열이 동일
- **음수**: str1이 str2보다 사전적으로 앞섰음
- **양수**: str1이 str2보다 사전적으로 뒤에 있음

### strcmp() 사용 예제

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str1[] = "Apple";
    char str2[] = "Banana";
    char str3[] = "Apple";

    int result1 = strcmp(str1, str2);
    int result2 = strcmp(str1, str3);
    int result3 = strcmp(str2, str1);

    printf("'%s'와 '%s' 비교: %d\n", str1, str2, result1);  // 음수
    printf("'%s'와 '%s' 비교: %d\n", str1, str3, result2);  // 0
    printf("'%s'와 '%s' 비교: %d\n", str2, str1, result3);  // 양수

    // 조건문에서 활용
    if (strcmp(str1, str3) == 0) {
        printf("str1과 str3는 같습니다.\n");
    }

    if (strcmp(str1, str2) < 0) {
        printf("'%s'가 '%s'보다 사전적으로 앞섭니다.\n", str1, str2);
    }

    return 0;
}
```

### 비교 함수 직접 구현해보기

```c
int my_strcmp(const char *str1, const char *str2) {
    while (*str1 != '\0' && *str2 != '\0') {
        if (*str1 != *str2) {
            return *str1 - *str2;
        }
        str1++;
        str2++;
    }
    return *str1 - *str2;  // 길이가 다른 경우 처리
}
```

## 문자열 검색 함수 - strchr(), strstr()

### strchr() - 문자 찾기

`strchr()` 함수는 **문자열에서 특정 문자를 찾아 그 위치를 반환**합니다:

```c
char *strchr(const char *str, int ch);
```

```c
#include <stdio.h>
#include <string.h>

int main() {
    char text[] = "Hello World";
    char *position;

    position = strchr(text, 'o');
    if (position != NULL) {
        printf("첫 번째 'o'의 위치: %ld\n", position - text);  // 4
        printf("'o'부터의 문자열: %s\n", position);  // "o World"
    }

    position = strchr(text, 'z');
    if (position == NULL) {
        printf("'z'를 찾을 수 없습니다.\n");
    }

    return 0;
}
```

### strstr() - 부분 문자열 찾기

`strstr()` 함수는 **문자열에서 부분 문자열을 찾아 그 위치를 반환**합니다:

```c
char *strstr(const char *haystack, const char *needle);
```

```c
#include <stdio.h>
#include <string.h>

int main() {
    char text[] = "The quick brown fox jumps";
    char *position;

    position = strstr(text, "quick");
    if (position != NULL) {
        printf("'quick'을 찾았습니다: %s\n", position);
        printf("위치: %ld\n", position - text);  // 4
    }

    position = strstr(text, "slow");
    if (position == NULL) {
        printf("'slow'를 찾을 수 없습니다.\n");
    }

    return 0;
}
```

## 기타 유용한 문자열 함수들

### strcspn() - 문자 집합까지의 길이

```c
#include <stdio.h>
#include <string.h>

int main() {
    char text[] = "Hello123World";

    size_t length = strcspn(text, "0123456789");
    printf("숫자가 나오기 전까지의 길이: %zu\n", length);  // 5

    return 0;
}
```

### strtok() - 문자열 토큰화

```c
#include <stdio.h>
#include <string.h>

int main() {
    char text[] = "apple,banana,cherry";
    char *token;

    token = strtok(text, ",");
    while (token != NULL) {
        printf("토큰: %s\n", token);
        token = strtok(NULL, ",");
    }

    return 0;
}
```

## 실전 예제

### 예제 1: 패스워드 검증 시스템

```c
#include <stdio.h>
#include <string.h>

int validatePassword(char *password) {
    int length = strlen(password);
    int hasUpper = 0, hasLower = 0, hasDigit = 0;

    // 길이 검사
    if (length < 8) {
        printf("패스워드는 최소 8자 이상이어야 합니다.\n");
        return 0;
    }

    // 문자 종류 검사
    for (int i = 0; i < length; i++) {
        if (password[i] >= 'A' && password[i] <= 'Z') {
            hasUpper = 1;
        } else if (password[i] >= 'a' && password[i] <= 'z') {
            hasLower = 1;
        } else if (password[i] >= '0' && password[i] <= '9') {
            hasDigit = 1;
        }
    }

    if (!hasUpper) {
        printf("대문자가 포함되어야 합니다.\n");
        return 0;
    }
    if (!hasLower) {
        printf("소문자가 포함되어야 합니다.\n");
        return 0;
    }
    if (!hasDigit) {
        printf("숫자가 포함되어야 합니다.\n");
        return 0;
    }

    return 1;  // 검증 통과
}

int main() {
    char password[50];

    printf("패스워드를 입력하세요: ");
    scanf("%s", password);

    if (validatePassword(password)) {
        printf("유효한 패스워드입니다!\n");
    } else {
        printf("패스워드가 조건을 만족하지 않습니다.\n");
    }

    return 0;
}
```

### 예제 2: 텍스트 처리 도구

```c
#include <stdio.h>
#include <string.h>

int main() {
    char text[200];
    char search[50], replace[50];
    char result[400] = "";

    printf("텍스트를 입력하세요: ");
    fgets(text, sizeof(text), stdin);

    printf("찾을 문자열: ");
    scanf("%s", search);

    printf("바꿀 문자열: ");
    scanf("%s", replace);

    // 간단한 문자열 치환
    char *pos = strstr(text, search);
    if (pos != NULL) {
        // 찾은 위치 이전까지 복사
        strncat(result, text, pos - text);

        // 치환할 문자열 추가
        strcat(result, replace);

        // 찾은 부분 이후 문자열 추가
        strcat(result, pos + strlen(search));

        printf("결과: %s", result);
    } else {
        printf("찾을 문자열이 없습니다.\n");
    }

    return 0;
}
```

### 예제 3: 간단한 스펠링 체커

```c
#include <stdio.h>
#include <string.h>

int main() {
    char dictionary[][20] = {
        "apple", "banana", "cherry", "dog", "elephant",
        "fish", "grape", "house", "ice", "jungle"
    };
    int dict_size = sizeof(dictionary) / sizeof(dictionary[0]);

    char word[20];
    int found = 0;

    printf("단어를 입력하세요: ");
    scanf("%s", word);

    // 사전에서 단어 검색
    for (int i = 0; i < dict_size; i++) {
        if (strcmp(word, dictionary[i]) == 0) {
            found = 1;
            break;
        }
    }

    if (found) {
        printf("'%s'는 올바른 단어입니다.\n", word);
    } else {
        printf("'%s'를 사전에서 찾을 수 없습니다.\n", word);

        // 유사한 단어 제안 (첫 글자가 같은 단어)
        printf("다음 단어들을 확인해보세요:\n");
        for (int i = 0; i < dict_size; i++) {
            if (dictionary[i][0] == word[0]) {
                printf("  - %s\n", dictionary[i]);
            }
        }
    }

    return 0;
}
```

## 문자열 함수 사용 시 주의사항

### 1. 버퍼 오버플로우 방지

```c
char dest[10];
char src[] = "This is a very long string";

// 위험: 대상 버퍼보다 큰 문자열 복사
// strcpy(dest, src);  // 버퍼 오버플로우!

// 안전: 크기 제한이 있는 함수 사용
strncpy(dest, src, sizeof(dest) - 1);
dest[sizeof(dest) - 1] = '\0';
```

### 2. 널 종료자 보장

```c
char buffer[10];
strncpy(buffer, "Hello World", 9);
buffer[9] = '\0';  // strncpy는 자동으로 널 종료자를 추가하지 않음!
```

### 3. 문자열 리터럴 수정 불가

```c
char *str = "Hello";  // 문자열 리터럴 (읽기 전용)
// strcpy(str, "World");  // 오류! 수정 불가

char str[] = "Hello";   // 문자 배열 (수정 가능)
strcpy(str, "World");   // 정상 작동
```

### 4. 반환값 확인

```c
char *pos = strstr(text, "찾을문자열");
if (pos != NULL) {
    // 문자열을 찾은 경우에만 처리
    printf("찾았음: %s\n", pos);
}
```

## 마무리

문자열 처리 함수들은 **텍스트 데이터를 효율적으로 조작하는 핵심 도구**입니다. 이 함수들을 마스터하면 복잡한 문자열 처리 작업도 간단하고 안전하게 수행할 수 있습니다.

**핵심 기억사항:**
- strlen(): 문자열 길이 측정
- strcpy()/strncpy(): 문자열 복사 (크기 주의)
- strcat()/strncat(): 문자열 연결 (버퍼 크기 주의)
- strcmp()/strncmp(): 문자열 비교 (==가 아닌 strcmp 사용)
- strchr()/strstr(): 문자/부분 문자열 검색
- 항상 버퍼 오버플로우와 널 종료자에 주의

문자열 함수들을 적절히 활용하면 텍스트 처리, 파싱, 검색, 치환 등 다양한 문자열 작업을 안전하고 효율적으로 수행할 수 있습니다.